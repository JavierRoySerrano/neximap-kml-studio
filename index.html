<!DOCTYPE html>
<!-- NexiMap KML Studio v4.0.0 - Unified open dialog, Undo/Redo, Eraser tool -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NexiMap KML Studio v4.0.0</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect x='2' y='2' width='28' height='28' rx='4' fill='%230096D6'/%3E%3Cpath d='M8 12L16 8L24 12L16 16Z' fill='white' opacity='0.9'/%3E%3Cpath d='M8 16L16 20L24 16' stroke='white' stroke-width='1.5' fill='none'/%3E%3Cpath d='M8 20L16 24L24 20' stroke='white' stroke-width='1.5' fill='none'/%3E%3C/svg%3E"/>
<style>
:root {
    --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    --bg: #ffffff;
    --bg-header: #fafafa;
    --bg-panel: #f8f9fa;
    --bg-hover: #e8e8e8;
    --bg-selected: #d0e8f5;
    --bg-active: #dbeafe;
    --border: #e0e0e0;
    --border-focus: #0096D6;
    --text: #333333;
    --text-secondary: #666666;
    --text-muted: #999999;
    --accent: #0096D6;
    --accent-hover: #0077aa;
    --accent-light: #e0f2fe;
    --accent-gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --shadow: 0 2px 8px rgba(0,0,0,0.1);
    --shadow-lg: 0 4px 20px rgba(0,0,0,0.15);
}

* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: var(--font); background: var(--bg); color: var(--text); overflow: hidden; height: 100vh; }

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: #f0f0f0; }
::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #aaa; }

/* === HEADER === */
header {
    display: flex;
    align-items: center;
    height: 40px;
    padding: 0 8px;
    background: var(--bg-header);
    border-bottom: 1px solid var(--border);
    gap: 4px;
    z-index: 2000;
    position: relative;
}

.app-logo {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 0 8px;
    font-weight: 700;
    font-size: 14px;
    color: var(--accent);
    white-space: nowrap;
}

.app-logo .ver {
    font-weight: 400;
    font-size: 10px;
    color: var(--text-muted);
    background: #eee;
    padding: 1px 5px;
    border-radius: 3px;
}

/* Menu items */
.menu-item {
    background: transparent;
    border: none;
    color: #444;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 13px;
    font-family: var(--font);
    border-radius: 4px;
    position: relative;
}
.menu-item:hover { background: var(--bg-hover); }

/* Dropdown menus */
.menu-dropdown {
    display: none;
    position: fixed;
    background: white;
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: var(--shadow-lg);
    min-width: 200px;
    padding: 4px 0;
    z-index: 9999;
}
.menu-dropdown.show { display: block; }

.menu-dropdown-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 14px;
    font-size: 13px;
    color: var(--text);
    cursor: pointer;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    font-family: var(--font);
}
.menu-dropdown-item:hover { background: var(--accent-light); color: var(--accent); }
.menu-dropdown-item .shortcut { margin-left: auto; font-size: 11px; color: var(--text-muted); }
.menu-sep { height: 1px; background: var(--border); margin: 4px 0; }

/* Toolbar buttons */
.tool-sep { width: 1px; height: 24px; background: #d0d0d0; margin: 0 4px; }

.tool-btn {
    background: transparent;
    border: 1px solid transparent;
    color: #555;
    padding: 5px 8px;
    cursor: pointer;
    font-size: 12px;
    font-family: var(--font);
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 4px;
    white-space: nowrap;
    transition: all 0.15s;
}
.tool-btn:hover { background: var(--bg-hover); border-color: #d0d0d0; }
.tool-btn.active {
    background: var(--bg-selected);
    color: #0066a0;
    border-color: var(--accent);
}
.tool-btn svg { width: 16px; height: 16px; flex-shrink: 0; }

.spacer { flex: 1; }

#statusText { font-size: 11px; color: var(--text-muted); padding-right: 8px; }

/* === MAIN LAYOUT === */
#mainLayout { display: flex; height: calc(100vh - 40px); position: relative; z-index: 1; }

/* === LEFT PANEL === */
#leftPanel {
    width: 260px;
    min-width: 180px;
    max-width: 400px;
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    position: relative;
}

.panel-header {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: white;
}

.panel-header h3 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
}

.panel-actions { display: flex; gap: 2px; }

.panel-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-muted);
    cursor: pointer;
    padding: 3px 5px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    font-size: 11px;
    font-family: var(--font);
    gap: 3px;
    transition: all 0.15s;
}
.panel-btn:hover { color: var(--text); background: var(--bg-hover); border-color: var(--border); }
.panel-btn svg { width: 14px; height: 14px; }

#folderTree { flex: 1; overflow-y: auto; padding: 4px 0; }

/* Tree folder */
.tree-folder { user-select: none; }

.tree-folder-header {
    display: flex;
    align-items: center;
    padding: 4px 6px;
    cursor: pointer;
    border-radius: 3px;
    margin: 1px 4px;
    transition: background 0.1s;
    gap: 3px;
}
.tree-folder-header:hover { background: var(--bg-hover); }
.tree-folder-header.selected { background: var(--bg-selected); }
.tree-folder-header.drag-over { outline: 2px dashed var(--accent); outline-offset: -2px; }

.tree-toggle {
    width: 16px; height: 16px;
    display: flex; align-items: center; justify-content: center;
    color: var(--text-muted); font-size: 9px; flex-shrink: 0;
    transition: transform 0.15s;
}
.tree-toggle.collapsed { transform: rotate(-90deg); }

.folder-icon { font-size: 14px; margin-right: 4px; }

.tree-folder-name {
    font-size: 12px; font-weight: 500; color: var(--text);
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

.tree-folder-count {
    font-size: 10px; color: var(--text-muted);
    background: #eee; padding: 0 5px; border-radius: 8px;
}

.tree-folder-children { padding-left: 14px; }
.tree-folder-children.hidden { display: none; }

/* Tree items */
.tree-item {
    display: flex; align-items: center;
    padding: 3px 6px 3px 8px;
    cursor: pointer; border-radius: 3px;
    margin: 1px 4px; transition: background 0.1s; gap: 5px;
}
.tree-item:hover { background: var(--bg-hover); }
.tree-item.selected { background: var(--bg-selected); }
.tree-item.drag-over { outline: 2px dashed var(--accent); }

.tree-item-color { width: 12px; height: 3px; border-radius: 2px; flex-shrink: 0; }

.tree-item-name {
    font-size: 11.5px; color: var(--text-secondary);
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

.tree-item-pts { font-size: 10px; color: var(--text-muted); }

.tree-item-vis {
    width: 16px; height: 16px; cursor: pointer; color: var(--text-muted);
    display: flex; align-items: center; flex-shrink: 0;
}
.tree-item-vis.hidden-item { opacity: 0.3; }

/* Resize handle */
#leftResize {
    position: absolute; right: -3px; top: 0; bottom: 0;
    width: 6px; cursor: col-resize; z-index: 10;
}
#leftResize:hover, #leftResize.active { background: var(--accent); opacity: 0.3; }

/* === MAP === */
#mapContainer { flex: 1; position: relative; z-index: 0; isolation: isolate; }
#map { width: 100%; height: 100%; }

/* Map layer selector - draggable */
#mapLayerSelector {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 500;
    background: white;
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: var(--shadow);
    padding: 0;
    transition: box-shadow 0.2s;
}
#mapLayerSelector.dragging { box-shadow: var(--shadow-lg); }
#mapLayerSelector.hidden { display: none; }

.map-layer-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 5px 8px; border-bottom: 1px solid var(--border); cursor: move;
    background: #fafafa; border-radius: 6px 6px 0 0; user-select: none;
}
.map-layer-header span { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); }
.map-layer-close { background: none; border: none; cursor: pointer; color: var(--text-muted); font-size: 14px; padding: 0 2px; line-height: 1; }
.map-layer-close:hover { color: var(--danger); }
.map-layer-body { padding: 4px; }

.map-layer-btn {
    display: block;
    width: 100%;
    padding: 5px 10px;
    font-size: 11px;
    font-family: var(--font);
    background: none;
    border: 1px solid transparent;
    border-radius: 4px;
    cursor: pointer;
    text-align: left;
    color: var(--text-secondary);
    transition: all 0.1s;
    white-space: nowrap;
}
.map-layer-btn:hover { background: #f0f0f0; }
.map-layer-btn.active { background: var(--bg-selected); color: var(--accent); border-color: var(--accent); font-weight: 600; }

/* === RIGHT PANEL === */
#rightPanel {
    width: 250px;
    min-width: 200px;
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    transition: width 0.2s, min-width 0.2s, padding 0.2s, opacity 0.2s;
}
#rightPanel.hidden {
    width: 0; min-width: 0; overflow: hidden; border-left: none; opacity: 0; padding: 0;
}

.prop-section {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
    background: white;
}

.prop-section h4 {
    font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.5px;
    color: var(--text-muted); margin-bottom: 8px;
}

.prop-row { display: flex; align-items: center; margin-bottom: 6px; gap: 8px; }
.prop-label { font-size: 11px; color: var(--text-secondary); width: 60px; flex-shrink: 0; }

.prop-input {
    flex: 1; background: white;
    border: 1px solid var(--border); color: var(--text);
    font-family: var(--font); font-size: 11px;
    padding: 4px 7px; border-radius: 4px; outline: none;
    transition: border-color 0.15s;
}
.prop-input:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(0,150,214,0.1); }

.prop-input[type="color"] { width: 32px; height: 26px; padding: 2px; cursor: pointer; }

.prop-input[type="range"] {
    -webkit-appearance: none; height: 4px;
    background: #ddd; border: none; border-radius: 2px; padding: 0;
}
.prop-input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    background: var(--accent); border-radius: 50%; cursor: pointer;
    border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.prop-range-val { font-size: 10px; color: var(--text-muted); width: 30px; text-align: right; }

.prop-btn {
    background: white; border: 1px solid var(--border);
    color: var(--text-secondary); font-family: var(--font);
    font-size: 11px; padding: 6px 10px; border-radius: 4px;
    cursor: pointer; transition: all 0.15s; width: 100%; text-align: center;
}
.prop-btn:hover { background: var(--accent-light); color: var(--accent); border-color: var(--accent); }
.prop-btn.danger:hover { background: #fef2f2; color: var(--danger); border-color: var(--danger); }
.prop-btn.success { background: #ecfdf5; color: var(--success); border-color: rgba(16,185,129,0.3); }
.prop-btn.success:hover { border-color: var(--success); }
.prop-btn.primary { background: var(--accent); color: white; border-color: var(--accent); }
.prop-btn.primary:hover { background: var(--accent-hover); }

#simplifyPreview { font-size: 10px; color: var(--text-muted); padding: 4px 0; line-height: 1.6; }

/* Empty state */
#emptyState {
    position: absolute; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 400; pointer-events: none;
}
#emptyState.hidden { display: none; }
#emptyState svg { width: 48px; height: 48px; color: #ccc; margin-bottom: 12px; }
#emptyState p { font-size: 13px; color: var(--text-muted); text-align: center; line-height: 1.6; }
#emptyState .hint { font-size: 11px; }

/* Context menu */
.ctx-menu {
    position: fixed; background: white;
    border: 1px solid var(--border); border-radius: 6px;
    padding: 4px 0; min-width: 200px;
    box-shadow: var(--shadow-lg); z-index: 7000; display: none;
    max-height: calc(100vh - 20px); overflow-y: auto;
}
.ctx-menu.show { display: block; }

.ctx-item {
    padding: 6px 14px; font-size: 12px; color: var(--text-secondary);
    cursor: pointer; display: flex; align-items: center; gap: 8px;
    transition: background 0.1s;
}
.ctx-item:hover { background: var(--accent-light); color: var(--accent); }
.ctx-item.danger { color: var(--danger); }
.ctx-item.danger:hover { background: #fef2f2; }
.ctx-sep { height: 1px; background: var(--border); margin: 4px 0; }

/* Toast */
#toastContainer {
    position: fixed; bottom: 20px; right: 20px;
    z-index: 6000; display: flex; flex-direction: column; gap: 8px;
}
.toast {
    background: white; border: 1px solid var(--border);
    border-radius: 6px; padding: 10px 16px; font-size: 12px;
    color: var(--text); box-shadow: var(--shadow-lg);
    animation: toastIn 0.3s ease; max-width: 320px;
}
.toast.success { border-left: 3px solid var(--success); }
.toast.error { border-left: 3px solid var(--danger); }
.toast.info { border-left: 3px solid var(--accent); }

@keyframes toastIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Vertex markers */
.vertex-marker {
    width: 10px; height: 10px;
    background: white;
    border: 2px solid var(--accent);
    border-radius: 50%;
    cursor: grab;
    transition: transform 0.1s;
    position: relative;
    z-index: 800 !important;
}
.vertex-marker:hover { transform: scale(1.5); background: var(--accent-light); }
.vertex-marker.dragging { cursor: grabbing; background: var(--accent); }

.vertex-marker-endpoint {
    width: 12px; height: 12px;
    background: var(--accent);
    border: 2px solid white;
    border-radius: 50%;
    cursor: grab;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    z-index: 800 !important;
}

/* Edit mode banner */
#editBanner {
    display: none; position: absolute; top: 10px; left: 50%;
    transform: translateX(-50%); z-index: 600;
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: white; padding: 6px 16px; border-radius: 20px;
    font-size: 12px; font-weight: 600;
    box-shadow: 0 2px 10px rgba(245,158,11,0.4);
    white-space: nowrap;
}
#editBanner.show { display: block; }

/* Hidden inputs */
#fileInput, #mergeFileInput, #geojsonInput, #logoInput { display: none; }

/* Color palette popup */
.color-palette {
    position: fixed; background: white; border: 1px solid var(--border);
    border-radius: 8px; box-shadow: var(--shadow-lg); padding: 10px;
    z-index: 9999; display: none; width: 220px;
}
.color-palette.show { display: block; }
.color-palette h5 { font-size: 10px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 6px; letter-spacing: 0.5px; }
.color-swatches { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; }
.color-swatch {
    width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
    border: 2px solid transparent; transition: all 0.1s;
}
.color-swatch:hover { transform: scale(1.15); border-color: #333; }
.color-swatch.active { border-color: #333; box-shadow: 0 0 0 2px white, 0 0 0 4px #333; }
.color-palette-custom { display: flex; gap: 6px; align-items: center; }
.color-palette-custom input[type="color"] { width: 32px; height: 28px; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; padding: 2px; }
.color-palette-custom span { font-size: 11px; color: var(--text-secondary); }

/* Logo overlay */
#logoOverlay {
    position: absolute; z-index: 500; cursor: move;
    user-select: none; display: none;
}
#logoOverlay.show { display: block; }
#logoOverlay img { max-width: 200px; max-height: 80px; pointer-events: none; }
#logoOverlay .logo-remove {
    position: absolute; top: -8px; right: -8px;
    width: 18px; height: 18px; background: var(--danger); color: white;
    border: 2px solid white; border-radius: 50%; font-size: 10px;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.15s;
}
#logoOverlay:hover .logo-remove { opacity: 1; }
#logoOverlay .logo-resize {
    position: absolute; bottom: -4px; right: -4px;
    width: 12px; height: 12px; background: white; border: 2px solid var(--accent);
    border-radius: 2px; cursor: se-resize; opacity: 0; transition: opacity 0.15s;
}
#logoOverlay:hover .logo-resize { opacity: 1; }



/* Multi-select: secondary selection highlight */
.tree-item.multi-selected { background: #e0f0ff; }
.tree-item.multi-selected.selected { background: var(--bg-selected); }
.tree-folder-header.folder-selected { background: var(--bg-selected); }

/* Multi-selection info */
.prop-multi-info { font-size: 11px; color: var(--text-secondary); padding: 2px 0; }
.prop-multi-count { font-weight: 600; color: var(--accent); }


/* Export dialog */
.export-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5); z-index: 9999;
    display: flex; align-items: center; justify-content: center;
}
.export-dialog {
    background: white; border-radius: 10px; box-shadow: var(--shadow-lg);
    padding: 24px; width: 360px; max-width: 90vw;
}
.export-dialog h3 { font-size: 15px; margin-bottom: 14px; color: var(--text); }
.export-dialog label { font-size: 12px; color: var(--text-secondary); display: block; margin-bottom: 4px; font-weight: 500; }
.export-dialog input, .export-dialog select {
    width: 100%; padding: 6px 10px; border: 1px solid var(--border); border-radius: 5px;
    font-size: 12px; font-family: var(--font); margin-bottom: 12px;
}
.export-dialog input:focus, .export-dialog select:focus { border-color: var(--accent); outline: none; }
.export-dialog-btns { display: flex; gap: 8px; justify-content: flex-end; margin-top: 6px; }
.export-dialog-btns button {
    padding: 6px 16px; border-radius: 5px; font-size: 12px; cursor: pointer;
    border: 1px solid var(--border); background: white; color: var(--text); font-family: var(--font);
}
.export-dialog-btns button.primary { background: var(--accent); color: white; border-color: var(--accent); }
.export-dialog-btns button:hover { opacity: 0.85; }

/* Print styles */
@media print {
    header, #leftPanel, #rightPanel, .resize-handle,
    #mapLayerSelector, #editBanner, #distancePanel,
    #ctxMenu, #toastContainer, #logoOverlay,
    .menu-dropdown, #pinTypeWindow, #colorPalette,
    .leaflet-control-zoom, .leaflet-control-attribution,
    #slackSettingsDialog, #pinTypeWindow, .export-overlay { display: none !important; }
    #mainLayout { display: block !important; }
    #mapContainer { position: absolute !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; width: 100vw !important; height: 100vh !important; }
    #map { width: 100% !important; height: 100% !important; }
    body { overflow: visible !important; }
}

/* Measure mode crosshair cursor */
.leaflet-container.measure-cursor { cursor: crosshair !important; }
.leaflet-container.measure-cursor .leaflet-interactive { cursor: crosshair !important; }

/* Eraser mode */
.leaflet-container.eraser-cursor { cursor: none !important; }
.leaflet-container.eraser-cursor .leaflet-interactive { cursor: none !important; }
#eraserBrush {
    position: fixed; pointer-events: none; z-index: 9000;
    border: 2px solid rgba(239,68,68,0.8); border-radius: 50%;
    background: rgba(239,68,68,0.12);
    display: none; transform: translate(-50%, -50%);
}
#eraserBrush.active { display: block; }
#eraserBrush.erasing { background: rgba(239,68,68,0.25); border-color: #ef4444; }
#eraserSizeSlider {
    position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
    z-index: 900; background: white; border: 1px solid var(--border);
    border-radius: 8px; box-shadow: var(--shadow); padding: 8px 14px;
    display: none; align-items: center; gap: 8px; font-size: 11px; color: var(--text-secondary);
}
#eraserSizeSlider.show { display: flex; }
#eraserSizeSlider input[type="range"] {
    -webkit-appearance: none; width: 120px; height: 4px;
    background: #ddd; border-radius: 2px; outline: none;
}
#eraserSizeSlider input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    background: var(--danger); border-radius: 50%; cursor: pointer;
    border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

/* Vertex dots overlay (non-edit, for visual reference) */
.vertex-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: rgba(255,255,255,0.85); border: 1.5px solid rgba(0,0,0,0.5);
    box-shadow: 0 0 3px rgba(0,0,0,0.3); z-index: 600 !important;
    transition: transform 0.1s;
}
.vertex-dot:hover { transform: scale(1.8); background: #fbbf24; border-color: #f59e0b; }
.leaflet-container:not(.measure-cursor) .vertex-dot { cursor: grab; }
.leaflet-container:not(.measure-cursor) .vertex-dot:active { cursor: grabbing; }
.vertex-dot-end {
    width: 10px; height: 10px; border-radius: 50%;
    background: rgba(255,255,255,0.95); border: 2px solid rgba(0,0,0,0.6);
    box-shadow: 0 0 4px rgba(0,0,0,0.4); z-index: 650 !important;
    transition: transform 0.1s;
}
.vertex-dot-end:hover { transform: scale(1.8); background: #fbbf24; border-color: #f59e0b; }
.leaflet-container:not(.measure-cursor) .vertex-dot-end { cursor: grab; }
.leaflet-container:not(.measure-cursor) .vertex-dot-end:active { cursor: grabbing; }

/* Measure snap preview dot */
.measure-snap-dot {
    width: 16px; height: 16px; border-radius: 50%;
    border: 3px solid #f59e0b; background: rgba(245,158,11,0.3);
    z-index: 2500 !important; pointer-events: none;
    animation: snapPulse 0.8s ease-in-out infinite;
}
@keyframes snapPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.3); opacity: 0.7; }
}


/* Ruler polyline tool */
#rulerPanel {
    position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.82); color: white; border-radius: 8px;
    padding: 8px 16px; z-index: 1200; display: none;
    font-family: var(--font); font-size: 12px; box-shadow: var(--shadow-lg);
    min-width: 220px; text-align: center; backdrop-filter: blur(4px);
    pointer-events: none;
}
#rulerPanel.show { display: block; }
#rulerPanel .ruler-dist { font-size: 18px; font-weight: 700; color: #fbbf24; margin: 2px 0; }
#rulerPanel .ruler-pts { font-size: 10px; color: rgba(255,255,255,0.6); }
#rulerPanel .ruler-label { font-size: 10px; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.5px; }

/* Ruler cursor */
.leaflet-container.ruler-cursor { cursor: crosshair !important; }
.leaflet-container.ruler-cursor .leaflet-interactive { cursor: crosshair !important; }

/* Geocoding search box */
.search-container {
    position: relative; display: flex; align-items: center;
    margin-left: auto; margin-right: 6px;
}
.search-input {
    width: 220px; height: 26px; padding: 0 28px 0 30px;
    border: 1px solid var(--border); border-radius: 13px;
    font-size: 12px; font-family: var(--font); color: var(--text);
    background: var(--bg); outline: none; transition: all 0.2s;
}
.search-input:focus { border-color: var(--accent); width: 300px; box-shadow: 0 0 0 2px rgba(0,150,214,0.15); }
.search-input::placeholder { color: var(--text-muted); }
.search-icon {
    position: absolute; left: 9px; top: 50%; transform: translateY(-50%);
    color: var(--text-muted); pointer-events: none; display: flex;
}
.search-clear {
    position: absolute; right: 7px; top: 50%; transform: translateY(-50%);
    background: none; border: none; color: var(--text-muted); cursor: pointer;
    font-size: 14px; display: none; padding: 0; line-height: 1;
}
.search-clear:hover { color: var(--danger); }
.search-input:not(:placeholder-shown) ~ .search-clear { display: block; }

/* Search results dropdown */
.search-results {
    position: absolute; top: 100%; left: 0; right: 0;
    margin-top: 4px; background: white; border: 1px solid var(--border);
    border-radius: 8px; box-shadow: var(--shadow-lg); z-index: 9000;
    max-height: 320px; overflow-y: auto; display: none;
}
.search-results.show { display: block; }
.search-result-item {
    display: flex; align-items: flex-start; gap: 8px;
    padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0;
    transition: background 0.1s;
}
.search-result-item:last-child { border-bottom: none; }
.search-result-item:hover { background: var(--bg-hover); }
.search-result-item.active { background: var(--bg-selected); }
.search-result-icon {
    flex-shrink: 0; width: 20px; height: 20px; display: flex;
    align-items: center; justify-content: center; color: var(--accent);
    margin-top: 1px;
}
.search-result-text { flex: 1; min-width: 0; }
.search-result-name { font-size: 12px; color: var(--text); font-weight: 500; }
.search-result-addr { font-size: 10px; color: var(--text-muted); margin-top: 1px;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.search-result-pin {
    flex-shrink: 0; padding: 3px 8px; border-radius: 4px; font-size: 10px;
    background: var(--accent); color: white; cursor: pointer; border: none;
    font-family: var(--font); opacity: 0; transition: opacity 0.15s;
    align-self: center;
}
.search-result-item:hover .search-result-pin { opacity: 1; }
.search-result-pin:hover { background: #0080b8; }
.search-loading { padding: 12px; text-align: center; font-size: 11px; color: var(--text-muted); }
.search-no-results { padding: 12px; text-align: center; font-size: 11px; color: var(--text-muted); }

/* Search temporary marker (pulsing blue dot) */
.search-temp-marker {
    width: 20px; height: 20px; border-radius: 50%;
    background: rgba(0, 150, 214, 0.3); border: 3px solid #0096D6;
    z-index: 4000 !important;
    animation: searchPulse 1.5s ease-in-out infinite;
}
@keyframes searchPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.4); opacity: 0.6; }
}

/* Context menu export submenu */
.ctx-submenu {
    position: relative;
}
.ctx-submenu-items {
    display: none; padding: 4px 0; margin: 2px 0 0 8px;
    border-left: 2px solid var(--border); background: var(--bg);
}
.ctx-submenu.open .ctx-submenu-items { display: block; }
.ctx-submenu-toggle {
    display: flex; align-items: center; justify-content: space-between; width: 100%;
    padding: 6px 12px; border: none; background: none; cursor: pointer;
    font-size: 12px; font-family: var(--font); color: var(--text); text-align: left;
}
.ctx-submenu-toggle:hover { background: var(--bg-hover); }
.ctx-submenu-toggle .ctx-arrow { font-size: 10px; color: var(--text-muted); }
.ctx-sub-item {
    padding: 5px 12px 5px 16px; cursor: pointer; font-size: 11px; color: var(--text);
    border: none; background: none; display: block; width: 100%;
    text-align: left; font-family: var(--font);
}
.ctx-sub-item:hover { background: var(--bg-hover); color: var(--accent); }
/* Crosshair cursor for pin placement mode */
.leaflet-container.pin-cursor { cursor: crosshair !important; }
.leaflet-container.pin-cursor .leaflet-interactive { cursor: crosshair !important; }
.leaflet-container.pin-cursor .leaflet-marker-icon { cursor: crosshair !important; }
.leaflet-container.draw-cursor { cursor: crosshair !important; }
.leaflet-container.draw-cursor .leaflet-interactive { cursor: crosshair !important; }
.leaflet-container.addpoint-cursor { cursor: crosshair !important; }
.leaflet-container.addpoint-cursor .leaflet-interactive { cursor: crosshair !important; }

/* Draggable pin marker */
.pin-marker.draggable-pin { cursor: grab; }
.pin-marker.draggable-pin:active { cursor: grabbing; }

/* Compact pin color swatch in properties */
.prop-pin-color-row { display: flex; align-items: center; gap: 6px; }
.prop-pin-color-current {
    width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
    border: 2px solid #ccc; transition: all 0.15s; flex-shrink: 0;
}
.prop-pin-color-current:hover { border-color: #666; transform: scale(1.1); }
.prop-pin-color-expand {
    display: none; flex-wrap: wrap; gap: 3px; padding: 6px 0;
}
.prop-pin-color-expand.show { display: flex; }

/* Pin type selector in properties */
.prop-pin-type-row { display: flex; align-items: center; gap: 6px; }
.prop-pin-type-current {
    width: 28px; height: 36px; cursor: pointer; transition: transform 0.15s;
}
.prop-pin-type-current:hover { transform: scale(1.1); }
.prop-pin-type-grid {
    display: none; grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 6px 0;
}
.prop-pin-type-grid.show { display: grid; }
.prop-pin-type-opt {
    display: flex; flex-direction: column; align-items: center; gap: 2px;
    padding: 4px 2px; border: 2px solid transparent; border-radius: 4px;
    cursor: pointer; transition: all 0.15s; background: #fafafa;
}
.prop-pin-type-opt:hover { background: var(--accent-light); border-color: var(--accent); }
.prop-pin-type-opt.active { border-color: var(--accent); background: var(--bg-selected); }
.prop-pin-type-opt svg { width: 20px; height: 28px; }
.prop-pin-type-opt span { font-size: 8px; color: var(--text-muted); text-align: center; line-height: 1.1; }

/* Tree item pin SVG icon */
.tree-pin-icon { width: 12px; height: 16px; flex-shrink: 0; }
.tree-line-icon { width: 14px; height: 8px; flex-shrink: 0; }

/* Editable GPS input */
.prop-gps-input {
    font-size: 11px; font-family: monospace; color: var(--text);
    border: 1px solid transparent; border-radius: 3px;
    padding: 1px 4px; background: transparent; width: 110px;
    transition: all 0.15s;
}
.prop-gps-input:hover { border-color: var(--border); background: white; }
.prop-gps-input:focus { border-color: var(--accent); background: white; outline: none; }

/* Pin marker on map */
.pin-marker {
    width: 24px; height: 36px; position: relative; overflow: visible;
}
.pin-marker svg { width: 24px; height: 36px; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3)); }
.pin-label {
    position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
    white-space: nowrap; font-size: 11px; font-weight: 600;
    text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white, 0 0 4px white;
    pointer-events: none; padding-bottom: 2px;
}

/* Inline color swatches in properties */
.prop-color-swatch {
    width: 18px; height: 18px; border-radius: 3px; cursor: pointer;
    border: 2px solid transparent; transition: all 0.1s; flex-shrink: 0;
}
.prop-color-swatch:hover { transform: scale(1.2); border-color: #666; }
.prop-color-swatch.active { border-color: #333; box-shadow: 0 0 0 1px white, 0 0 0 3px #333; }

/* Layer visibility filters */
#layerFilters {
    padding: 6px 10px;
    border-top: 1px solid var(--border);
    background: white;
    display: flex; gap: 10px; flex-wrap: wrap;
}
.filter-toggle {
    display: flex; align-items: center; gap: 4px;
    font-size: 11px; color: var(--text-secondary); cursor: pointer;
    user-select: none;
}
.filter-toggle input { accent-color: var(--accent); margin: 0; cursor: pointer; }

/* Folder checkbox */
.tree-folder-check {
    width: 14px; height: 14px; margin: 0 2px 0 0;
    accent-color: var(--accent); cursor: pointer; flex-shrink: 0;
}
/* Segment (layer) checkbox */
.tree-item-check {
    width: 13px; height: 13px; margin: 0 1px 0 0;
    accent-color: var(--accent); cursor: pointer; flex-shrink: 0;
}

/* Folder/subfolder visibility eye */
.tree-folder-vis {
    width: 16px; height: 16px; cursor: pointer; color: var(--text-muted);
    display: flex; align-items: center; flex-shrink: 0; margin-left: auto;
}
.tree-folder-vis.folder-hidden { opacity: 0.3; }

/* Match selection button */
#matchSelBtn {
    background: none; border: 1px solid var(--border); border-radius: 4px;
    padding: 2px 7px; cursor: pointer; font-size: 10px; color: var(--text-secondary);
    display: flex; align-items: center; gap: 3px; white-space: nowrap;
    transition: all 0.15s;
}
#matchSelBtn:hover { background: var(--accent-light); border-color: var(--accent); color: var(--accent); }


/* Pin type selector window */
#pinTypeWindow {
    position: fixed; background: white; border: 1px solid var(--border);
    border-radius: 8px; box-shadow: var(--shadow-lg); z-index: 8000;
    display: none; width: 280px;
}
#pinTypeWindow.show { display: block; }
.pin-type-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 12px; border-bottom: 1px solid var(--border);
    cursor: move; user-select: none; background: #fafafa; border-radius: 8px 8px 0 0;
}
.pin-type-header h5 { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin:0; }
.pin-type-close { background: none; border: none; cursor: pointer; color: var(--text-muted); font-size: 14px; padding: 0; }
.pin-type-close:hover { color: var(--danger); }
.pin-type-grid {
    display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;
    padding: 10px; max-height: 300px; overflow-y: auto;
}
.pin-type-option {
    display: flex; flex-direction: column; align-items: center; gap: 4px;
    padding: 8px 4px; border: 2px solid transparent; border-radius: 6px;
    cursor: pointer; transition: all 0.15s; background: #fafafa;
}
.pin-type-option:hover { background: var(--accent-light); border-color: var(--accent); }
.pin-type-option.active { border-color: var(--accent); background: var(--bg-selected); }
.pin-type-option svg { width: 24px; height: 32px; }
.pin-type-option span { font-size: 9px; color: var(--text-muted); text-align: center; line-height: 1.2; }

/* Distance panel on map */
#distancePanel {
    position: absolute; bottom: 20px; left: 50%;
    transform: translateX(-50%); z-index: 600;
    background: white; border: 1px solid var(--border);
    border-radius: 8px; box-shadow: var(--shadow-lg);
    padding: 0; display: none; min-width: 320px; max-width: 420px; font-size: 12px;
    resize: both; overflow: hidden;
}
#distancePanel.show { display: flex; flex-direction: column; }
#distancePanel.minimized #distanceContent { display: none; }
#distancePanel.minimized { min-width: 220px; min-height: auto !important; height: auto !important; resize: none; }
.dist-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 6px 10px; background: var(--bg-secondary); border-bottom: 1px solid var(--border);
    cursor: move; user-select: none; border-radius: 8px 8px 0 0; flex-shrink: 0;
}
.dist-header h5 { font-size: 10px; font-weight: 600; text-transform: uppercase; color: var(--text-muted); margin: 0; }
.dist-header-btns { display: flex; gap: 4px; }
.dist-header-btns button { background: none; border: none; cursor: pointer; color: var(--text-muted); font-size: 13px; padding: 0 3px; line-height: 1; }
.dist-header-btns button:hover { color: var(--danger); }
#distanceContent { padding: 10px 14px; overflow-y: auto; flex: 1; }
.dist-row { display: flex; justify-content: space-between; margin-bottom: 3px; }
.dist-row .dist-label { color: var(--text-secondary); }
.dist-row .dist-value { font-weight: 600; color: var(--text); font-family: monospace; }
.dist-row .dist-value.green { color: var(--success); }
.dist-row .dist-value.blue { color: var(--accent); }
.dist-row .dist-value.orange { color: #e67e22; }
.dist-mode-toggle {
    display: flex; align-items: center; gap: 6px; margin: 8px 0 6px; padding: 6px 8px;
    background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border);
}
.dist-mode-toggle label { font-size: 10px; color: var(--text-secondary); cursor: pointer; flex: 1; text-align: center; }
.dist-mode-toggle label.active { color: var(--text); font-weight: 600; }
.dist-mode-switch {
    position: relative; width: 36px; height: 18px; flex-shrink: 0;
}
.dist-mode-switch input { opacity: 0; width: 0; height: 0; }
.dist-mode-switch .slider {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: var(--accent); border-radius: 9px; cursor: pointer; transition: 0.2s;
}
.dist-mode-switch .slider:before {
    content: ''; position: absolute; height: 14px; width: 14px; left: 2px; bottom: 2px;
    background: white; border-radius: 50%; transition: 0.2s;
}
.dist-mode-switch input:checked + .slider { background: #e67e22; }
.dist-mode-switch input:checked + .slider:before { transform: translateX(18px); }
.dist-gap-info {
    font-size: 9px; color: var(--text-muted); padding: 4px 0; font-style: italic;
}

/* Topology diagram modal */
#topoModal {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 2000; background: rgba(0,0,0,0.6); align-items: center; justify-content: center;
}
#topoModal.show { display: flex; }
#topoModalInner {
    background: white; border-radius: 10px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    width: 90vw; height: 85vh; display: flex; flex-direction: column; overflow: hidden;
}
.topo-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 16px; background: var(--bg-header); border-bottom: 1px solid var(--border);
}
.topo-header h3 { margin: 0; font-size: 14px; color: var(--text); }
.topo-header-btns { display: flex; gap: 8px; align-items: center; }
.topo-header-btns button { background: none; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; padding: 3px 8px; font-size: 11px; color: var(--text-secondary); }
.topo-header-btns button:hover { background: var(--bg-hover); }
.topo-body { flex: 1; position: relative; overflow: hidden; background: #f0f2f5; }
#topoCanvas { width: 100%; height: 100%; display: block; }
.topo-legend {
    position: absolute; bottom: 10px; left: 10px; background: rgba(255,255,255,0.92);
    border-radius: 6px; padding: 8px 12px; font-size: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.topo-legend-item { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; }
.topo-legend-line { width: 24px; height: 3px; border-radius: 2px; }
.topo-info {
    position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.92);
    border-radius: 6px; padding: 8px 12px; font-size: 11px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    max-width: 250px;
}

/* Measurement A/B end markers */
.measure-marker-a {
    width: 14px; height: 14px; background: var(--success); border: 2px solid white;
    border-radius: 50%; box-shadow: 0 1px 4px rgba(0,0,0,0.4); z-index: 900 !important;
}
.measure-marker-b {
    width: 14px; height: 14px; background: var(--danger); border: 2px solid white;
    border-radius: 50%; box-shadow: 0 1px 4px rgba(0,0,0,0.4); z-index: 900 !important;
}


/* Settings toggle switch */
.settings-toggle {
    display: flex; align-items: center; gap: 8px; margin-bottom: 10px;
}
.settings-toggle label { font-size: 12px; color: var(--text-secondary); flex: 1; }
.toggle-switch {
    position: relative; width: 36px; height: 20px; flex-shrink: 0;
}
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.toggle-slider {
    position: absolute; inset: 0; background: #ccc; border-radius: 20px;
    cursor: pointer; transition: 0.2s;
}
.toggle-slider:before {
    content: ''; position: absolute; width: 16px; height: 16px;
    left: 2px; bottom: 2px; background: white; border-radius: 50%;
    transition: 0.2s;
}
.toggle-switch input:checked + .toggle-slider { background: var(--accent); }
.toggle-switch input:checked + .toggle-slider:before { transform: translateX(16px); }

/* Viewport bias inline toggle next to search */
.search-bias-toggle {
    display: flex; align-items: center; gap: 4px; margin-left: 6px;
    cursor: pointer; user-select: none; white-space: nowrap;
}
.search-bias-toggle .mini-toggle {
    position: relative; width: 28px; height: 16px; flex-shrink: 0;
}
.search-bias-toggle .mini-toggle input { opacity: 0; width: 0; height: 0; position: absolute; }
.search-bias-toggle .mini-slider {
    position: absolute; inset: 0; background: #ccc; border-radius: 16px;
    cursor: pointer; transition: 0.2s;
}
.search-bias-toggle .mini-slider:before {
    content: ''; position: absolute; width: 12px; height: 12px;
    left: 2px; bottom: 2px; background: white; border-radius: 50%;
    transition: 0.2s;
}
.search-bias-toggle .mini-toggle input:checked + .mini-slider { background: var(--accent); }
.search-bias-toggle .mini-toggle input:checked + .mini-slider:before { transform: translateX(12px); }
.search-bias-label {
    font-size: 10px; color: var(--text-muted); transition: color 0.2s;
}
.search-bias-label.active { color: var(--accent); font-weight: 500; }
/* Settings dialog overlay */
.settings-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.3); z-index: 9998;
    display: none; align-items: center; justify-content: center;
}
.settings-overlay.show { display: flex; }
.settings-dialog {
    background: white; border-radius: 10px; box-shadow: var(--shadow-lg);
    padding: 20px; min-width: 320px; max-width: 400px;
}
.settings-dialog h4 { font-size: 13px; font-weight: 600; color: var(--text); margin-bottom: 12px; }
.settings-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
.settings-row label { font-size: 12px; color: var(--text-secondary); width: 120px; }
.settings-row input { flex: 1; padding: 5px 8px; border: 1px solid var(--border); border-radius: 4px; font-size: 12px; font-family: var(--font); }
.settings-row input:focus { border-color: var(--accent); outline: none; }
.settings-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 14px; }
</style>
</head>
<body>

<!-- HEADER -->
<header>
    <div class="app-logo">
        <svg width="20" height="20" viewBox="0 0 32 32"><rect x="2" y="2" width="28" height="28" rx="4" fill="#0096D6"/><path d="M8 12L16 8L24 12L16 16Z" fill="white" opacity="0.9"/><path d="M8 16L16 20L24 16" stroke="white" stroke-width="1.5" fill="none"/><path d="M8 20L16 24L24 20" stroke="white" stroke-width="1.5" fill="none"/></svg>
        NexiMap KML Studio
        <span class="ver">v4.0.0</span>
    </div>

    <!-- File Menu -->
    <button class="menu-item" onclick="toggleMenu('fileMenu', this)">File</button>
    <!-- Edit Menu -->
    <button class="menu-item" onclick="toggleMenu('editMenu', this)">Edit</button>
    <!-- View Menu -->
    <button class="menu-item" onclick="toggleMenu('viewMenu', this)">View</button>
    <!-- Tools Menu -->
    <button class="menu-item" onclick="toggleMenu('toolsMenu', this)">Tools</button>

    <div class="tool-sep"></div>

    <!-- Toolbar buttons -->
    <button class="tool-btn" id="btnEditMode" onclick="toggleEditMode()" title="Toggle vertex editing (drag dots to move)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
    </button>
    <button class="tool-btn" id="btnAddPoint" onclick="toggleAddPointMode()" title="Click on map to insert vertices into selected line">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
    </button>
    <button class="tool-btn" id="btnDrawLine" onclick="toggleDrawMode()" title="Draw a new polyline on the map">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 20 8 10 14 14 20 4"/><circle cx="4" cy="20" r="2"/><circle cx="8" cy="10" r="2"/><circle cx="14" cy="14" r="2"/><circle cx="20" cy="4" r="2"/></svg>
    </button>
    <button class="tool-btn" id="btnPlacePin" onclick="togglePinMode()" title="Place a pin marker on the map">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
    </button>
    <button class="tool-btn" id="btnPinTypes" onclick="togglePinTypeWindow()" title="Choose pin icon type">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
    </button>
    <button class="tool-btn" id="btnMeasurePath" onclick="toggleMeasureMode()" title="Measure A-End to B-End distance on a line">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12h20"/><path d="M6 8v8"/><path d="M18 8v8"/><path d="M10 10v4"/><path d="M14 10v4"/></svg>
    </button>
    <button class="tool-btn" id="btnRuler" onclick="toggleRulerMode()" title="Ruler: draw a polyline to measure distance">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 21L21 3"/><path d="M6 18l2-2"/><path d="M9 15l2-2"/><path d="M12 12l2-2"/><path d="M15 9l2-2"/><circle cx="3" cy="21" r="1.5" fill="currentColor"/><circle cx="21" cy="3" r="1.5" fill="currentColor"/></svg>
    </button>
    <button class="tool-btn" id="btnEraser" onclick="toggleEraserMode()" title="Eraser: drag across map to delete features">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8l10-10c.8-.8 2-.8 2.8 0l5.6 5.6c.8.8.8 2 0 2.8L16 17"/><path d="M6 11l7 7"/></svg>
    </button>

    <div class="tool-sep"></div>

    <button class="tool-btn" id="btnColorPick" onclick="showColorPalette(this)" title="Color palette">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="8" r="1.5" fill="#ef4444"/><circle cx="16" cy="11" r="1.5" fill="#3b82f6"/><circle cx="14" cy="15" r="1.5" fill="#10b981"/><circle cx="9" cy="14" r="1.5" fill="#f59e0b"/><circle cx="8" cy="10" r="1.5" fill="#8b5cf6"/></svg>
    </button>
    <button class="tool-btn" onclick="promptLineWidth()" title="Set line width">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="4" y1="6" x2="20" y2="6" stroke-width="1"/><line x1="4" y1="12" x2="20" y2="12" stroke-width="3"/><line x1="4" y1="18" x2="20" y2="18" stroke-width="5"/></svg>
    </button>
    <button class="tool-btn" id="btnToggleMapLayers" onclick="toggleMapLayerSelector()" title="Toggle map type selector">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
    </button>
    <button class="tool-btn" id="btnToggleProps" onclick="togglePropertiesPanel()" title="Toggle properties panel">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M9 3v18"/></svg>
    </button>
    <button class="tool-btn" id="btnTopology" onclick="showTopologyDiagram()" title="Show topology diagram of segment connectivity">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="5" cy="6" r="2.5"/><circle cx="19" cy="6" r="2.5"/><circle cx="12" cy="18" r="2.5"/><path d="M7.5 6h9M6.5 8l4 8M17.5 8l-4 8"/></svg>
    </button>

    <div class="spacer"></div>

    <!-- Geocoding search (v2.3) -->
    <div class="search-container" id="searchContainer">
        <span class="search-icon">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="11" cy="11" r="7"/><path d="M21 21l-4.35-4.35"/></svg>
        </span>
        <input type="text" class="search-input" id="searchInput" placeholder="Search address or place…" autocomplete="off" spellcheck="false">
        <button class="search-clear" id="searchClear" onclick="clearSearch()">&times;</button>
        <div class="search-results" id="searchResults"></div>
    </div>
    <label class="search-bias-toggle" title="Viewport bias — prioritise search results near current map view">
        <div class="mini-toggle">
            <input type="checkbox" id="biasToggleInline" onchange="toggleViewportBias(this.checked)">
            <span class="mini-slider"></span>
        </div>
        <span class="search-bias-label" id="biasLabel">Bias</span>
    </label>

    <span id="statusText">Ready</span>
</header>

<!-- MAIN LAYOUT -->
<div id="mainLayout">
    <!-- LEFT PANEL -->
    <div id="leftPanel">
        <div class="panel-header">
            <h3>Layers</h3>
            <div class="panel-actions">
                <button class="panel-btn" onclick="createNewFolder()" title="New folder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                    New
                </button>
                <button class="panel-btn" onclick="expandAllFolders()" title="Expand all">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                </button>
                <button class="panel-btn" onclick="collapseAllFolders()" title="Collapse all">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
                </button>
            </div>
        </div>
        <div id="folderTree"></div>
        <div id="layerFilters">
            <label class="filter-toggle">
                <input type="checkbox" id="filterLines" checked onchange="applyLayerFilters()">
                ━ Lines
            </label>
            <label class="filter-toggle">
                <input type="checkbox" id="filterPins" checked onchange="applyLayerFilters()">
                📍 Pins
            </label>
            <label class="filter-toggle" title="Show vertex dots when zoomed in (configurable in Settings)">
                <input type="checkbox" id="filterVertexDots" onchange="applyLayerFilters()">
                ○ Vertices <span id="vertexZoomHint" style="font-size:9px;color:var(--text-muted);"></span>
            </label>
            <button id="matchSelBtn" onclick="matchCheckboxesToVisibility()" title="Set checkboxes to match current visibility state">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                Match ☑ ↔ 👁
            </button>
        </div>
        <div id="leftResize"></div>
    </div>

    <!-- MAP -->
    <div id="mapContainer">
        <div id="map"></div>
        <div id="editBanner">✏️ EDIT MODE — Drag vertices to reposition • Right-click vertex to delete</div>
        <div id="eraserBrush"></div>
        <div id="eraserSizeSlider">
            <span>🧹</span>
            <input type="range" id="eraserSizeRange" min="20" max="200" value="60" oninput="updateEraserSize(this.value)">
            <span id="eraserSizeLabel">60px</span>
        </div>
        <div id="mapLayerSelector">
            <div class="map-layer-header" id="mapLayerDragHandle">
                <span>Map Type</span>
                <button class="map-layer-close" onclick="toggleMapLayerSelector()">&#10005;</button>
            </div>
            <div class="map-layer-body">
            <button class="map-layer-btn active" data-layer="osm" onclick="switchMapLayer('osm')">🗺️ Street Map</button>
            <button class="map-layer-btn" data-layer="osm-hot" onclick="switchMapLayer('osm-hot')">🏙️ Humanitarian</button>
            <button class="map-layer-btn" data-layer="carto-voyager" onclick="switchMapLayer('carto-voyager')">🏷️ Labels + Detail</button>
            <button class="map-layer-btn" data-layer="carto-light" onclick="switchMapLayer('carto-light')">☁️ Light Clean</button>
            <button class="map-layer-btn" data-layer="carto-dark" onclick="switchMapLayer('carto-dark')">🌑 Dark</button>
            <button class="map-layer-btn" data-layer="satellite" onclick="switchMapLayer('satellite')">🛰️ Satellite</button>
            <button class="map-layer-btn" data-layer="sat-labels" onclick="switchMapLayer('sat-labels')">🛰️ Satellite + Labels</button>
            <button class="map-layer-btn" data-layer="topo" onclick="switchMapLayer('topo')">⛰️ Topographic</button>
            </div>
        </div>
        <div id="emptyState">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/>
            </svg>
            <p>Open a KML, KMZ, or GeoJSON file to begin<br><span class="hint">Use File &gt; Open or drag &amp; drop onto the map</span></p>
        </div>
        <div id="logoOverlay">
            <img id="logoImage" src="" alt="Logo">
            <div class="logo-remove" onclick="removeLogo()">✕</div>
            <div class="logo-resize" id="logoResizeHandle"></div>
        </div>
        <div id="rulerPanel">
            <div class="ruler-label">📏 Ruler Measurement</div>
            <div class="ruler-dist" id="rulerDistance">0.00 m</div>
            <div class="ruler-pts" id="rulerPoints">0 points — Click to add, Enter/dblclick to finish, Escape to cancel</div>
        </div>
        <div id="distancePanel">
            <div class="dist-header" id="distDragHandle">
                <h5>DISTANCE MEASUREMENT</h5>
                <div class="dist-header-btns">
                    <button onclick="toggleDistMinimize()" title="Minimize/Expand" id="distMinBtn">&#9660;</button>
                    <button onclick="closeDistancePanel()" title="Close">&#10005;</button>
                </div>
            </div>
            <div id="distanceContent"></div>
        </div>
    </div>


    <!-- TOPOLOGY MODAL -->
    <div id="topoModal">
        <div id="topoModalInner">
            <div class="topo-header">
                <h3>🔗 Topology Diagram — Simplified Graph</h3>
                <div class="topo-header-btns">
                    <button onclick="topoZoomIn()">Zoom +</button>
                    <button onclick="topoZoomOut()">Zoom −</button>
                    <button onclick="topoResetView()">Reset</button>
                    <button onclick="closeTopologyDiagram()" style="color:var(--danger);font-weight:600;">✕ Close</button>
                </div>
            </div>
            <div class="topo-body">
                <canvas id="topoCanvas"></canvas>
                <div class="topo-legend">
                    <div class="topo-legend-item"><div class="topo-legend-line" style="background:#0096D6;"></div><span>Cable path (merged)</span></div>
                    <div class="topo-legend-item"><div class="topo-legend-line" style="background:#e67e22;border:1px dashed #c0392b;height:1px;"></div><span>Bridge (island link)</span></div>
                    <div class="topo-legend-item"><svg width="12" height="12"><circle cx="6" cy="6" r="5" fill="#10b981" stroke="white" stroke-width="1.5"/></svg><span>Terminal</span></div>
                    <div class="topo-legend-item"><svg width="12" height="12"><circle cx="6" cy="6" r="5" fill="#ef4444" stroke="white" stroke-width="1.5"/></svg><span>Hub / Branch</span></div>
                </div>
                <div class="topo-info" id="topoInfo">Hover over a node or edge for details</div>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL -->
    <div id="rightPanel">
        <div class="panel-header"><h3>Properties</h3></div>
        <div id="propsContent">
            <div class="prop-section" id="propNone">
                <p style="font-size:11px;color:var(--text-muted);text-align:center;padding:20px 0;">Select a layer to edit properties</p>
            </div>
            <div class="prop-section" id="propName" style="display:none;">
                <h4>Layer Info</h4>
                <div class="prop-row">
                    <span class="prop-label">Name</span>
                    <input class="prop-input" type="text" id="propNameInput" onchange="updateSelectedName(this.value)">
                </div>
                <div class="prop-row">
                    <span class="prop-label">Points</span>
                    <span id="propPointCount" style="font-size:11px;color:var(--text-muted);">0</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Type</span>
                    <span id="propType" style="font-size:11px;color:var(--text-muted);">—</span>
                </div>
            </div>
            <!-- Pin GPS + Description + Pin Type (Enhancement 2 + v1.7) -->
            <div class="prop-section" id="propPinInfo" style="display:none;">
                <h4>Pin Location</h4>
                <div class="prop-row">
                    <span class="prop-label">Latitude</span>
                    <input class="prop-gps-input" type="text" id="propPinLat" value="—" onchange="updatePinGPS('lat', this.value)" onkeydown="if(event.key==='Enter'){this.blur();}">
                </div>
                <div class="prop-row">
                    <span class="prop-label">Longitude</span>
                    <input class="prop-gps-input" type="text" id="propPinLng" value="—" onchange="updatePinGPS('lng', this.value)" onkeydown="if(event.key==='Enter'){this.blur();}">
                </div>
                <div class="prop-row" style="align-items:flex-start;">
                    <span class="prop-label">Note</span>
                    <textarea class="prop-input" id="propPinDesc" rows="3" style="resize:vertical;min-height:40px;" onchange="updatePinDescription(this.value)" placeholder="Add a description..."></textarea>
                </div>
                <h4 style="margin-top:8px;">Pin Type</h4>
                <div class="prop-row">
                    <span class="prop-label">Icon</span>
                    <div class="prop-pin-type-row">
                        <div id="propPinTypeCurrent" class="prop-pin-type-current" onclick="togglePropPinTypeGrid()" title="Click to change pin type"></div>
                        <span id="propPinTypeName" style="font-size:10px;color:var(--text-muted);">Default</span>
                    </div>
                </div>
                <div class="prop-pin-type-grid" id="propPinTypeGrid"></div>
                <div class="prop-row" style="margin-top:6px;">
                    <span class="prop-label">Show label</span>
                    <label style="display:flex;align-items:center;gap:6px;cursor:pointer;">
                        <input type="checkbox" id="propPinShowLabel" checked onchange="togglePinLabel(this.checked)">
                        <span style="font-size:10px;color:var(--text-muted);" id="propPinLabelStatus">Visible</span>
                    </label>
                </div>
            </div>
            <!-- Distance info for lines (Enhancement 4/5) -->
            <div class="prop-section" id="propDistance" style="display:none;">
                <h4>Distance</h4>
                <div class="prop-row">
                    <span class="prop-label">Geometric</span>
                    <span id="propDistGeo" style="font-size:11px;color:var(--text);font-family:monospace;">—</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Estimated</span>
                    <span id="propDistEst" style="font-size:11px;color:var(--accent);font-family:monospace;">—</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Slack</span>
                    <span id="propSlackPct" style="font-size:11px;color:var(--text-muted);">—</span>
                </div>

            </div>
            <div class="prop-section" id="propStyle" style="display:none;">
                <h4>Style</h4>
                <!-- Compact color (pins): single swatch expands on click -->
                <div class="prop-row" id="propColorCompactRow" style="display:none;">
                    <span class="prop-label">Color</span>
                    <div class="prop-pin-color-row">
                        <div id="propColorCompactSwatch" class="prop-pin-color-current" onclick="togglePinColorExpand()" title="Click to change color"></div>
                        <span id="propColorCompactHex" style="font-size:10px;color:var(--text-muted);font-family:monospace;"></span>
                    </div>
                </div>
                <div class="prop-pin-color-expand" id="propColorExpandPanel">
                    <div id="propColorExpandSwatches" style="display:flex;flex-wrap:wrap;gap:3px;"></div>
                    <div style="display:flex;align-items:center;gap:4px;margin-top:4px;">
                        <input class="prop-input" type="color" id="propColorExpandCustom" value="#3b82f6" onchange="updateSelectedColor(this.value); updateCompactColorDisplay();" style="width:28px;height:24px;padding:1px;flex:none;">
                        <span style="font-size:10px;color:var(--text-muted);">Custom</span>
                    </div>
                </div>
                <!-- Full color (lines): full palette always visible -->
                <div class="prop-row" id="propColorFullRow">
                    <span class="prop-label">Color</span>
                    <div id="propColorSwatches" style="display:flex;flex-wrap:wrap;gap:3px;flex:1;"></div>
                </div>
                <div class="prop-row" style="margin-top:2px;" id="propColorFullCustomRow">
                    <span class="prop-label"></span>
                    <input class="prop-input" type="color" id="propColorCustom" value="#3b82f6" onchange="updateSelectedColor(this.value)" style="width:28px;height:24px;padding:1px;flex:none;">
                    <span style="font-size:10px;color:var(--text-muted);">Custom</span>
                    <span id="propColorHex" style="font-size:10px;color:var(--text-muted);margin-left:auto;font-family:monospace;"></span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Width</span>
                    <input class="prop-input" type="range" id="propWidth" min="1" max="12" value="3" oninput="updateSelectedWidth(this.value)">
                    <span class="prop-range-val" id="propWidthVal">3</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Opacity</span>
                    <input class="prop-input" type="range" id="propOpacity" min="0.1" max="1" step="0.05" value="0.9" oninput="updateSelectedOpacity(this.value)">
                    <span class="prop-range-val" id="propOpacityVal">0.9</span>
                </div>
            </div>
            <div class="prop-section" id="propSimplify" style="display:none;">
                <h4>Simplification</h4>
                <p style="font-size:10px;color:var(--text-muted);margin-bottom:8px;">Douglas-Peucker algorithm. Lower tolerance = more detail.</p>
                <div class="prop-row">
                    <span class="prop-label">Tolerance</span>
                    <input class="prop-input" type="range" id="propTolerance" min="0.0001" max="0.1" step="0.0001" value="0.001" oninput="previewSimplify(this.value)">
                    <span class="prop-range-val" id="propToleranceVal">0.001</span>
                </div>
                <div id="simplifyPreview"></div>
                <div style="display:flex;gap:6px;margin-top:6px;">
                    <button class="prop-btn primary" onclick="applySimplify()" style="flex:1;">Apply</button>
                    <button class="prop-btn" onclick="undoSimplify()" style="flex:1;">Undo</button>
                </div>
            </div>
            <div class="prop-section" id="propActions" style="display:none;">
                <h4>Actions</h4>
                <button class="prop-btn" onclick="zoomToSelected()">Zoom to Layer</button>
                <div style="height:5px;"></div>
                <button class="prop-btn" onclick="calcSelectedDistance()">📐 Calculate Distance</button>
                <div style="height:5px;"></div>
                <button class="prop-btn" onclick="duplicateSelected()">Duplicate</button>
                <div style="height:5px;"></div>
                <button class="prop-btn danger" onclick="deleteSelected()">Delete Layer</button>
            </div>
            <!-- Multi-select / Folder selection panel (v1.8) -->
            <div class="prop-section" id="propMultiActions" style="display:none;">
                <h4 id="propMultiName">Multiple Layers</h4>
                <p class="prop-multi-info"><span class="prop-multi-count" id="propMultiCount">0 selected</span></p>
                <div class="prop-row" style="margin-top:6px;">
                    <span class="prop-label">Geometric</span>
                    <span id="propMultiDistGeo" style="font-size:11px;color:var(--text);font-family:monospace;">—</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Estimated</span>
                    <span id="propMultiDistEst" style="font-size:11px;color:var(--accent);font-family:monospace;">—</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Slack</span>
                    <span id="propMultiSlackPct" style="font-size:11px;color:var(--text-muted);">—</span>
                </div>
                <div style="height:8px;"></div>
                <button class="prop-btn" onclick="zoomToMultiSelected()">Zoom to Selection</button>
                <div style="height:5px;"></div>
                <button class="prop-btn" onclick="calcMultiDistance()">📐 Calculate Distance</button>
                <div style="height:5px;"></div>
                <button class="prop-btn" onclick="joinSelectedSegments()" style="background:#e67e22;color:white;">&#x1F517; Join into Single Line</button>
                <div style="height:5px;"></div>
                <button class="prop-btn danger" onclick="deleteMultiSelected()">Delete Selected</button>
            </div>
        </div>
    </div>
</div>

<!-- CONTEXT MENU -->
<div class="ctx-menu" id="ctxMenu">
    <div class="ctx-item" data-for="both" onclick="ctxRename()">✏️ Rename</div>
    <div class="ctx-item" data-for="both" onclick="ctxZoomTo()">🔎 Zoom to</div>
    <div class="ctx-sep" data-for="both"></div>
    <div class="ctx-item" data-for="both" onclick="ctxChangeColor()">🎨 Change Color</div>
    <div class="ctx-item" data-for="both" onclick="ctxChangeWidth()">📏 Change Width</div>
    <div class="ctx-sep" data-for="layer"></div>
    <div class="ctx-item" data-for="layer" onclick="ctxDuplicate()">📋 Duplicate</div>
    <div class="ctx-item" data-for="layer" onclick="ctxMoveToFolder()">📁 Move to folder…</div>
    <div class="ctx-sep" data-for="both"></div>
    <div class="ctx-item" data-for="both" onclick="ctxCalcDistance()">📐 Calculate Distance</div>
    <div class="ctx-item" data-for="both" onclick="ctxJoinSegments()">&#x1F517; Join into Single Line</div>
    <div class="ctx-item" data-for="layer" onclick="ctxMeasureAB()">🟢🔴 Measure A-End → B-End</div>
    <div class="ctx-sep" data-for="both"></div>
    <div class="ctx-submenu" data-for="both" id="ctxExportSubmenu">
        <button class="ctx-submenu-toggle" onclick="document.getElementById('ctxExportSubmenu').classList.toggle('open')">
            💾 Export As… <span class="ctx-arrow">▶</span>
        </button>
        <div class="ctx-submenu-items">
            <button class="ctx-sub-item" onclick="ctxExportAs('kml')">KML</button>
            <button class="ctx-sub-item" onclick="ctxExportAs('kmz')">KMZ (compressed)</button>
            <button class="ctx-sub-item" onclick="ctxExportAs('geojson')">GeoJSON</button>
            <button class="ctx-sub-item" onclick="ctxExportAs('simplified')">Simplified GeoJSON</button>
        </div>
    </div>
    <div class="ctx-sep" data-for="both"></div>
    <div class="ctx-item danger" data-for="both" onclick="ctxDelete()">🗑️ Delete</div>
</div>

<div id="toastContainer"></div>

<!-- Menu dropdowns (body-level for z-index above Leaflet) -->
<div class="menu-dropdown" id="fileMenu">
    <button class="menu-dropdown-item" onclick="openFile(); closeMenus();">
        📂 Open… <span class="shortcut">Ctrl+O</span>
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="openMergeFiles(); closeMenus();">
        📑 Merge files…
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="fileSave(); closeMenus();">
        💾 Save <span class="shortcut">Ctrl+S</span>
    </button>
    <button class="menu-dropdown-item" onclick="fileSaveAs(); closeMenus();">
        💾 Save As… <span class="shortcut">Ctrl+Shift+S</span>
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="fileSaveAsGeoJSON(); closeMenus();">
        📤 Save as GeoJSON
    </button>
    <button class="menu-dropdown-item" onclick="exportSimplifiedGeoJSON(); closeMenus();">
        📤 Export Simplified GeoJSON
    </button>
    <button class="menu-dropdown-item" onclick="showExportImageDialog(); closeMenus();">
        🖼️ Export Image…
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="printMap(); closeMenus();">
        🖨️ Print Map…
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="clearProject(); closeMenus();">
        🗑️ Clear All
    </button>
</div>
<div class="menu-dropdown" id="editMenu">
    <button class="menu-dropdown-item" onclick="undo(); closeMenus();">
        ↩️ Undo <span class="shortcut">Ctrl+Z</span>
    </button>
    <button class="menu-dropdown-item" onclick="redo(); closeMenus();">
        ↪️ Redo <span class="shortcut">Ctrl+Shift+Z</span>
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="createNewFolder(); closeMenus();">
        📁 New Folder
    </button>
    <button class="menu-dropdown-item" onclick="toggleDrawMode(); closeMenus();">
        ✏️ Draw New Line
    </button>
    <button class="menu-dropdown-item" onclick="togglePinMode(); closeMenus();">
        📍 Place Pin Marker
    </button>
    <button class="menu-dropdown-item" onclick="toggleRulerMode(); closeMenus();">
        📏 Ruler Tool
    </button>
    <button class="menu-dropdown-item" onclick="toggleEraserMode(); closeMenus();">
        🧹 Eraser Tool
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="toggleEditMode(); closeMenus();">
        🔧 Edit Vertices
    </button>
    <button class="menu-dropdown-item" onclick="toggleAddPointMode(); closeMenus();">
        ➕ Add Point to Line
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="showColorPaletteForSelected(); closeMenus();">
        🎨 Change Color…
    </button>
    <button class="menu-dropdown-item" onclick="promptLineWidth(); closeMenus();">
        📏 Change Width…
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="selectAllItems(); closeMenus();">
        ☑️ Select All Layers
    </button>
    <button class="menu-dropdown-item" onclick="deselectAll(); closeMenus();">
        ⬜ Deselect All
    </button>
</div>
<div class="menu-dropdown" id="viewMenu">
    <button class="menu-dropdown-item" onclick="zoomToAll(); closeMenus();">
        🔍 Zoom to All Layers
    </button>
    <button class="menu-dropdown-item" onclick="zoomToSelected(); closeMenus();">
        🔎 Zoom to Selected
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="toggleMapLayerSelector(); closeMenus();">
        🗺️ Toggle Map Type Selector
    </button>
    <button class="menu-dropdown-item" onclick="loadLogoImage(); closeMenus();">
        🖼️ Add Logo Overlay…
    </button>
    <button class="menu-dropdown-item" onclick="toggleLogoSettings(); closeMenus();">
        ⚙️ Logo Settings…
    </button>
</div>
<div class="menu-dropdown" id="toolsMenu">
    <button class="menu-dropdown-item" onclick="batchSimplifyAll(); closeMenus();">
        📐 Simplify All Lines
    </button>
    <button class="menu-dropdown-item" onclick="showProjectStats(); closeMenus();">
        📊 Project Statistics
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="openSlackSettings(); closeMenus();">
        ⚙️ Settings…
    </button>
</div>

<input type="file" id="fileInput" accept=".kml,.kmz,.geojson,.json" onchange="handleFileOpen(event)">
<input type="file" id="mergeFileInput" accept=".kml,.kmz,.geojson,.json" multiple onchange="handleMergeFiles(event)">
<input type="file" id="logoInput" accept="image/*" onchange="handleLogoUpload(event)">

<!-- Color palette popup -->
<div class="color-palette" id="colorPalette">
    <h5>Colors</h5>
    <div class="color-swatches" id="colorSwatches"></div>
    <div class="color-palette-custom">
        <input type="color" id="customColorPicker" value="#3b82f6">
        <span>Custom</span>
    </div>
</div>

<!-- Pin type selector window -->
<div id="pinTypeWindow">
    <div class="pin-type-header" id="pinTypeDragHandle">
        <h5 style="margin:0;">📌 Pin Types</h5>
        <button class="pin-type-close" onclick="togglePinTypeWindow()">✕</button>
    </div>
    <div class="pin-type-grid" id="pinTypeGrid"></div>
</div>

<!-- Settings overlay -->
<div class="settings-overlay" id="settingsOverlay">
    <div class="settings-dialog">
        <h4>⚙️ Settings</h4>
        <div class="settings-row">
            <label>Fiber Slack %</label>
            <input type="number" id="settingsSlackPct" min="0" max="200" step="0.5" value="10">
        </div>
        <p style="font-size:10px;color:var(--text-muted);margin-bottom:8px;">Estimated distance = Geometric distance × (1 + slack%/100). Typical fiber slack: 5-15%.</p>
        <div style="border-top:1px solid var(--border);margin:10px 0;padding-top:10px;">
            <div class="settings-row">
                <label>Vertex dots min zoom</label>
                <input type="number" id="settingsVertexZoom" min="8" max="20" step="1" value="13">
            </div>
            <p style="font-size:10px;color:var(--text-muted);margin-bottom:4px;">Vertices only shown when zoomed in ≥ this level (8–20). Higher = fewer dots, better performance.</p>
            <div class="settings-row">
                <label>Max vertex dots</label>
                <input type="number" id="settingsVertexMax" min="200" max="10000" step="100" value="2000">
            </div>
            <p style="font-size:10px;color:var(--text-muted);margin-bottom:8px;">Maximum dots rendered at once. Lower for slower devices.</p>
        </div>
        <div style="border-top:1px solid var(--border);margin:10px 0;padding-top:10px;">
            <div class="settings-toggle">
                <span style="font-size:12px;color:var(--text-secondary);flex:1;">Search viewport bias</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="settingsViewportBias">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <p style="font-size:10px;color:var(--text-muted);margin-bottom:8px;">When enabled, address search prioritises results near the current map view. Useful when you're already zoomed into the area of interest.</p>
        </div>
        <div class="settings-actions">
            <button class="prop-btn" onclick="closeSlackSettings()">Cancel</button>
            <button class="prop-btn primary" onclick="saveSlackSettings()">Save</button>
        </div>
    </div>
</div>

<script>
// Load Leaflet dynamically with multi-CDN fallback
function loadScript(url) {
    return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url; s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
    });
}
function loadCSS(url) {
    return new Promise((resolve) => {
        const l = document.createElement('link');
        l.rel = 'stylesheet'; l.href = url;
        l.onload = resolve; l.onerror = resolve;
        document.head.appendChild(l);
    });
}

async function loadLeaflet() {
    const cssCDNs = [
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
        'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css',
        'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css'
    ];
    const jsCDNs = [
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
        'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js',
        'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js'
    ];
    for (const url of cssCDNs) { try { await loadCSS(url); break; } catch(e) {} }
    for (const url of jsCDNs) {
        try { await loadScript(url); if (typeof L !== 'undefined') return true; }
        catch(e) { console.warn('CDN failed:', url); }
    }
    return false;
}

async function loadJSZip() {
    const cdns = [
        'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js',
        'https://unpkg.com/jszip@3.10.1/dist/jszip.min.js',
        'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'
    ];
    for (const url of cdns) {
        try { await loadScript(url); if (typeof JSZip !== 'undefined') return true; }
        catch(e) { console.warn('JSZip CDN failed:', url); }
    }
    return false;
}

(async function() {
    const ok = await loadLeaflet();
    if (!ok) {
        document.getElementById('emptyState').innerHTML = '<p style="color:#ef4444;font-size:14px;padding:30px;">Failed to load Leaflet map library.<br>Check internet connection and reload.</p>';
        return;
    }
    // Load JSZip for KMZ support (non-blocking — KMZ features just warn if not loaded)
    await loadJSZip();
    initApp();
})();

function initApp() {

// === DATA MODEL ===
let projectData = { folders: [], layers: {} };
let nextId = 1;
const genId = () => 'L' + (nextId++);
const genFolderId = () => 'F' + (nextId++);
let selectedLayerId = null;
let selectedLayerIds = new Set(); // Multi-select set
let selectedFolderId = null; // Folder selection
let editMode = false;
let addPointMode = false;
let ctxTargetId = null;

// === UNDO / REDO SYSTEM ===
const undoStack = [];
const redoStack = [];
const MAX_UNDO = 80;

function takeSnapshot() {
    // Deep-clone projectData (without Leaflet objects)
    const snap = { folders: JSON.parse(JSON.stringify(projectData.folders)), layers: {} };
    for (const [id, l] of Object.entries(projectData.layers)) {
        snap.layers[id] = {
            id: l.id, name: l.name, type: l.type,
            coords: JSON.parse(JSON.stringify(l.coords)),
            originalCoords: JSON.parse(JSON.stringify(l.originalCoords)),
            color: l.color, width: l.width, opacity: l.opacity,
            visible: l.visible, checked: l.checked, folderId: l.folderId,
            pinType: l.pinType, description: l.description, showLabel: l.showLabel
        };
    }
    snap.nextId = nextId;
    return snap;
}

function restoreSnapshot(snap) {
    // Remove existing Leaflet layers
    Object.values(projectData.layers).forEach(l => {
        if (l.leafletLayer) map.removeLayer(l.leafletLayer);
        l.vertexMarkers.forEach(m => map.removeLayer(m));
    });
    // Restore data
    projectData.folders = JSON.parse(JSON.stringify(snap.folders));
    projectData.layers = {};
    for (const [id, l] of Object.entries(snap.layers)) {
        projectData.layers[id] = {
            ...JSON.parse(JSON.stringify(l)),
            leafletLayer: null, vertexMarkers: []
        };
    }
    nextId = snap.nextId;
    // Clear selection if the layer no longer exists
    if (selectedLayerId && !projectData.layers[selectedLayerId]) selectedLayerId = null;
    selectedLayerIds = new Set([...selectedLayerIds].filter(id => projectData.layers[id]));
    if (selectedFolderId && !projectData.folders.find(f => f.id === selectedFolderId)) selectedFolderId = null;
    renderAll(); updatePropsPanel(); updateStatus();
}

function pushUndo() {
    undoStack.push(takeSnapshot());
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack.length = 0; // clear redo on new action
}

window.undo = function() {
    if (undoStack.length === 0) { toast('Nothing to undo', 'info'); return; }
    redoStack.push(takeSnapshot());
    restoreSnapshot(undoStack.pop());
    toast('Undo', 'info');
};

window.redo = function() {
    if (redoStack.length === 0) { toast('Nothing to redo', 'info'); return; }
    undoStack.push(takeSnapshot());
    restoreSnapshot(redoStack.pop());
    toast('Redo', 'info');
};

// === MAP ===
const map = L.map('map', { center: [20, 0], zoom: 3, zoomControl: true, attributionControl: true });

const tileLayers = {
    'osm': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '© OpenStreetMap'
    }),
    'osm-hot': L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '© OpenStreetMap HOT'
    }),
    'carto-voyager': L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}{r}.png', {
        maxZoom: 19, subdomains: 'abcd', attribution: '© CARTO Voyager'
    }),
    'carto-light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19, subdomains: 'abcd', attribution: '© CARTO'
    }),
    'carto-dark': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19, subdomains: 'abcd', attribution: '© CARTO'
    }),
    'satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 18, attribution: '© Esri'
    }),
    'sat-labels': L.layerGroup([
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 18, attribution: '© Esri'
        }),
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
            maxZoom: 19, subdomains: 'abcd', pane: 'overlayPane'
        })
    ]),
    'topo': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17, attribution: '© OpenTopoMap'
    })
};

let currentTileLayer = tileLayers['osm'];
currentTileLayer.addTo(map);

window.switchMapLayer = function(key) {
    map.removeLayer(currentTileLayer);
    currentTileLayer = tileLayers[key];
    currentTileLayer.addTo(map);
    document.querySelectorAll('.map-layer-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.layer === key);
    });
};

// === FILE I/O ===
window.openFile = () => document.getElementById('fileInput').click();
window.openKMLFile = () => document.getElementById('fileInput').click(); // legacy alias
window.openMergeFiles = () => document.getElementById('mergeFileInput').click();
window.openGeoJSONFile = () => document.getElementById('fileInput').click(); // legacy alias

// Detect file type and import accordingly
async function importFileByType(file) {
    const fname = file.name.toLowerCase();
    if (fname.endsWith('.kmz')) {
        const kmlStr = await extractKMLFromKMZ(file);
        importKML(kmlStr, file.name);
    } else if (fname.endsWith('.geojson') || fname.endsWith('.json')) {
        const text = await readFileAsText(file);
        importGeoJSON(text, file.name);
    } else {
        // Default: treat as KML
        const text = await readFileAsText(file);
        importKML(text, file.name);
    }
}

window.handleFileOpen = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    currentFileName = file.name;
    currentFileHandle = null;
    currentFileIsKMZ = file.name.toLowerCase().endsWith('.kmz');

    try {
        await importFileByType(file);
        toast('Opened ' + file.name, 'success');
    } catch (err) {
        toast('Error opening file: ' + err.message, 'error');
    }
    e.target.value = '';
};

window.handleMergeFiles = async function(e) {
    const files = Array.from(e.target.files);
    if (!files.length) return;
    let loaded = 0;
    for (const file of files) {
        try {
            await importFileByType(file);
        } catch (err) { toast('Error in ' + file.name + ': ' + err.message, 'error'); }
        loaded++;
    }
    if (loaded > 0) { renderAll(); toast(loaded + ' file(s) merged', 'success'); updateStatus(); }
    e.target.value = '';
};

// Helper: read file as text (Promise)
function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (ev) => resolve(ev.target.result);
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
    });
}

window.handleGeoJSONOpen = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try { importGeoJSON(ev.target.result, file.name); toast('Opened ' + file.name, 'success'); }
        catch (err) { toast('Error: ' + err.message, 'error'); }
    };
    reader.readAsText(file);
    e.target.value = '';
};

// Drag-and-drop (supports KML, KMZ, GeoJSON, JSON)
const mapContainer = document.getElementById('mapContainer');
mapContainer.addEventListener('dragover', (e) => { e.preventDefault(); });
mapContainer.addEventListener('drop', async (e) => {
    e.preventDefault();
    for (const file of Array.from(e.dataTransfer.files)) {
        try {
            await importFileByType(file);
            toast('Loaded ' + file.name, 'success');
        } catch (err) { toast('Error: ' + err.message, 'error'); }
    }
});

// === KML PARSER (robust) ===
function importKML(kmlStr, fileName) {
    pushUndo();
    // Strip any non-XML content before the actual KML (e.g. email headers)
    const kmlStart = kmlStr.indexOf('<?xml');
    if (kmlStart > 0) kmlStr = kmlStr.substring(kmlStart);
    if (kmlStart < 0) {
        const kmlTag = kmlStr.indexOf('<kml');
        if (kmlTag >= 0) kmlStr = kmlStr.substring(kmlTag);
    }

    // Strip namespace prefixes that cause querySelector issues
    kmlStr = kmlStr.replace(/<kml:(\w)/g, '<$1').replace(/<\/kml:(\w)/g, '</$1');
    kmlStr = kmlStr.replace(/<gx:(\w)/g, '<gx_$1').replace(/<\/gx:(\w)/g, '</gx_$1');

    const doc = new DOMParser().parseFromString(kmlStr, 'text/xml');

    // Check for parse errors
    const parseErr = doc.querySelector('parsererror');
    if (parseErr) { toast('KML parse error — file may be malformed', 'error'); }

    // Parse shared styles
    const sharedStyles = {};
    doc.querySelectorAll('Style[id]').forEach(s => {
        sharedStyles['#' + s.getAttribute('id')] = parseStyleEl(s);
    });
    // StyleMap support — pick normal style
    doc.querySelectorAll('StyleMap[id]').forEach(sm => {
        const normal = sm.querySelector('Pair key');
        if (normal) {
            const pairs = sm.querySelectorAll('Pair');
            for (const pair of pairs) {
                const key = pair.querySelector('key');
                if (key && key.textContent.trim() === 'normal') {
                    const styleUrl = pair.querySelector('styleUrl');
                    if (styleUrl) {
                        const ref = styleUrl.textContent.trim();
                        if (sharedStyles[ref]) sharedStyles['#' + sm.getAttribute('id')] = sharedStyles[ref];
                    }
                    const inlineStyle = pair.querySelector('Style');
                    if (inlineStyle) sharedStyles['#' + sm.getAttribute('id')] = parseStyleEl(inlineStyle);
                }
            }
        }
    });

    const folderId = genFolderId();
    const folder = { id: folderId, name: fileName.replace(/\.kml$/i, ''), expanded: true, items: [] };

    function processFolder(parentEl, parentFolderId) {
        // Handle both <Folder> and <Document> as container elements
        const childContainers = parentEl.querySelectorAll(':scope > Folder, :scope > Document');
        childContainers.forEach(kf => {
            const sfId = genFolderId();
            const sfName = getKmlText(kf, 'name') || (kf.tagName === 'Document' ? 'Document' : 'Folder');
            const sf = { id: sfId, name: sfName, expanded: true, items: [], parentId: parentFolderId };

            // Collect styles scoped to this container
            const localStyles = {};
            kf.querySelectorAll(':scope > Style[id]').forEach(s => {
                localStyles['#' + s.getAttribute('id')] = parseStyleEl(s);
            });
            kf.querySelectorAll(':scope > StyleMap[id]').forEach(sm => {
                const pairs = sm.querySelectorAll('Pair');
                for (const pair of pairs) {
                    const key = pair.querySelector('key');
                    if (key && key.textContent.trim() === 'normal') {
                        const styleUrl = pair.querySelector('styleUrl');
                        if (styleUrl) {
                            const ref = styleUrl.textContent.trim();
                            const resolved = localStyles[ref] || sharedStyles[ref];
                            if (resolved) localStyles['#' + sm.getAttribute('id')] = resolved;
                        }
                        const inl = pair.querySelector('Style');
                        if (inl) localStyles['#' + sm.getAttribute('id')] = parseStyleEl(inl);
                    }
                }
            });
            // Merge local styles into shared for resolution within this scope
            const mergedStyles = { ...sharedStyles, ...localStyles };

            kf.querySelectorAll(':scope > Placemark').forEach(pm => {
                const layers = parsePlacemark(pm, sfId, mergedStyles);
                layers.forEach(layer => { sf.items.push(layer.id); projectData.layers[layer.id] = layer; });
            });

            processFolder(kf, sfId);

            if (sf.items.length > 0 || projectData.folders.some(f => f.parentId === sfId)) {
                projectData.folders.push(sf);
                const parent = projectData.folders.find(f => f.id === parentFolderId) || folder;
                parent.items.push(sfId);
            }
        });
    }

    // Root placemarks
    const rootSel = ['Document > Placemark', 'kml > Placemark', 'kml > Document > Placemark'];
    const rootPms = new Set();
    rootSel.forEach(sel => { try { doc.querySelectorAll(sel).forEach(pm => rootPms.add(pm)); } catch(e) {} });
    rootPms.forEach(pm => {
        const layers = parsePlacemark(pm, folderId, sharedStyles);
        layers.forEach(l => { folder.items.push(l.id); projectData.layers[l.id] = l; });
    });

    // Nested folders
    const docEl = doc.querySelector('Document') || doc.querySelector('kml');
    if (docEl) processFolder(docEl, folderId);

    // Fallback: grab all placemarks if nothing was found
    if (folder.items.filter(id => projectData.layers[id]).length === 0 &&
        !projectData.folders.some(f => f.parentId === folderId)) {
        doc.querySelectorAll('Placemark').forEach(pm => {
            const layers = parsePlacemark(pm, folderId, sharedStyles);
            layers.forEach(l => { folder.items.push(l.id); projectData.layers[l.id] = l; });
        });
    }

    projectData.folders.push(folder);
    renderAll();
    zoomToAllInternal();
    document.getElementById('emptyState').classList.add('hidden');
    updateStatus();
}

function parsePlacemark(pm, folderId, sharedStyles) {
    const name = getKmlText(pm, 'name') || 'Unnamed';
    const results = [];

    // Resolve style
    let style = { color: '#3b82f6', width: 3, opacity: 0.9 };
    const styleUrlEl = pm.querySelector(':scope > styleUrl');
    if (styleUrlEl) {
        const ref = styleUrlEl.textContent.trim();
        if (sharedStyles[ref]) style = { ...style, ...sharedStyles[ref] };
    }
    const inlineStyle = pm.querySelector(':scope > Style');
    if (inlineStyle) style = { ...style, ...parseStyleEl(inlineStyle) };

    // Collect all geometries from this placemark
    const geometries = [];

    // Direct geometries
    pm.querySelectorAll(':scope > LineString, :scope > Point, :scope > Polygon, :scope > LinearRing').forEach(g => {
        geometries.push(g);
    });

    // MultiGeometry
    pm.querySelectorAll('MultiGeometry LineString, MultiGeometry Point, MultiGeometry Polygon, MultiGeometry LinearRing').forEach(g => {
        geometries.push(g);
    });

    // gx:Track support
    pm.querySelectorAll('gx_Track').forEach(track => {
        const coords = [];
        track.querySelectorAll('gx_coord').forEach(c => {
            const parts = c.textContent.trim().split(/\s+/);
            if (parts.length >= 2) coords.push([parseFloat(parts[1]), parseFloat(parts[0])]);
        });
        if (coords.length > 0) {
            const id = genId();
            results.push({ id, name, type: 'line', coords, originalCoords: JSON.parse(JSON.stringify(coords)),
                color: style.color, width: style.width, opacity: style.opacity,
                visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
        }
    });

    // If no direct geometry elements found, try just finding coordinates anywhere
    if (geometries.length === 0 && results.length === 0) {
        const anyCoords = pm.querySelector('coordinates');
        if (anyCoords) {
            const coords = parseCoordStr(anyCoords.textContent);
            if (coords.length > 0) {
                const id = genId();
                const type = coords.length === 1 ? 'point' : 'line';
                results.push({ id, name, type, coords, originalCoords: JSON.parse(JSON.stringify(coords)),
                    color: style.color, width: style.width, opacity: style.opacity,
                    visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
            }
        }
        return results;
    }

    let gIdx = 0;
    geometries.forEach(g => {
        const tag = g.tagName.toLowerCase();
        const coordsEl = g.querySelector('coordinates');
        if (!coordsEl && tag !== 'polygon') return;

        if (tag === 'linestring' || tag === 'linearring') {
            const coords = parseCoordStr(coordsEl.textContent);
            if (coords.length > 0) {
                const id = genId();
                const suffix = geometries.length > 1 ? ' #' + (++gIdx) : '';
                results.push({ id, name: name + suffix, type: 'line', coords,
                    originalCoords: JSON.parse(JSON.stringify(coords)),
                    color: style.color, width: style.width, opacity: style.opacity,
                    visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
            }
        } else if (tag === 'point') {
            const coords = parseCoordStr(coordsEl.textContent);
            if (coords.length > 0) {
                const id = genId();
                results.push({ id, name, type: 'point', coords: [coords[0]],
                    originalCoords: JSON.parse(JSON.stringify([coords[0]])),
                    color: style.color, width: style.width, opacity: style.opacity,
                    visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
            }
        } else if (tag === 'polygon') {
            // Extract outer boundary as a line
            const outerCoords = g.querySelector('outerBoundaryIs coordinates') ||
                                g.querySelector('outerBoundaryIs LinearRing coordinates');
            if (outerCoords) {
                const coords = parseCoordStr(outerCoords.textContent);
                if (coords.length > 0) {
                    const id = genId();
                    const suffix = geometries.length > 1 ? ' #' + (++gIdx) : '';
                    results.push({ id, name: name + suffix + ' (polygon)', type: 'line', coords,
                        originalCoords: JSON.parse(JSON.stringify(coords)),
                        color: style.color, width: style.width, opacity: style.opacity,
                        visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
                }
            }
        }
    });

    return results;
}

function parseCoordStr(str) {
    if (!str) return [];
    // Handle various formats: "lng,lat,alt" or "lng,lat" separated by whitespace or newlines
    return str.trim().split(/[\s\n\r]+/).map(s => {
        if (!s || s.length < 3) return null;
        const p = s.split(',');
        if (p.length >= 2) {
            const lng = parseFloat(p[0]);
            const lat = parseFloat(p[1]);
            if (!isNaN(lat) && !isNaN(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                return [lat, lng]; // [lat, lng] for Leaflet
            }
        }
        return null;
    }).filter(c => c !== null);
}

function parseStyleEl(styleEl) {
    const result = {};
    const ls = styleEl.querySelector('LineStyle');
    if (ls) {
        const kc = getKmlText(ls, 'color');
        if (kc && kc.length === 8) {
            result.opacity = Math.round(parseInt(kc.substr(0, 2), 16) / 255 * 100) / 100;
            result.color = '#' + kc.substr(6, 2) + kc.substr(4, 2) + kc.substr(2, 2);
        } else if (kc && kc.length === 6) {
            result.color = '#' + kc.substr(4, 2) + kc.substr(2, 2) + kc.substr(0, 2);
        }
        const w = getKmlText(ls, 'width');
        if (w) result.width = parseFloat(w);
    }
    // Also try PolyStyle for polygons
    const ps = styleEl.querySelector('PolyStyle');
    if (ps && !ls) {
        const kc = getKmlText(ps, 'color');
        if (kc && kc.length === 8) {
            result.opacity = Math.round(parseInt(kc.substr(0, 2), 16) / 255 * 100) / 100;
            result.color = '#' + kc.substr(6, 2) + kc.substr(4, 2) + kc.substr(2, 2);
        }
    }
    return result;
}

function parseStyle(pm) {
    return parseStyleEl(pm.querySelector('Style') || pm);
}

function getKmlText(parent, tag) {
    // Try direct child first, then any descendant
    let el = parent.querySelector(':scope > ' + tag);
    if (!el) {
        // Some KML files use different casing
        const children = parent.children;
        for (let i = 0; i < children.length; i++) {
            if (children[i].tagName.toLowerCase() === tag.toLowerCase()) { el = children[i]; break; }
        }
    }
    return el ? el.textContent.trim() : null;
}

// === GEOJSON PARSER ===
function importGeoJSON(jsonStr, fileName) {
    pushUndo();
    const data = JSON.parse(jsonStr);
    const folderId = genFolderId();
    const folder = { id: folderId, name: fileName.replace(/\.(geojson|json)$/i, ''), expanded: true, items: [] };

    const features = data.type === 'FeatureCollection' ? data.features :
                     data.type === 'Feature' ? [data] : [];

    features.forEach(f => {
        if (!f.geometry) return;
        const geom = f.geometry;
        const props = f.properties || {};
        const name = props.name || props.Name || props.title || 'Unnamed';
        const color = props.stroke || props.color || '#3b82f6';
        const width = props['stroke-width'] || 3;
        const opacity = props['stroke-opacity'] || 0.9;

        if (geom.type === 'LineString') {
            const coords = geom.coordinates.map(c => [c[1], c[0]]);
            if (coords.length > 0) {
                const id = genId();
                folder.items.push(id);
                projectData.layers[id] = {
                    id, name, type: 'line', coords,
                    originalCoords: JSON.parse(JSON.stringify(coords)),
                    color, width, opacity, visible: true,
                    folderId, leafletLayer: null, vertexMarkers: []
                };
            }
        } else if (geom.type === 'MultiLineString') {
            geom.coordinates.forEach((line, i) => {
                const coords = line.map(c => [c[1], c[0]]);
                if (coords.length > 0) {
                    const id = genId();
                    folder.items.push(id);
                    projectData.layers[id] = {
                        id, name: name + (geom.coordinates.length > 1 ? ' #' + (i + 1) : ''),
                        type: 'line', coords,
                        originalCoords: JSON.parse(JSON.stringify(coords)),
                        color, width, opacity, visible: true,
                        folderId, leafletLayer: null, vertexMarkers: []
                    };
                }
            });
        } else if (geom.type === 'Point') {
            const coords = [[geom.coordinates[1], geom.coordinates[0]]];
            const id = genId();
            folder.items.push(id);
            projectData.layers[id] = {
                id, name, type: 'point', coords,
                originalCoords: JSON.parse(JSON.stringify(coords)),
                color, width: 3, opacity, visible: true,
                folderId, leafletLayer: null, vertexMarkers: []
            };
        }
    });

    projectData.folders.push(folder);
    renderAll();
    zoomToAllInternal();
    document.getElementById('emptyState').classList.add('hidden');
    updateStatus();
}

// === RENDERING ===
function renderAll() { renderFolderTree(); renderMapLayers(); }

function renderMapLayers() {
    const showLines = document.getElementById('filterLines').checked;
    const showPins = document.getElementById('filterPins').checked;

    Object.values(projectData.layers).forEach(layer => {
        if (layer.leafletLayer) map.removeLayer(layer.leafletLayer);
        layer.leafletLayer = null;
        layer.vertexMarkers.forEach(m => map.removeLayer(m));
        layer.vertexMarkers = [];
    });

    Object.values(projectData.layers).forEach(layer => {
        if (!layer.visible) return;
        if (layer.type === 'line' && !showLines) return;
        if (layer.type === 'point' && !showPins) return;

        if (layer.type === 'line' && layer.coords.length > 1) {
            layer.leafletLayer = L.polyline(layer.coords, {
                color: layer.color, weight: layer.width, opacity: layer.opacity, interactive: true
            }).addTo(map);
            layer.leafletLayer.on('click', (e) => {
                if (measureMode) {
                    handleMeasureClick(e.latlng);
                    return;
                }
                L.DomEvent.stopPropagation(e);
                if (e.originalEvent.ctrlKey || e.originalEvent.metaKey) {
                    toggleMultiSelect(layer.id);
                } else if (e.originalEvent.shiftKey && selectedLayerId) {
                    rangeSelect(selectedLayerId, layer.id);
                } else {
                    selectedFolderId = null;
                    selectLayer(layer.id);
                }
            });
        } else if (layer.type === 'point' && layer.coords.length > 0) {
            const pinSvg = getPinSvg(layer.pinType || 'default', layer.color);
            const showLabel = layer.showLabel !== false; // default true
            const labelHtml = showLabel ? '<div class="pin-label" style="color:' + (layer.color || '#e74c3c') + ';">' + (layer.name || '').replace(/</g, '&lt;') + '</div>' : '';
            const icon = L.divIcon({
                className: 'pin-marker draggable-pin',
                html: labelHtml + pinSvg,
                iconSize: [24, 36],
                iconAnchor: [12, 36]
            });
            layer.leafletLayer = L.marker(layer.coords[0], { icon, interactive: true, draggable: true }).addTo(map);
            layer.leafletLayer.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                if (e.originalEvent.ctrlKey || e.originalEvent.metaKey) {
                    toggleMultiSelect(layer.id);
                } else if (e.originalEvent.shiftKey && selectedLayerId) {
                    rangeSelect(selectedLayerId, layer.id);
                } else {
                    selectedFolderId = null;
                    selectLayer(layer.id);
                }
            });
            // Draggable pin: update coords on drag (no mousedown handler - it breaks map panning on simple clicks)
            layer.leafletLayer.on('dragstart', () => { map.dragging.disable(); });
            layer.leafletLayer.on('drag', (e) => {
                const ll = e.target.getLatLng();
                layer.coords[0] = [ll.lat, ll.lng];
                if (selectedLayerId === layer.id) updatePropsPanel();
            });
            layer.leafletLayer.on('dragend', (e) => {
                map.dragging.enable();
                const ll = e.target.getLatLng();
                layer.coords[0] = [ll.lat, ll.lng];
                layer.originalCoords = JSON.parse(JSON.stringify(layer.coords));
                if (selectedLayerId === layer.id) updatePropsPanel();
                toast('Pin moved to ' + ll.lat.toFixed(4) + ', ' + ll.lng.toFixed(4), 'info');
            });
        }

        if (editMode && layer.id === selectedLayerId && layer.type === 'line') {
            renderVertexMarkers(layer);
        }
    });

    // Render vertex dots overlay if enabled (v2.0)
    renderVertexDots();
}

// === VERTEX DOTS (v2.4 — viewport-culled, zoom-gated, capped) ===
let vertexDotMarkers = [];
let vertexMinZoom = 13;   // Only show dots at zoom >= this
let vertexMaxDots = 2000; // Max dots to render at once
let vertexDotsScheduled = false;

function renderVertexDots() {
    // Clear existing dots
    vertexDotMarkers.forEach(m => map.removeLayer(m));
    vertexDotMarkers = [];

    const showDots = document.getElementById('filterVertexDots').checked;
    if (!showDots && !measureMode) return;

    const zoom = map.getZoom();

    // In measure mode: always show for selected line (but still viewport-cull)
    // In normal mode: require minimum zoom level
    if (!measureMode && zoom < vertexMinZoom) {
        // Show a helpful toast on first attempt
        if (showDots) {
            toast('Zoom in to level ' + vertexMinZoom + '+ to see vertices (current: ' + Math.round(zoom) + ')', 'info');
        }
        return;
    }

    const bounds = map.getBounds();
    const layersToShow = measureMode
        ? Object.values(projectData.layers)
        : Object.values(projectData.layers);

    // Collect all visible vertices within viewport (with metadata)
    const candidates = [];
    layersToShow.forEach(layer => {
        if (!layer.visible || layer.type !== 'line' || layer.coords.length < 2) return;
        if (editMode && layer.id === selectedLayerId) return;

        layer.coords.forEach((coord, idx) => {
            // Viewport culling: skip if outside visible bounds
            if (coord[0] < bounds.getSouth() || coord[0] > bounds.getNorth() ||
                coord[1] < bounds.getWest() || coord[1] > bounds.getEast()) return;

            const isEnd = idx === 0 || idx === layer.coords.length - 1;
            candidates.push({ layer, coord, idx, isEnd });
        });
    });

    // Cap to prevent browser lag
    const dotsToRender = candidates.length <= vertexMaxDots
        ? candidates
        : candidates.slice(0, vertexMaxDots);

    if (candidates.length > vertexMaxDots && !measureMode) {
        toast('Showing ' + vertexMaxDots + ' of ' + candidates.length + ' vertices in view. Zoom in more or adjust in Settings.', 'info');
    }

    dotsToRender.forEach(({ layer, coord, idx, isEnd }) => {
        const canDrag = !measureMode && !editMode && selectedLayerIds.has(layer.id);
        const icon = L.divIcon({
            className: isEnd ? 'vertex-dot-end' : 'vertex-dot',
            iconSize: isEnd ? [10, 10] : [8, 8],
            iconAnchor: isEnd ? [5, 5] : [4, 4]
        });
        const marker = L.marker(coord, { icon, interactive: true, draggable: canDrag, zIndexOffset: 600 }).addTo(map);

        marker.on('click', (e) => {
            L.DomEvent.stopPropagation(e);
            if (measureMode) {
                handleMeasureClick(e.latlng, idx, layer.id);
            }
        });

        if (canDrag) {
            marker.on('dragstart', () => { pushUndo(); map.dragging.disable(); });
            marker.on('drag', (e) => {
                const ll = e.target.getLatLng();
                layer.coords[idx] = [ll.lat, ll.lng];
                if (layer.leafletLayer) layer.leafletLayer.setLatLngs(layer.coords);
            });
            marker.on('dragend', (e) => {
                map.dragging.enable();
                const ll = e.target.getLatLng();
                layer.coords[idx] = [ll.lat, ll.lng];
                updatePropsPanel(); updateStatus();
            });
        }

        vertexDotMarkers.push(marker);
    });
}

// Debounced re-render on pan/zoom (v2.4)
function scheduleVertexDotsUpdate() {
    const showDots = document.getElementById('filterVertexDots').checked;
    if (!showDots && !measureMode) return;
    if (vertexDotsScheduled) return;
    vertexDotsScheduled = true;
    requestAnimationFrame(() => {
        vertexDotsScheduled = false;
        renderVertexDots();
    });
    updateVertexZoomHint();
}

function updateVertexZoomHint() {
    const hint = document.getElementById('vertexZoomHint');
    if (!hint) return;
    const zoom = Math.round(map.getZoom());
    const showDots = document.getElementById('filterVertexDots').checked;
    if (showDots && zoom < vertexMinZoom) {
        hint.textContent = '(z' + zoom + '/' + vertexMinZoom + ')';
        hint.style.color = 'var(--danger)';
    } else if (showDots) {
        hint.textContent = '(z' + zoom + ')';
        hint.style.color = 'var(--success)';
    } else {
        hint.textContent = '';
    }
}

window.applyLayerFilters = function() { renderMapLayers(); updateVertexZoomHint(); };

// Match checkboxes to visibility: checked = visible, unchecked = hidden
window.matchCheckboxesToVisibility = function() {
    // Sync all layers: checked ↔ visible
    Object.values(projectData.layers).forEach(l => { l.checked = l.visible !== false; });
    // Sync all folders: checked ↔ visible
    projectData.folders.forEach(f => { f.checked = f.visible !== false; });
    renderFolderTree();
    toast('Checkboxes matched to visibility state', 'info');
};

function renderVertexMarkers(layer) {
    layer.vertexMarkers.forEach(m => map.removeLayer(m));
    layer.vertexMarkers = [];

    layer.coords.forEach((coord, idx) => {
        const isEnd = idx === 0 || idx === layer.coords.length - 1;
        const icon = L.divIcon({
            className: isEnd ? 'vertex-marker-endpoint' : 'vertex-marker',
            iconSize: isEnd ? [12, 12] : [10, 10],
            iconAnchor: isEnd ? [6, 6] : [5, 5]
        });

        const marker = L.marker(coord, { icon, draggable: true, zIndexOffset: 2000 }).addTo(map);

        // Prevent map drag when dragging marker
        marker.on('mousedown', () => { map.dragging.disable(); });
        marker.on('dragstart', () => {
            pushUndo();
            map.dragging.disable();
            if (marker.getElement()) marker.getElement().classList.add('dragging');
        });
        marker.on('drag', (e) => {
            const ll = e.target.getLatLng();
            layer.coords[idx] = [ll.lat, ll.lng];
            if (layer.leafletLayer) layer.leafletLayer.setLatLngs(layer.coords);
        });
        marker.on('dragend', (e) => {
            map.dragging.enable();
            const ll = e.target.getLatLng();
            layer.coords[idx] = [ll.lat, ll.lng];
            if (marker.getElement()) marker.getElement().classList.remove('dragging');
            updateStatus();
        });
        marker.on('contextmenu', (e) => {
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            if (layer.coords.length > 2) {
                pushUndo();
                layer.coords.splice(idx, 1);
                renderMapLayers();
                updatePropsPanel();
                toast('Removed vertex ' + (idx + 1), 'info');
            }
        });

        layer.vertexMarkers.push(marker);
    });
}

// === FOLDER TREE ===
function renderFolderTree() {
    const container = document.getElementById('folderTree');
    container.innerHTML = '';
    projectData.folders.filter(f => !f.parentId).forEach(f => {
        container.appendChild(createFolderEl(f));
    });
}

function createFolderEl(folder) {
    const div = document.createElement('div');
    div.className = 'tree-folder';
    div.dataset.folderId = folder.id;
    div.draggable = true;

    const header = document.createElement('div');
    header.className = 'tree-folder-header' + (selectedFolderId === folder.id ? ' folder-selected' : '');
    const count = countItems(folder);
    const isChecked = folder.checked !== false;
    const folderVis = folder.visible !== false;
    header.innerHTML = `
        <input type="checkbox" class="tree-folder-check" ${isChecked ? 'checked' : ''} data-folder-id="${folder.id}">
        <span class="tree-toggle ${folder.expanded ? '' : 'collapsed'}">▼</span>
        <span class="folder-icon">${folder.expanded ? '📂' : '📁'}</span>
        <span class="tree-folder-name">${esc(folder.name)}</span>
        <span class="tree-folder-count">${count}</span>
        <span class="tree-folder-vis ${folderVis ? '' : 'folder-hidden'}" data-folder-id="${folder.id}">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            ${folderVis
                ? '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'
                : '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>'
            }</svg>
        </span>
    `;

    const checkbox = header.querySelector('.tree-folder-check');
    checkbox.addEventListener('click', (e) => {
        e.stopPropagation();
        folder.checked = checkbox.checked;
        function cascadeCheck(fId, val) {
            const f = projectData.folders.find(ff => ff.id === fId);
            if (f) { f.checked = val; f.items.forEach(id => { const l = projectData.layers[id]; if (l) l.checked = val; }); }
            projectData.folders.filter(ff => ff.parentId === fId).forEach(sf => cascadeCheck(sf.id, val));
        }
        cascadeCheck(folder.id, checkbox.checked);
        renderFolderTree();
    });

    // Folder visibility eye click
    const folderEye = header.querySelector('.tree-folder-vis');
    if (folderEye) folderEye.addEventListener('click', (e) => {
        e.stopPropagation();
        const newVis = folder.visible === false ? true : false;
        function cascadeVis(fId, val) {
            const f = projectData.folders.find(ff => ff.id === fId);
            if (f) { f.visible = val; f.items.forEach(id => { const l = projectData.layers[id]; if (l) l.visible = val; }); }
            projectData.folders.filter(ff => ff.parentId === fId).forEach(sf => cascadeVis(sf.id, val));
        }
        cascadeVis(folder.id, newVis);
        renderAll(); updatePropsPanel();
    });

    header.addEventListener('click', (e) => {
        if (e.target.classList.contains('tree-folder-check')) return;
        if (e.target.closest('.tree-folder-vis')) return;
        if (e.target.closest('.tree-toggle') || e.target.closest('.folder-icon')) {
            // Click on toggle arrow or folder icon: expand/collapse
            folder.expanded = !folder.expanded; renderFolderTree();
        } else {
            // Click on folder name/area: select folder
            selectFolder(folder.id);
        }
    });

    header.addEventListener('dblclick', (e) => { e.stopPropagation(); zoomToFolder(folder); });

    header.addEventListener('contextmenu', (e) => {
        e.preventDefault(); ctxTargetId = null; ctxTargetFolderId = folder.id;
        showCtxMenu(e.clientX, e.clientY, true);
    });

    header.addEventListener('dragover', (e) => { e.preventDefault(); header.classList.add('drag-over'); });
    header.addEventListener('dragleave', () => { header.classList.remove('drag-over'); });
    header.addEventListener('drop', (e) => {
        e.preventDefault(); e.stopPropagation(); header.classList.remove('drag-over');
        const data = e.dataTransfer.getData('text/plain');
        if (data.startsWith('FOLDER:')) { moveFolderIntoFolder(data.replace('FOLDER:', ''), folder.id); }
        else if (data) { moveLayerToFolder(data, folder.id); }
    });

    div.addEventListener('dragstart', (e) => {
        if (e.target !== div) return;
        e.dataTransfer.setData('text/plain', 'FOLDER:' + folder.id);
        e.dataTransfer.effectAllowed = 'move'; e.stopPropagation();
    });

    div.appendChild(header);

    const children = document.createElement('div');
    children.className = 'tree-folder-children' + (folder.expanded ? '' : ' hidden');

    // Sub-folders
    projectData.folders.filter(f => f.parentId === folder.id).forEach(sf => {
        children.appendChild(createFolderEl(sf));
    });

    // Layer items
    folder.items.forEach(itemId => {
        if (projectData.folders.find(f => f.id === itemId)) return;
        const layer = projectData.layers[itemId];
        if (!layer) return;

        const item = document.createElement('div');
        item.className = 'tree-item'
            + (selectedLayerId === layer.id ? ' selected' : '')
            + (selectedLayerIds.has(layer.id) && selectedLayerId !== layer.id ? ' multi-selected' : '');
        item.draggable = true;

        const typeIcon = layer.type === 'line'
            ? '<svg class="tree-line-icon" viewBox="0 0 20 8" fill="none"><polyline points="1,6 6,2 14,5 19,1" stroke="' + layer.color + '" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>'
            : '<svg class="tree-pin-icon" viewBox="0 0 12 16"><path d="M6 0C2.7 0 0 2.7 0 6c0 4.5 6 10 6 10s6-5.5 6-10C12 2.7 9.3 0 6 0z" fill="' + layer.color + '"/><circle cx="6" cy="6" r="2.2" fill="white" opacity="0.9"/></svg>';
        const layerChecked = layer.checked !== false;
        item.innerHTML = `
            <input type="checkbox" class="tree-item-check" ${layerChecked ? 'checked' : ''} data-layer-id="${layer.id}">
            <span class="tree-item-color" style="background:${layer.color}"></span>
            ${typeIcon}
            <span class="tree-item-name">${esc(layer.name)}</span>
            <span class="tree-item-pts">${layer.coords.length}</span>
            <span class="tree-item-vis ${layer.visible ? '' : 'hidden-item'}" data-id="${layer.id}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                ${layer.visible
                    ? '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'
                    : '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>'
                }</svg>
            </span>
        `;

        item.addEventListener('click', (e) => {
            if (e.target.closest('.tree-item-check')) {
                e.stopPropagation();
                layer.checked = e.target.checked;
                // Update parent folder indeterminate state (visual only, no cascade)
                renderFolderTree();
                return;
            }
            if (e.target.closest('.tree-item-vis')) {
                layer.visible = !layer.visible; renderAll(); return;
            }
            if (e.ctrlKey || e.metaKey) {
                // Ctrl+Click: toggle this layer in multi-select
                toggleMultiSelect(layer.id);
            } else if (e.shiftKey && selectedLayerId) {
                // Shift+Click: range select from last selected to this
                rangeSelect(selectedLayerId, layer.id);
            } else {
                // Normal click: single select, clear multi
                selectedFolderId = null;
                selectLayer(layer.id);
            }
        });

        item.addEventListener('contextmenu', (e) => {
            e.preventDefault(); ctxTargetId = layer.id; ctxTargetFolderId = null;
            showCtxMenu(e.clientX, e.clientY, false);
        });

        item.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            // Zoom to this layer
            if (layer.leafletLayer) {
                if (layer.leafletLayer.getBounds) map.fitBounds(layer.leafletLayer.getBounds(), { padding: [50, 50] });
                else if (layer.leafletLayer.getLatLng) map.setView(layer.leafletLayer.getLatLng(), 14);
            }
        });

        item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', layer.id);
            e.dataTransfer.effectAllowed = 'move';
        });

        children.appendChild(item);
    });

    div.appendChild(children);
    return div;
}

function countItems(folder) {
    let c = folder.items.filter(id => projectData.layers[id]).length;
    projectData.folders.filter(f => f.parentId === folder.id).forEach(sf => c += countItems(sf));
    return c;
}

function moveLayerToFolder(layerId, targetId) {
    projectData.folders.forEach(f => { f.items = f.items.filter(id => id !== layerId); });
    const target = projectData.folders.find(f => f.id === targetId);
    if (target) {
        target.items.push(layerId);
        const layer = projectData.layers[layerId];
        if (layer) layer.folderId = targetId;
    }
    renderFolderTree();
    toast('Layer moved', 'info');
}

// === SELECTION ===
function selectLayer(id) {
    selectedLayerId = id;
    selectedLayerIds.clear();
    selectedLayerIds.add(id);
    // Expand parent folders so the item is visible
    const layer = projectData.layers[id];
    if (layer) {
        let fId = layer.folderId;
        while (fId) {
            const f = projectData.folders.find(ff => ff.id === fId);
            if (f) { f.expanded = true; fId = f.parentId; } else break;
        }
    }
    renderFolderTree();
    renderMapLayers();
    updatePropsPanel();
    // Scroll selected item into view
    setTimeout(() => {
        const sel = document.querySelector('.tree-item.selected');
        if (sel) sel.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }, 50);
}

// === MULTI-SELECT (v1.8) ===
function toggleMultiSelect(id) {
    selectedFolderId = null;
    if (selectedLayerIds.has(id)) {
        selectedLayerIds.delete(id);
        if (selectedLayerId === id) {
            // Pick another from set, or null
            selectedLayerId = selectedLayerIds.size > 0 ? [...selectedLayerIds][selectedLayerIds.size - 1] : null;
        }
    } else {
        selectedLayerIds.add(id);
        selectedLayerId = id; // Primary = last clicked
    }
    renderFolderTree();
    renderMapLayers();
    updatePropsPanel();
}

function rangeSelect(fromId, toId) {
    selectedFolderId = null;
    // Build flat ordered list of all visible layer IDs in tree order
    const flatIds = getFlatLayerIds();
    const fromIdx = flatIds.indexOf(fromId);
    const toIdx = flatIds.indexOf(toId);
    if (fromIdx === -1 || toIdx === -1) { selectLayer(toId); return; }
    const start = Math.min(fromIdx, toIdx);
    const end = Math.max(fromIdx, toIdx);
    selectedLayerIds.clear();
    for (let i = start; i <= end; i++) {
        selectedLayerIds.add(flatIds[i]);
    }
    selectedLayerId = toId;
    renderFolderTree();
    renderMapLayers();
    updatePropsPanel();
}

function getFlatLayerIds() {
    const ids = [];
    function walkFolder(folderId) {
        const folder = projectData.folders.find(f => f.id === folderId);
        if (!folder) return;
        // Sub-folders first (matching tree render order)
        projectData.folders.filter(f => f.parentId === folderId).forEach(sf => walkFolder(sf.id));
        // Then layer items
        folder.items.forEach(itemId => {
            if (!projectData.folders.find(f => f.id === itemId) && projectData.layers[itemId]) {
                ids.push(itemId);
            }
        });
    }
    projectData.folders.filter(f => !f.parentId).forEach(f => walkFolder(f.id));
    return ids;
}

// === FOLDER SELECTION (v1.8) ===
function selectFolder(folderId) {
    selectedFolderId = folderId;
    selectedLayerId = null;
    selectedLayerIds.clear();
    // Select all layers in this folder (and sub-folders)
    function collectLayers(fId) {
        const f = projectData.folders.find(ff => ff.id === fId);
        if (!f) return;
        f.items.forEach(id => {
            if (projectData.layers[id]) selectedLayerIds.add(id);
        });
        projectData.folders.filter(ff => ff.parentId === fId).forEach(sf => collectLayers(sf.id));
    }
    collectLayers(folderId);
    // Set primary to first layer in folder
    if (selectedLayerIds.size > 0) selectedLayerId = [...selectedLayerIds][0];
    // Expand folder
    const f = projectData.folders.find(ff => ff.id === folderId);
    if (f) f.expanded = true;
    renderFolderTree();
    renderMapLayers();
    updatePropsPanel();
}

function updatePropsPanel() {
    const layer = projectData.layers[selectedLayerId];
    const show = (id, v) => document.getElementById(id).style.display = v ? '' : 'none';
    const multiCount = selectedLayerIds.size;
    const isMulti = multiCount > 1 || selectedFolderId;

    if (!layer && !selectedFolderId) {
        show('propNone', true); show('propName', false); show('propStyle', false);
        show('propSimplify', false); show('propActions', false);
        show('propPinInfo', false); show('propDistance', false);
        show('propMultiActions', false);
        return;
    }
    show('propNone', false);
    show('propName', !isMulti && !!layer);
    show('propStyle', true);
    show('propSimplify', !isMulti && !!layer && layer.type === 'line');
    show('propActions', !isMulti && !!layer);
    show('propMultiActions', isMulti);

    // Multi-select info header
    if (isMulti) {
        const folder = selectedFolderId ? projectData.folders.find(f => f.id === selectedFolderId) : null;
        const mName = document.getElementById('propMultiName');
        const mCount = document.getElementById('propMultiCount');
        if (folder) {
            mName.textContent = folder.name;
        } else {
            mName.textContent = 'Multiple Layers';
        }
        mCount.textContent = multiCount + ' layer' + (multiCount !== 1 ? 's' : '') + ' selected';

        // Distance for multi-select
        let totalGeo = 0;
        selectedLayerIds.forEach(id => {
            const l = projectData.layers[id];
            if (l && l.type === 'line') totalGeo += calcLineDistance(l.coords);
        });
        const totalEst = totalGeo * (1 + fiberSlackPct / 100);
        document.getElementById('propMultiDistGeo').textContent = formatDistance(totalGeo);
        document.getElementById('propMultiDistEst').textContent = formatDistance(totalEst);
        document.getElementById('propMultiSlackPct').textContent = fiberSlackPct + '%';
    }

    if (!layer) {
        // Folder selected but no primary layer - still show style with first layer's values
        if (selectedLayerIds.size > 0) {
            const firstL = projectData.layers[[...selectedLayerIds][0]];
            if (firstL) {
                renderCompactColorForFolder(firstL.color);
                document.getElementById('propWidth').value = firstL.width;
                document.getElementById('propWidthVal').textContent = firstL.width;
                document.getElementById('propOpacity').value = firstL.opacity;
                document.getElementById('propOpacityVal').textContent = firstL.opacity;
            }
        }
        show('propPinInfo', false); show('propDistance', false);
        // Compact color for folders (single swatch, click to expand)
        document.getElementById('propColorCompactRow').style.display = '';
        document.getElementById('propColorFullRow').style.display = 'none';
        document.getElementById('propColorFullCustomRow').style.display = 'none';
        document.getElementById('propColorExpandPanel').classList.remove('show');
        return;
    }
    show('propActions', !isMulti);

    // Pin info (Enhancement 2 + v1.7 editable GPS + pin type)
    show('propPinInfo', layer.type === 'point');
    if (layer.type === 'point' && layer.coords.length > 0) {
        document.getElementById('propPinLat').value = layer.coords[0][0].toFixed(6);
        document.getElementById('propPinLng').value = layer.coords[0][1].toFixed(6);
        document.getElementById('propPinDesc').value = layer.description || '';
        // Pin type in properties
        const pt = PIN_TYPES.find(p => p.id === (layer.pinType || 'default')) || PIN_TYPES[0];
        document.getElementById('propPinTypeCurrent').innerHTML = pt.svg(layer.color);
        document.getElementById('propPinTypeName').textContent = pt.name;
        const showLabel = layer.showLabel !== false;
        document.getElementById('propPinShowLabel').checked = showLabel;
        document.getElementById('propPinLabelStatus').textContent = showLabel ? 'Visible' : 'Hidden';
        renderPropPinTypeGrid(layer);
    }

    // Distance info (Enhancement 4/5)
    show('propDistance', layer.type === 'line');
    if (layer.type === 'line' && layer.coords.length >= 2) {
        const geo = calcLineDistance(layer.coords);
        const est = geo * (1 + fiberSlackPct / 100);
        document.getElementById('propDistGeo').textContent = formatDistance(geo);
        document.getElementById('propDistEst').textContent = formatDistance(est);
        document.getElementById('propSlackPct').textContent = fiberSlackPct + '%';
    }

    document.getElementById('propNameInput').value = layer.name;
    document.getElementById('propPointCount').textContent = layer.coords.length + (layer.type === 'line' ? ' vertices' : ' (pin)');
    document.getElementById('propType').textContent = layer.type === 'line' ? 'LineString' : 'Pin Marker';

    // Render color: ALWAYS compact (single swatch, click to expand palette)
    const useCompact = true;
    document.getElementById('propColorCompactRow').style.display = '';
    document.getElementById('propColorFullRow').style.display = 'none';
    document.getElementById('propColorFullCustomRow').style.display = 'none';
    // Close expanded panel on selection change
    document.getElementById('propColorExpandPanel').classList.remove('show');

    if (useCompact) {
        // Compact: single swatch (pins, folders, multi-select)
        document.getElementById('propColorCompactSwatch').style.background = layer.color;
        if (layer.color === '#ffffff') document.getElementById('propColorCompactSwatch').style.borderColor = '#ddd';
        else document.getElementById('propColorCompactSwatch').style.borderColor = '#ccc';
        document.getElementById('propColorCompactHex').textContent = layer.color;
        document.getElementById('propColorExpandCustom').value = layer.color;
        // Render expand swatches
        const expandContainer = document.getElementById('propColorExpandSwatches');
        expandContainer.innerHTML = '';
        GIS_COLORS.forEach(c => {
            const s = document.createElement('div');
            s.className = 'prop-color-swatch' + (c === layer.color ? ' active' : '');
            s.style.background = c;
            if (c === '#ffffff') s.style.border = '2px solid #ddd';
            s.addEventListener('click', () => { updateSelectedColor(c); updateCompactColorDisplay(); updatePropsPanel(); });
            expandContainer.appendChild(s);
        });
    } else {
        // Full: all swatches visible
        const swatchContainer = document.getElementById('propColorSwatches');
        swatchContainer.innerHTML = '';
        GIS_COLORS.forEach(c => {
            const s = document.createElement('div');
            s.className = 'prop-color-swatch' + (c === layer.color ? ' active' : '');
            s.style.background = c;
            if (c === '#ffffff') s.style.border = '2px solid #ddd';
            s.addEventListener('click', () => { updateSelectedColor(c); updatePropsPanel(); });
            swatchContainer.appendChild(s);
        });
        document.getElementById('propColorCustom').value = layer.color;
        document.getElementById('propColorHex').textContent = layer.color;
    }

    document.getElementById('propWidth').value = layer.width;
    document.getElementById('propWidthVal').textContent = layer.width;
    document.getElementById('propOpacity').value = layer.opacity;
    document.getElementById('propOpacityVal').textContent = layer.opacity;
    if (layer.type === 'line') previewSimplify(document.getElementById('propTolerance').value);
}

// === PROPERTY UPDATES ===
window.updateSelectedName = (v) => { const l = projectData.layers[selectedLayerId]; if (l) { l.name = v; renderFolderTree(); } };
window.updateSelectedColor = (v) => {
    pushUndo();
    // Apply to ALL selected layers (multi-select aware)
    selectedLayerIds.forEach(id => {
        const l = projectData.layers[id];
        if (l) l.color = v;
    });
    renderMapLayers(); renderFolderTree();
    document.getElementById('propColorCustom').value = v;
    document.getElementById('propColorHex').textContent = v;
    document.querySelectorAll('#propColorSwatches .prop-color-swatch').forEach(s => {
        s.classList.toggle('active', s.style.backgroundColor === hexToRgb(v));
    });
};
window.updateSelectedWidth = (v) => {
    pushUndo();
    const w = parseFloat(v);
    selectedLayerIds.forEach(id => {
        const l = projectData.layers[id];
        if (l) { l.width = w; if (l.leafletLayer && l.leafletLayer.setStyle) l.leafletLayer.setStyle({ weight: w }); }
    });
    document.getElementById('propWidthVal').textContent = v;
};
window.updateSelectedOpacity = (v) => {
    const o = parseFloat(v);
    selectedLayerIds.forEach(id => {
        const l = projectData.layers[id];
        if (l) { l.opacity = o; if (l.leafletLayer && l.leafletLayer.setStyle) l.leafletLayer.setStyle({ opacity: o }); }
    });
    document.getElementById('propOpacityVal').textContent = v;
};

// === SIMPLIFICATION ===
function douglasPeucker(pts, tol) {
    if (pts.length <= 2) return pts;
    let maxD = 0, maxI = 0;
    for (let i = 1; i < pts.length - 1; i++) {
        const d = perpDist(pts[i], pts[0], pts[pts.length - 1]);
        if (d > maxD) { maxD = d; maxI = i; }
    }
    if (maxD > tol) {
        const left = douglasPeucker(pts.slice(0, maxI + 1), tol);
        const right = douglasPeucker(pts.slice(maxI), tol);
        return left.slice(0, -1).concat(right);
    }
    return [pts[0], pts[pts.length - 1]];
}

function perpDist(p, a, b) {
    const dx = b[1] - a[1], dy = b[0] - a[0];
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) return Math.sqrt((p[0] - a[0]) ** 2 + (p[1] - a[1]) ** 2);
    const u = ((p[1] - a[1]) * dx + (p[0] - a[0]) * dy) / (mag * mag);
    return Math.sqrt((p[0] - (a[0] + u * dy)) ** 2 + (p[1] - (a[1] + u * dx)) ** 2);
}

window.previewSimplify = function(tol) {
    tol = parseFloat(tol);
    document.getElementById('propToleranceVal').textContent = tol.toFixed(4);
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'line') return;
    const simp = douglasPeucker(l.coords, tol);
    const pct = ((1 - simp.length / l.coords.length) * 100).toFixed(1);
    document.getElementById('simplifyPreview').innerHTML =
        `Original: ${l.originalCoords.length} → Current: ${l.coords.length} → After: ${simp.length} pts (−${pct}%)`;
};

window.applySimplify = function() {
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'line') return;
    pushUndo();
    const tol = parseFloat(document.getElementById('propTolerance').value);
    l.coords = douglasPeucker(l.coords, tol);
    renderAll(); updatePropsPanel();
    toast('Simplified to ' + l.coords.length + ' points', 'success');
};

window.undoSimplify = function() {
    const l = projectData.layers[selectedLayerId]; if (!l) return;
    pushUndo();
    l.coords = JSON.parse(JSON.stringify(l.originalCoords));
    renderAll(); updatePropsPanel();
    toast('Restored original coordinates', 'info');
};

// =========================================================================
// SEGMENT CHAINING FOR SIMPLIFIED EXPORT (v4.0.0)
// =========================================================================
// 1. Deduplicates exact-copy geometries (common when KMZ has repeated folders)
// 2. Builds endpoint degree map to detect branching junctions
// 3. Only chains through degree-2 endpoints (linear continuation)
//    Stops at degree-3+ junctions (branches) to avoid stitching local
//    wiring networks into the main submarine path
//
// Input:  [{name, coords:[[lat,lon],...], color, width, opacity}, ...]
// Output: array of chained segments (fewer, longer LineStrings)
//
// To disable: comment out chainSimplifiedSegments() calls in
// exportSimplifiedGeoJSON and buildSimplifiedGeoJSONForLayers.
// =========================================================================
function chainSimplifiedSegments(segments) {
    if (!segments || segments.length <= 1) return segments;

    // --- STEP 1: Deduplicate exact-copy geometries ---
    const seen = new Set();
    const unique = [];
    for (const s of segments) {
        const key = s.coords.map(c => c[0].toFixed(5) + ',' + c[1].toFixed(5)).join('|');
        if (!seen.has(key)) {
            seen.add(key);
            unique.push(s);
        }
    }
    const dedupRemoved = segments.length - unique.length;
    if (dedupRemoved > 0) console.log('[CHAIN] Dedup: removed ' + dedupRemoved + ' duplicate geometries');
    if (unique.length <= 1) return unique;

    // Internal coords are [lat, lon]
    const cosLat = Math.cos((unique[0].coords[0][0]) * Math.PI / 180);
    function distSq(a, b) {
        const dlat = a[0] - b[0];
        const dlon = (a[1] - b[1]) * cosLat;
        return dlat * dlat + dlon * dlon;
    }

    // Snap tolerance: ~2km in degrees (matches topology SNAP=0.02)
    const SNAP = 0.02;
    const SNAP_SQ = SNAP * SNAP;

    const segs = unique.map((s, i) => ({
        idx: i, name: s.name, coords: s.coords,
        color: s.color, width: s.width, opacity: s.opacity,
        start: s.coords[0], end: s.coords[s.coords.length - 1],
        used: false
    }));

    // --- STEP 2: Build endpoint degree map ---
    // Grid-based clustering of endpoints to find junctions
    const epGrid = new Map();
    function gridKey(c) { return Math.floor(c[0] / SNAP) + ',' + Math.floor(c[1] / SNAP); }

    for (const seg of segs) {
        for (const ep of [seg.start, seg.end]) {
            const gk = gridKey(ep);
            if (!epGrid.has(gk)) epGrid.set(gk, []);
            epGrid.get(gk).push(ep);
        }
    }

    // Count how many segment-endpoints cluster near a given point
    function junctionDegree(pt) {
        const gx = Math.floor(pt[0] / SNAP), gy = Math.floor(pt[1] / SNAP);
        let count = 0;
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const cell = epGrid.get((gx+dx) + ',' + (gy+dy));
                if (!cell) continue;
                for (const ep of cell) {
                    if (Math.abs(pt[0] - ep[0]) < SNAP && Math.abs(pt[1] - ep[1]) < SNAP) count++;
                }
            }
        }
        return count;
    }

    // --- STEP 3: Chain segments, stopping at branching junctions ---
    const chains = [];

    while (true) {
        // Pick unused seed (prefer longest)
        let seedIdx = -1, maxPts = 0;
        for (let i = 0; i < segs.length; i++) {
            if (!segs[i].used && segs[i].coords.length > maxPts) {
                maxPts = segs[i].coords.length;
                seedIdx = i;
            }
        }
        if (seedIdx < 0) break;

        const seed = segs[seedIdx];
        seed.used = true;
        let chain = [...seed.coords];
        let chainName = seed.name;
        let chainColor = seed.color;
        let chainWidth = seed.width;
        let chainOpacity = seed.opacity;

        // Extend from both ends, but STOP at branching junctions (degree > 2)
        let extended = true;
        while (extended) {
            extended = false;
            const chainEnd = chain[chain.length - 1];
            const chainStart = chain[0];

            // Check if chain END is at a branching junction (degree > 2)
            const endDeg = junctionDegree(chainEnd);
            if (endDeg <= 2) {
                let beIdx = -1, beDist = Infinity, beRev = false;
                for (let i = 0; i < segs.length; i++) {
                    if (segs[i].used) continue;
                    const dS = distSq(chainEnd, segs[i].start);
                    const dE = distSq(chainEnd, segs[i].end);
                    const m = Math.min(dS, dE);
                    if (m < beDist) { beDist = m; beIdx = i; beRev = dE < dS; }
                }
                if (beIdx >= 0 && beDist <= SNAP_SQ) {
                    const seg = segs[beIdx];
                    const coords = beRev ? [...seg.coords].reverse() : seg.coords;
                    const skip = (distSq(chain[chain.length - 1], coords[0]) < SNAP_SQ) ? 1 : 0;
                    for (let j = skip; j < coords.length; j++) chain.push(coords[j]);
                    seg.used = true;
                    extended = true;
                    continue;
                }
            }

            // Check if chain START is at a branching junction (degree > 2)
            const startDeg = junctionDegree(chainStart);
            if (startDeg <= 2) {
                let bsIdx = -1, bsDist = Infinity, bsRev = false;
                for (let i = 0; i < segs.length; i++) {
                    if (segs[i].used) continue;
                    const dE = distSq(chainStart, segs[i].end);
                    const dS = distSq(chainStart, segs[i].start);
                    const m = Math.min(dE, dS);
                    if (m < bsDist) { bsDist = m; bsIdx = i; bsRev = dS < dE; }
                }
                if (bsIdx >= 0 && bsDist <= SNAP_SQ) {
                    const seg = segs[bsIdx];
                    const coords = bsRev ? [...seg.coords].reverse() : seg.coords;
                    const trim = (distSq(chain[0], coords[coords.length - 1]) < SNAP_SQ) ? 1 : 0;
                    chain = [...coords.slice(0, coords.length - trim), ...chain];
                    seg.used = true;
                    extended = true;
                }
            }
        }

        chains.push({ name: chainName, coords: chain, color: chainColor, width: chainWidth, opacity: chainOpacity });
    }

    console.log('[CHAIN] ' + segments.length + ' segs, dedup=' + dedupRemoved +
        ', unique=' + unique.length + ' -> ' + chains.length + ' chains (' +
        chains.reduce((s, c) => s + c.coords.length, 0) + ' pts)');
    return chains;
}

// === EDIT MODE ===
window.toggleEditMode = function() {
    // Deactivate other modes
    if (eraserMode) { eraserMode = false; document.getElementById('btnEraser').classList.remove('active'); document.getElementById('eraserSizeSlider').classList.remove('show'); document.getElementById('eraserBrush').classList.remove('active'); const lcE = document.querySelector('.leaflet-container'); if (lcE) lcE.classList.remove('eraser-cursor'); map.dragging.enable(); }
    if (measureMode) {
        measureMode = false; measureClicks = []; measureClickData = []; clearMeasureMarkers();
        document.getElementById('btnMeasurePath').classList.remove('active');
        const lcm = document.querySelector('.leaflet-container');
        if (lcm) lcm.classList.remove('measure-cursor');
        map.doubleClickZoom.enable();
    }
    if (drawMode) {
        drawCoords = []; if (drawPreviewLayer) { map.removeLayer(drawPreviewLayer); drawPreviewLayer = null; } drawDotMarkers.forEach(m => map.removeLayer(m)); drawDotMarkers = [];
        drawMode = false; document.getElementById('btnDrawLine').classList.remove('active');
        const lcD3 = document.querySelector('.leaflet-container'); if (lcD3) lcD3.classList.remove('draw-cursor');
    }
    if (addPointMode) {
        addPointMode = false; document.getElementById('btnAddPoint').classList.remove('active');
        const lcA3 = document.querySelector('.leaflet-container'); if (lcA3) lcA3.classList.remove('addpoint-cursor');
    }
    editMode = !editMode;
    document.getElementById('btnEditMode').classList.toggle('active', editMode);
    document.getElementById('editBanner').classList.toggle('show', editMode);
    if (editMode) document.getElementById('editBanner').textContent = '✏️ EDIT MODE — Drag vertex dots to reshape lines';
    renderMapLayers();
    renderVertexDots();
    toast(editMode ? 'Edit mode ON — drag vertices to reshape' : 'Edit mode OFF', 'info');
};

window.toggleAddPointMode = function() {
    addPointMode = !addPointMode;
    // Deactivate other modes
    if (addPointMode) {
        if (drawMode) { drawCoords = []; if (drawPreviewLayer) { map.removeLayer(drawPreviewLayer); drawPreviewLayer = null; } drawDotMarkers.forEach(m => map.removeLayer(m)); drawDotMarkers = []; drawMode = false; document.getElementById('btnDrawLine').classList.remove('active'); const lcD2 = document.querySelector('.leaflet-container'); if (lcD2) lcD2.classList.remove('draw-cursor'); }
        if (editMode) { editMode = false; document.getElementById('btnEditMode').classList.remove('active'); }
        if (measureMode) { measureMode = false; measureClicks = []; measureClickData = []; clearMeasureMarkers(); document.getElementById('btnMeasurePath').classList.remove('active'); const lcm = document.querySelector('.leaflet-container'); if (lcm) lcm.classList.remove('measure-cursor'); map.doubleClickZoom.enable(); }
    }
    document.getElementById('btnAddPoint').classList.toggle('active', addPointMode);
    document.getElementById('editBanner').classList.toggle('show', addPointMode);
    if (addPointMode) document.getElementById('editBanner').textContent = '⊕ ADD POINT MODE — Click on map to add vertices to selected line';
    const lcAp = document.querySelector('.leaflet-container');
    if (addPointMode) {
        if (lcAp) lcAp.classList.add('addpoint-cursor');
    } else {
        if (lcAp) lcAp.classList.remove('addpoint-cursor');
    }
    if (addPointMode && !selectedLayerId) {
        toast('Select a line layer first', 'error');
        addPointMode = false; document.getElementById('btnAddPoint').classList.remove('active');
        document.getElementById('editBanner').classList.remove('show');
        if (lcAp) lcAp.classList.remove('addpoint-cursor');
        return;
    }
    renderVertexDots();
    toast(addPointMode ? 'Click on map to add vertices' : 'Add point mode OFF', 'info');
};

// === DRAW MODE ===
let drawMode = false;
let drawCoords = [];
let drawPreviewLayer = null;
let drawDotMarkers = [];

window.toggleDrawMode = function() {
    drawMode = !drawMode;
    // Deactivate other modes
    if (drawMode) {
        if (addPointMode) { addPointMode = false; document.getElementById('btnAddPoint').classList.remove('active'); const lcA2 = document.querySelector('.leaflet-container'); if (lcA2) lcA2.classList.remove('addpoint-cursor'); }
        if (editMode) { editMode = false; document.getElementById('btnEditMode').classList.remove('active'); }
        if (measureMode) { measureMode = false; measureClicks = []; measureClickData = []; clearMeasureMarkers(); document.getElementById('btnMeasurePath').classList.remove('active'); const lcm = document.querySelector('.leaflet-container'); if (lcm) lcm.classList.remove('measure-cursor'); map.doubleClickZoom.enable(); }
    }
    document.getElementById('btnDrawLine').classList.toggle('active', drawMode);
    const lc = document.querySelector('.leaflet-container');
    if (drawMode) {
        drawCoords = [];
        if (lc) lc.classList.add('draw-cursor');
        document.getElementById('editBanner').textContent = '✏️ DRAW MODE — Click to add points, double-click or press Enter to finish, Escape to cancel';
        document.getElementById('editBanner').classList.add('show');
        toast('Click on map to draw a new line', 'info');
    } else {
        if (lc) lc.classList.remove('draw-cursor');
        finishDraw();
    }
};

function finishDraw() {
    if (drawPreviewLayer) { map.removeLayer(drawPreviewLayer); drawPreviewLayer = null; }
    drawDotMarkers.forEach(m => map.removeLayer(m)); drawDotMarkers = [];
    if (drawCoords.length >= 2) {
        pushUndo();
        // Create new layer
        const name = prompt('Name for new line:', 'New Line') || 'New Line';
        const id = genId();
        const color = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');

        // Find or create a folder
        let folderId;
        const existing = projectData.folders.filter(f => !f.parentId);
        if (existing.length > 0) {
            folderId = existing[0].id;
        } else {
            folderId = genFolderId();
            projectData.folders.push({ id: folderId, name: 'Drawn Lines', expanded: true, items: [] });
        }

        projectData.layers[id] = {
            id, name, type: 'line', coords: drawCoords,
            originalCoords: JSON.parse(JSON.stringify(drawCoords)),
            color, width: 3, opacity: 0.9, visible: true,
            folderId, leafletLayer: null, vertexMarkers: []
        };
        const folder = projectData.folders.find(f => f.id === folderId);
        if (folder) folder.items.push(id);

        selectLayer(id);
        renderAll(); updateStatus();
        toast('Created line "' + name + '" with ' + drawCoords.length + ' points', 'success');
    }
    drawCoords = [];
    drawMode = false;
    document.getElementById('btnDrawLine').classList.remove('active');
    const lcDraw = document.querySelector('.leaflet-container');
    if (lcDraw) lcDraw.classList.remove('draw-cursor');
    if (!editMode && !addPointMode) document.getElementById('editBanner').classList.remove('show');
    renderVertexDots();
}

map.on('click', (e) => {
    // Ruler mode (v2.1)
    if (rulerMode) {
        addRulerPoint(e.latlng);
        return;
    }
    // Measure mode (Enhancement 5) - delegate to shared handler
    if (measureMode) {
        handleMeasureClick(e.latlng);
        return;
    }
    // Pin mode (uses selected pin type - Enhancement 7)
    if (pinMode) {
        pushUndo();
        const name = prompt('Pin name:', 'Location') || 'Location';
        const id = genId();
        const coords = [[e.latlng.lat, e.latlng.lng]];
        let folderId;
        const existing = projectData.folders.filter(f => !f.parentId);
        if (existing.length > 0) { folderId = existing[0].id; }
        else { folderId = genFolderId(); projectData.folders.push({ id: folderId, name: 'Markers', expanded: true, items: [], checked: true }); }
        projectData.layers[id] = { id, name, type: 'point', coords, originalCoords: JSON.parse(JSON.stringify(coords)),
            color: '#ef4444', width: 3, opacity: 1, visible: true, folderId, leafletLayer: null, vertexMarkers: [],
            pinType: selectedPinType, description: '' };
        const folder = projectData.folders.find(f => f.id === folderId);
        if (folder) folder.items.push(id);
        selectLayer(id); renderAll(); updateStatus();
        toast('Pin "' + name + '" placed', 'success');
        pinMode = false; document.getElementById('btnPlacePin').classList.remove('active');
        document.getElementById('editBanner').classList.remove('show');
        const lc = document.querySelector('.leaflet-container');
        if (lc) lc.classList.remove('pin-cursor');
        map.doubleClickZoom.enable();
        return;
    }
    // Draw mode
    if (drawMode) {
        drawCoords.push([e.latlng.lat, e.latlng.lng]);
        if (drawPreviewLayer) map.removeLayer(drawPreviewLayer);
        if (drawCoords.length >= 2) {
            drawPreviewLayer = L.polyline(drawCoords, { color: '#ff6600', weight: 3, dashArray: '8,6' }).addTo(map);
        }
        drawDotMarkers.push(L.circleMarker(e.latlng, { radius: 4, color: '#ff6600', fillColor: '#fff', fillOpacity: 1, weight: 2 }).addTo(map));
        return;
    }
    if (!addPointMode) return;
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'line') return;
    let minD = Infinity, ins = l.coords.length;
    for (let i = 0; i < l.coords.length - 1; i++) {
        const d = distToSeg([e.latlng.lat, e.latlng.lng], l.coords[i], l.coords[i + 1]);
        if (d < minD) { minD = d; ins = i + 1; }
    }
    l.coords.splice(ins, 0, [e.latlng.lat, e.latlng.lng]);
    renderMapLayers(); updatePropsPanel(); updateStatus();
});

map.on('dblclick', (e) => {
    if (rulerMode) {
        // Double-click finishes ruler (don't add the point twice)
        deactivateRuler();
        return;
    }
    if (drawMode) {
        e.originalEvent.preventDefault();
        finishDraw();
    }
});

function distToSeg(p, a, b) {
    const dx = b[1] - a[1], dy = b[0] - a[0], len = dx * dx + dy * dy;
    if (len === 0) return Math.sqrt((p[0] - a[0]) ** 2 + (p[1] - a[1]) ** 2);
    let t = Math.max(0, Math.min(1, ((p[1] - a[1]) * dx + (p[0] - a[0]) * dy) / len));
    return Math.sqrt((p[0] - (a[0] + t * dy)) ** 2 + (p[1] - (a[1] + t * dx)) ** 2);
}

// === FOLDER OPS ===
window.createNewFolder = function() {
    projectData.folders.push({ id: genFolderId(), name: 'New Folder', expanded: true, items: [], checked: true });
    renderFolderTree(); toast('Created folder', 'info');
};

window.expandAllFolders = () => { projectData.folders.forEach(f => f.expanded = true); renderFolderTree(); };
window.collapseAllFolders = () => { projectData.folders.forEach(f => f.expanded = false); renderFolderTree(); };

window.selectAllItems = function() {
    const ids = Object.keys(projectData.layers);
    selectedLayerIds.clear();
    ids.forEach(id => selectedLayerIds.add(id));
    selectedLayerId = ids.length > 0 ? ids[0] : null;
    selectedFolderId = null;
    renderAll(); updatePropsPanel();
};
window.deselectAll = function() { selectedLayerId = null; selectedLayerIds.clear(); selectedFolderId = null; renderAll(); updatePropsPanel(); };

// === CONTEXT MENU ===
let ctxTargetFolderId = null;

function showCtxMenu(x, y, isFolder) {
    const m = document.getElementById('ctxMenu');
    // Show/hide items based on target type
    m.querySelectorAll('[data-for]').forEach(el => {
        const forType = el.dataset.for;
        el.style.display = (forType === 'both' || forType === (isFolder ? 'folder' : 'layer')) ? '' : 'none';
    });
    // Position then clamp to viewport (Enhancement 6)
    m.style.left = x + 'px'; m.style.top = y + 'px';
    m.classList.add('show');
    // After render, adjust if overflowing
    requestAnimationFrame(() => {
        const rect = m.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        if (rect.bottom > vh - 10) m.style.top = Math.max(10, vh - rect.height - 10) + 'px';
        if (rect.right > vw - 10) m.style.left = Math.max(10, vw - rect.width - 10) + 'px';
    });
}

document.addEventListener('click', () => { document.getElementById('ctxMenu').classList.remove('show'); closeMenus(); });

window.ctxRename = function() {
    if (ctxTargetFolderId) {
        const f = projectData.folders.find(f => f.id === ctxTargetFolderId);
        if (f) { const n = prompt('Rename folder:', f.name); if (n) { f.name = n; renderFolderTree(); } }
    } else {
        const l = projectData.layers[ctxTargetId]; if (!l) return;
        const n = prompt('Rename:', l.name);
        if (n) { l.name = n; renderAll(); updatePropsPanel(); }
    }
    ctxTargetFolderId = null;
};
window.ctxDuplicate = () => { duplicateLayer(ctxTargetId); ctxTargetFolderId = null; };
window.ctxZoomTo = function() {
    if (ctxTargetFolderId) {
        const f = projectData.folders.find(f => f.id === ctxTargetFolderId);
        if (f) zoomToFolder(f);
    } else {
        const l = projectData.layers[ctxTargetId];
        if (l && l.leafletLayer && l.leafletLayer.getBounds) map.fitBounds(l.leafletLayer.getBounds(), { padding: [40, 40] });
    }
    ctxTargetFolderId = null;
};
window.ctxChangeColor = function() {
    // Create a temporary color picker
    const input = document.createElement('input');
    input.type = 'color';
    input.value = '#3b82f6';
    input.style.position = 'fixed'; input.style.opacity = '0';
    document.body.appendChild(input);
    input.addEventListener('input', () => {
        const color = input.value;
        if (ctxTargetFolderId) {
            applyToFolderLayers(ctxTargetFolderId, l => { l.color = color; });
        } else if (ctxTargetId) {
            const l = projectData.layers[ctxTargetId];
            if (l) l.color = color;
        }
        renderAll(); updatePropsPanel();
    });
    input.addEventListener('change', () => { document.body.removeChild(input); ctxTargetFolderId = null; });
    input.click();
};
window.ctxChangeWidth = function() {
    const w = prompt('Line width (1-12):', '3');
    if (w) {
        const width = Math.max(1, Math.min(12, parseFloat(w)));
        if (ctxTargetFolderId) {
            applyToFolderLayers(ctxTargetFolderId, l => { l.width = width; });
        } else if (ctxTargetId) {
            const l = projectData.layers[ctxTargetId];
            if (l) l.width = width;
        }
        renderAll(); updatePropsPanel();
    }
    ctxTargetFolderId = null;
};
window.ctxMoveToFolder = function() {
    const folders = projectData.folders.filter(f => !f.parentId);
    const choice = prompt('Move to folder:\n' + folders.map((f, i) => (i + 1) + '. ' + f.name).join('\n') + '\n\nEnter number:');
    if (choice) {
        const idx = parseInt(choice) - 1;
        if (idx >= 0 && idx < folders.length) moveLayerToFolder(ctxTargetId, folders[idx].id);
    }
    ctxTargetFolderId = null;
};
window.ctxDelete = function() {
    if (ctxTargetFolderId) {
        if (confirm('Delete this folder and all its layers?')) {
            pushUndo();
            deleteFolderRecursive(ctxTargetFolderId);
            renderAll(); updatePropsPanel(); updateStatus();
            toast('Folder deleted', 'info');
        }
    } else {
        deleteLayer(ctxTargetId);
    }
    ctxTargetFolderId = null;
};

function applyToFolderLayers(folderId, fn) {
    const folder = projectData.folders.find(f => f.id === folderId);
    if (!folder) return;
    folder.items.forEach(id => {
        const layer = projectData.layers[id];
        if (layer) fn(layer);
    });
    // Recurse into sub-folders
    projectData.folders.filter(f => f.parentId === folderId).forEach(sf => {
        applyToFolderLayers(sf.id, fn);
    });
}

function deleteFolderRecursive(folderId) {
    const folder = projectData.folders.find(f => f.id === folderId);
    if (!folder) return;
    // Delete child layers
    folder.items.forEach(id => {
        const l = projectData.layers[id];
        if (l) {
            if (l.leafletLayer) map.removeLayer(l.leafletLayer);
            l.vertexMarkers.forEach(m => map.removeLayer(m));
            delete projectData.layers[id];
            if (selectedLayerId === id) selectedLayerId = null;
        }
    });
    // Recurse sub-folders
    projectData.folders.filter(f => f.parentId === folderId).forEach(sf => {
        deleteFolderRecursive(sf.id);
    });
    // Remove folder from parent
    projectData.folders.forEach(f => { f.items = f.items.filter(i => i !== folderId); });
    projectData.folders = projectData.folders.filter(f => f.id !== folderId);
}

function zoomToFolder(folder) {
    const allCoords = [];
    function collectCoords(fId) {
        const f = projectData.folders.find(ff => ff.id === fId);
        if (!f) return;
        f.items.forEach(id => {
            const l = projectData.layers[id];
            if (l) l.coords.forEach(c => allCoords.push(c));
        });
        projectData.folders.filter(ff => ff.parentId === fId).forEach(sf => collectCoords(sf.id));
    }
    collectCoords(folder.id);
    if (allCoords.length > 0) {
        map.fitBounds(L.latLngBounds(allCoords), { padding: [50, 50] });
    } else {
        toast('No coordinates in this folder', 'info');
    }
}

// === ACTIONS ===
window.zoomToSelected = function() {
    const l = projectData.layers[selectedLayerId];
    if (l && l.leafletLayer && l.leafletLayer.getBounds) map.fitBounds(l.leafletLayer.getBounds(), { padding: [40, 40] });
};

function zoomToAllInternal() {
    const all = [];
    Object.values(projectData.layers).forEach(l => l.coords.forEach(c => all.push(c)));
    if (all.length) map.fitBounds(L.latLngBounds(all), { padding: [40, 40] });
}
window.zoomToAll = zoomToAllInternal;

window.duplicateSelected = () => duplicateLayer(selectedLayerId);

function duplicateLayer(id) {
    const l = projectData.layers[id]; if (!l) return;
    const nid = genId();
    projectData.layers[nid] = { ...l, id: nid, name: l.name + ' (copy)',
        coords: JSON.parse(JSON.stringify(l.coords)),
        originalCoords: JSON.parse(JSON.stringify(l.originalCoords)),
        leafletLayer: null, vertexMarkers: [] };
    const f = projectData.folders.find(f => f.id === l.folderId);
    if (f) f.items.push(nid);
    renderAll(); toast('Duplicated', 'info');
}

window.deleteSelected = () => deleteLayer(selectedLayerId);

function deleteLayer(id) {
    const l = projectData.layers[id]; if (!l) return;
    pushUndo();
    if (l.leafletLayer) map.removeLayer(l.leafletLayer);
    l.vertexMarkers.forEach(m => map.removeLayer(m));
    delete projectData.layers[id];
    projectData.folders.forEach(f => { f.items = f.items.filter(i => i !== id); });
    if (selectedLayerId === id) selectedLayerId = null;
    renderAll(); updatePropsPanel(); toast('Deleted', 'info'); updateStatus();
}

window.clearProject = function() {
    if (!confirm('Clear all layers and folders?')) return;
    pushUndo();
    Object.values(projectData.layers).forEach(l => {
        if (l.leafletLayer) map.removeLayer(l.leafletLayer);
        l.vertexMarkers.forEach(m => map.removeLayer(m));
    });
    projectData = { folders: [], layers: {} };
    selectedLayerId = null;
    renderAll(); updatePropsPanel();
    document.getElementById('emptyState').classList.remove('hidden');
    updateStatus(); toast('Cleared', 'info');
};

// === EXPORT KML ===
// === SAVE (v1.9): writes to same file handle if available, else falls back to Save As ===
window.fileSave = async function() {
    if (currentFileHandle) {
        try {
            const isKmz = currentFileName.toLowerCase().endsWith('.kmz');
            let data;
            if (isKmz) {
                data = await buildKMZBlob();
            } else {
                data = buildKML();
            }
            const writable = await currentFileHandle.createWritable();
            await writable.write(data);
            await writable.close();
            toast('Saved to ' + currentFileName, 'success');
            return;
        } catch (err) {
            // Handle might have been invalidated - fall through to Save As
        }
    }
    // No handle or it failed - use Save As
    fileSaveAs();
};

// === SAVE AS (v1.9): always prompts for filename / location ===
window.fileSaveAs = async function() {
    // Try File System Access API (Chrome/Edge)
    if (window.showSaveFilePicker) {
        try {
            const opts = {
                suggestedName: currentFileName,
                types: [
                    { description: 'KML Files', accept: { 'application/vnd.google-earth.kml+xml': ['.kml'] } },
                    { description: 'KMZ Files (compressed)', accept: { 'application/vnd.google-earth.kmz': ['.kmz'] } },
                    { description: 'GeoJSON Files', accept: { 'application/geo+json': ['.geojson'] } }
                ]
            };
            const handle = await window.showSaveFilePicker(opts);
            const fname = handle.name.toLowerCase();
            const isKmz = fname.endsWith('.kmz');
            const isGeoJson = fname.endsWith('.geojson') || fname.endsWith('.json');
            let data;
            if (isKmz) {
                data = await buildKMZBlob();
            } else if (isGeoJson) {
                data = buildFullGeoJSON();
            } else {
                data = buildKML();
            }
            const writable = await handle.createWritable();
            await writable.write(data);
            await writable.close();
            currentFileHandle = handle;
            currentFileName = handle.name;
            currentFileIsKMZ = isKmz;
            toast('Saved as ' + currentFileName, 'success');
            return;
        } catch (err) {
            if (err.name === 'AbortError') return;
        }
    }
    // Fallback: prompt for name then download
    const name = prompt('Save file as (.kml, .kmz, or .geojson):', currentFileName);
    if (!name) return;
    const nameLc = name.toLowerCase();
    if (nameLc.endsWith('.kmz')) {
        currentFileName = name;
        try {
            const blob = await buildKMZBlob();
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = currentFileName;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            currentFileIsKMZ = true;
            toast('Saved as ' + currentFileName, 'success');
        } catch (err) { toast('KMZ save failed: ' + err.message, 'error'); }
    } else if (nameLc.endsWith('.geojson') || nameLc.endsWith('.json')) {
        currentFileName = name;
        currentFileIsKMZ = false;
        downloadFile(buildFullGeoJSON(), currentFileName, 'application/geo+json');
        toast('Saved as ' + currentFileName, 'success');
    } else {
        currentFileName = name.endsWith('.kml') ? name : name + '.kml';
        currentFileIsKMZ = false;
        downloadFile(buildKML(), currentFileName, 'application/vnd.google-earth.kml+xml');
        toast('Saved as ' + currentFileName, 'success');
    }
};

// Keep old name for backwards compat (keyboard shortcut)
window.saveKML = window.fileSave;

function buildKML() {
    let k = '<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n';
    k += '  <name>NexiMap KML Studio Export</name>\n';
    projectData.folders.filter(f => !f.parentId).forEach(f => { k += buildKMLFolder(f, '  '); });
    k += '</Document>\n</kml>';
    return k;
}

function buildKMLFolder(folder, ind) {
    let k = ind + '<Folder>\n' + ind + '  <name>' + escXml(folder.name) + '</name>\n';
    projectData.folders.filter(f => f.parentId === folder.id).forEach(sf => { k += buildKMLFolder(sf, ind + '  '); });
    folder.items.forEach(id => {
        if (projectData.folders.find(f => f.id === id)) return;
        const l = projectData.layers[id]; if (!l) return;
        k += buildPM(l, ind + '  ');
    });
    k += ind + '</Folder>\n';
    return k;
}

function buildPM(l, ind) {
    const a = Math.round(l.opacity * 255).toString(16).padStart(2, '0');
    const r = l.color.substr(1, 2), g = l.color.substr(3, 2), b = l.color.substr(5, 2);
    let k = ind + '<Placemark>\n' + ind + '  <name>' + escXml(l.name) + '</name>\n';
    k += ind + '  <Style><LineStyle><color>' + a + b + g + r + '</color><width>' + l.width + '</width></LineStyle></Style>\n';
    if (l.type === 'line') {
        k += ind + '  <LineString><coordinates>\n';
        l.coords.forEach(c => { k += ind + '    ' + c[1] + ',' + c[0] + ',0\n'; });
        k += ind + '  </coordinates></LineString>\n';
    } else {
        k += ind + '  <Point><coordinates>' + l.coords[0][1] + ',' + l.coords[0][0] + ',0</coordinates></Point>\n';
    }
    k += ind + '</Placemark>\n';
    return k;
}

// === EXPORT GEOJSON ===
// === EXPORT GEOJSON (auto-simplified, compact) ===
window.exportSimplifiedGeoJSON = function() {
    const lines = Object.values(projectData.layers).filter(l => l.type === 'line');
    const pins = Object.values(projectData.layers).filter(l => l.type === 'point');
    if (!lines.length && !pins.length) { toast('No layers to export', 'error'); return; }

    // Calculate total points and determine if simplification needed
    const totalPts = lines.reduce((s, l) => s + l.coords.length, 0);
    const TARGET_TOTAL = 300;
    let tolerance = 0;

    if (totalPts > TARGET_TOTAL) {
        let lo = 0.0001, hi = 1.0, best = hi;
        for (let iter = 0; iter < 30; iter++) {
            const mid = (lo + hi) / 2;
            const count = lines.reduce((s, l) => s + douglasPeucker(l.coords, mid).length, 0);
            if (count > TARGET_TOTAL) { lo = mid; } else { best = mid; hi = mid; }
        }
        tolerance = best;
    }

    // Simplify each line independently first
    const simplifiedSegs = lines.map(l => ({
        name: l.name,
        coords: tolerance > 0 ? douglasPeucker(l.coords, tolerance) : l.coords,
        color: l.color, width: l.width, opacity: l.opacity
    }));

    // Chain simplified segments into connected paths (see SEGMENT CHAINING section)
    const chained = chainSimplifiedSegments(simplifiedSegs);

    const features = [];
    let totalSimplified = 0;

    chained.forEach(c => {
        totalSimplified += c.coords.length;
        features.push({
            type: 'Feature',
            properties: { name: c.name, stroke: c.color, 'stroke-width': c.width, 'stroke-opacity': c.opacity, layerType: 'line' },
            geometry: {
                type: 'LineString',
                coordinates: c.coords.map(p => [Math.round(p[1] * 100000) / 100000, Math.round(p[0] * 100000) / 100000])
            }
        });
    });

    // Include pins
    pins.forEach(l => {
        features.push({
            type: 'Feature',
            properties: { name: l.name, 'marker-color': l.color, layerType: 'pin' },
            geometry: {
                type: 'Point',
                coordinates: [Math.round(l.coords[0][1] * 100000) / 100000, Math.round(l.coords[0][0] * 100000) / 100000]
            }
        });
    });

    const gj = { type: 'FeatureCollection', features };
    // Compact JSON — no pretty printing
    const jsonStr = JSON.stringify(gj);
    const defaultName = 'Simplified_GeoJSON_' + getProjectName() + '.geojson';
    const name = prompt('Export filename:', defaultName);
    if (!name) return; // cancelled
    const finalName = name.endsWith('.geojson') ? name : name + '.geojson';
    downloadFile(jsonStr, finalName, 'application/geo+json');

    const reduction = totalPts > 0 ? Math.round((1 - totalSimplified / totalPts) * 100) : 0;
    toast(`Exported ${chained.length} chains (from ${lines.length} segments): ${totalPts} → ${totalSimplified} pts (${reduction}% reduction)`, 'success');
};

function getProjectName() {
    const rf = projectData.folders.filter(f => !f.parentId);
    if (rf.length === 1) return rf[0].name.replace(/[^a-zA-Z0-9_-]/g, '_');
    return rf.length > 1 ? 'merged_' + rf.length : 'export';
}


// === FULL GEOJSON EXPORT (v2.5) ===
function buildFullGeoJSON() {
    const features = [];
    Object.values(projectData.layers).forEach(l => {
        if (l.type === 'line' && l.coords.length > 1) {
            features.push({
                type: 'Feature',
                properties: { name: l.name, stroke: l.color, 'stroke-width': l.width, 'stroke-opacity': l.opacity },
                geometry: { type: 'LineString', coordinates: l.coords.map(c => [c[1], c[0]]) }
            });
        } else if (l.type === 'point' && l.coords.length > 0) {
            features.push({
                type: 'Feature',
                properties: { name: l.name, 'marker-color': l.color, pinType: l.pinType || 'default', description: l.description || '' },
                geometry: { type: 'Point', coordinates: [l.coords[0][1], l.coords[0][0]] }
            });
        }
    });
    return JSON.stringify({ type: 'FeatureCollection', features }, null, 2);
}

// Build GeoJSON for specific layers (folder export)
function buildGeoJSONForLayers(layerIds) {
    const features = [];
    layerIds.forEach(id => {
        const l = projectData.layers[id]; if (!l) return;
        if (l.type === 'line' && l.coords.length > 1) {
            features.push({
                type: 'Feature',
                properties: { name: l.name, stroke: l.color, 'stroke-width': l.width, 'stroke-opacity': l.opacity },
                geometry: { type: 'LineString', coordinates: l.coords.map(c => [c[1], c[0]]) }
            });
        } else if (l.type === 'point' && l.coords.length > 0) {
            features.push({
                type: 'Feature',
                properties: { name: l.name, 'marker-color': l.color, pinType: l.pinType || 'default' },
                geometry: { type: 'Point', coordinates: [l.coords[0][1], l.coords[0][0]] }
            });
        }
    });
    return JSON.stringify({ type: 'FeatureCollection', features }, null, 2);
}

// Build simplified GeoJSON for specific layers
function buildSimplifiedGeoJSONForLayers(layerIds) {
    const lines = layerIds.map(id => projectData.layers[id]).filter(l => l && l.type === 'line');
    const pins = layerIds.map(id => projectData.layers[id]).filter(l => l && l.type === 'point');
    const totalPts = lines.reduce((s, l) => s + l.coords.length, 0);
    const TARGET = 300;
    let tol = 0;
    if (totalPts > TARGET) {
        let lo = 0.0001, hi = 1.0, best = hi;
        for (let iter = 0; iter < 30; iter++) {
            const mid = (lo + hi) / 2;
            const count = lines.reduce((s, l) => s + douglasPeucker(l.coords, mid).length, 0);
            if (count > TARGET) lo = mid; else { best = mid; hi = mid; }
        }
        tol = best;
    }
    // Simplify then chain (see SEGMENT CHAINING section)
    const simplifiedSegs = lines.map(l => ({
        name: l.name, coords: tol > 0 ? douglasPeucker(l.coords, tol) : l.coords,
        color: l.color, width: l.width, opacity: l.opacity
    }));
    const chained = chainSimplifiedSegments(simplifiedSegs);

    const features = [];
    chained.forEach(c => {
        features.push({
            type: 'Feature',
            properties: { name: c.name, stroke: c.color, 'stroke-width': c.width, 'stroke-opacity': c.opacity },
            geometry: { type: 'LineString', coordinates: c.coords.map(p => [Math.round(p[1]*1e5)/1e5, Math.round(p[0]*1e5)/1e5]) }
        });
    });
    pins.forEach(l => {
        features.push({
            type: 'Feature',
            properties: { name: l.name, 'marker-color': l.color },
            geometry: { type: 'Point', coordinates: [Math.round(l.coords[0][1]*1e5)/1e5, Math.round(l.coords[0][0]*1e5)/1e5] }
        });
    });
    return JSON.stringify({ type: 'FeatureCollection', features });
}

// Save as GeoJSON (full) from File menu
window.fileSaveAsGeoJSON = function() {
    const gj = buildFullGeoJSON();
    const name = getProjectName() + '.geojson';
    downloadFile(gj, name, 'application/geo+json');
    toast('Saved as GeoJSON: ' + name, 'success');
};

// === ERASER MODE ===
let eraserMode = false;
let eraserSize = 60;
let eraserDragging = false;
let eraserDeletedIds = new Set();

window.toggleEraserMode = function() {
    eraserMode = !eraserMode;
    // Deactivate other modes
    if (eraserMode) {
        if (editMode) toggleEditMode();
        if (addPointMode) toggleAddPointMode();
        if (drawMode) { drawCoords = []; if (drawPreviewLayer) { map.removeLayer(drawPreviewLayer); drawPreviewLayer = null; } drawDotMarkers.forEach(m => map.removeLayer(m)); drawDotMarkers = []; drawMode = false; document.getElementById('btnDrawLine').classList.remove('active'); }
        if (pinMode) { pinMode = false; document.getElementById('btnPlacePin').classList.remove('active'); }
        if (measureMode) { measureMode = false; measureClicks = []; measureClickData = []; clearMeasureMarkers(); document.getElementById('btnMeasurePath').classList.remove('active'); }
        if (rulerMode) { deactivateRuler(); }
    }
    document.getElementById('btnEraser').classList.toggle('active', eraserMode);
    const lc = document.querySelector('.leaflet-container');
    if (eraserMode) {
        document.getElementById('editBanner').textContent = '🧹 ERASER MODE — Drag across features to delete them. Scroll to resize brush.';
        document.getElementById('editBanner').classList.add('show');
        document.getElementById('eraserSizeSlider').classList.add('show');
        document.getElementById('eraserBrush').classList.add('active');
        if (lc) lc.classList.add('eraser-cursor');
        map.dragging.disable();
    } else {
        if (!editMode && !addPointMode && !drawMode && !pinMode) document.getElementById('editBanner').classList.remove('show');
        document.getElementById('eraserSizeSlider').classList.remove('show');
        document.getElementById('eraserBrush').classList.remove('active');
        if (lc) lc.classList.remove('eraser-cursor');
        map.dragging.enable();
    }
    toast(eraserMode ? 'Eraser ON — drag to delete features' : 'Eraser OFF', 'info');
};

window.updateEraserSize = function(v) {
    eraserSize = parseInt(v);
    document.getElementById('eraserSizeLabel').textContent = v + 'px';
    const brush = document.getElementById('eraserBrush');
    brush.style.width = eraserSize + 'px';
    brush.style.height = eraserSize + 'px';
};

// Track mouse for eraser brush visual
document.addEventListener('mousemove', (e) => {
    if (!eraserMode) return;
    const brush = document.getElementById('eraserBrush');
    brush.style.left = e.clientX + 'px';
    brush.style.top = e.clientY + 'px';
    brush.style.width = eraserSize + 'px';
    brush.style.height = eraserSize + 'px';

    if (eraserDragging) {
        eraseAtPoint(e.clientX, e.clientY);
    }
});

// Scroll to resize eraser brush
document.getElementById('mapContainer').addEventListener('wheel', (e) => {
    if (!eraserMode) return;
    e.preventDefault();
    eraserSize = Math.max(20, Math.min(200, eraserSize + (e.deltaY > 0 ? -10 : 10)));
    document.getElementById('eraserSizeRange').value = eraserSize;
    document.getElementById('eraserSizeLabel').textContent = eraserSize + 'px';
    const brush = document.getElementById('eraserBrush');
    brush.style.width = eraserSize + 'px';
    brush.style.height = eraserSize + 'px';
}, { passive: false });

document.getElementById('mapContainer').addEventListener('mousedown', (e) => {
    if (!eraserMode || e.button !== 0) return;
    eraserDragging = true;
    eraserDeletedIds = new Set();
    pushUndo();
    document.getElementById('eraserBrush').classList.add('erasing');
    eraseAtPoint(e.clientX, e.clientY);
});

document.addEventListener('mouseup', () => {
    if (eraserDragging) {
        eraserDragging = false;
        document.getElementById('eraserBrush').classList.remove('erasing');
        if (eraserDeletedIds.size > 0) {
            renderAll(); updatePropsPanel(); updateStatus();
            toast('Erased ' + eraserDeletedIds.size + ' feature(s)', 'info');
        } else {
            // No features erased — pop the undo snapshot we pushed
            undoStack.pop();
        }
        eraserDeletedIds = new Set();
    }
});

function eraseAtPoint(clientX, clientY) {
    const radius = eraserSize / 2;
    // Check each visible layer for proximity to the eraser brush center
    const toDelete = [];
    Object.values(projectData.layers).forEach(layer => {
        if (!layer.visible || !layer.leafletLayer) return;
        if (eraserDeletedIds.has(layer.id)) return;

        if (layer.type === 'line' && layer.coords.length > 0) {
            // Check if any segment of the polyline passes through the brush
            for (let i = 0; i < layer.coords.length; i++) {
                const pt = map.latLngToContainerPoint(L.latLng(layer.coords[i][0], layer.coords[i][1]));
                const mapRect = document.getElementById('map').getBoundingClientRect();
                const screenX = pt.x + mapRect.left;
                const screenY = pt.y + mapRect.top;
                const dx = screenX - clientX;
                const dy = screenY - clientY;
                if (Math.sqrt(dx*dx + dy*dy) <= radius) {
                    toDelete.push(layer.id);
                    break;
                }
            }
        } else if (layer.type === 'point' && layer.coords.length > 0) {
            const pt = map.latLngToContainerPoint(L.latLng(layer.coords[0][0], layer.coords[0][1]));
            const mapRect = document.getElementById('map').getBoundingClientRect();
            const screenX = pt.x + mapRect.left;
            const screenY = pt.y + mapRect.top;
            const dx = screenX - clientX;
            const dy = screenY - clientY;
            if (Math.sqrt(dx*dx + dy*dy) <= radius) {
                toDelete.push(layer.id);
            }
        }
    });

    toDelete.forEach(id => {
        eraserDeletedIds.add(id);
        const l = projectData.layers[id];
        if (l) {
            if (l.leafletLayer) map.removeLayer(l.leafletLayer);
            l.vertexMarkers.forEach(m => map.removeLayer(m));
            delete projectData.layers[id];
            projectData.folders.forEach(f => { f.items = f.items.filter(i => i !== id); });
            if (selectedLayerId === id) selectedLayerId = null;
            selectedLayerIds.delete(id);
        }
    });
}

// === MENUS ===
window.toggleMenu = function(id, btn) {
    const m = document.getElementById(id);
    const wasOpen = m.classList.contains('show');
    closeMenus();
    if (!wasOpen) {
        const rect = btn.getBoundingClientRect();
        m.style.left = rect.left + 'px';
        m.style.top = rect.bottom + 2 + 'px';
        m.classList.add('show');
        event.stopPropagation();
    }
};
window.closeMenus = function() {
    document.querySelectorAll('.menu-dropdown').forEach(m => m.classList.remove('show'));
};

// === PIN PLACEMENT MODE ===
let pinMode = false;

// === FILE TRACKING (v1.9) ===
let currentFileName = 'neximap_export.kml';
let currentFileHandle = null; // File System Access API handle (if available)

window.togglePinMode = function() {
    pinMode = !pinMode;
    drawMode = false; addPointMode = false;
    document.getElementById('btnDrawLine').classList.remove('active');
    document.getElementById('btnAddPoint').classList.remove('active');
    document.getElementById('btnPlacePin').classList.toggle('active', pinMode);
    if (pinMode) {
        document.getElementById('editBanner').textContent = '📍 PIN MODE — Click on map to place a marker, Escape to cancel';
        document.getElementById('editBanner').classList.add('show');
        const lc = document.querySelector('.leaflet-container');
        if (lc) lc.classList.add('pin-cursor');
        // Disable doubleClickZoom so click fires instantly (no 200ms delay)
        map.doubleClickZoom.disable();
    } else {
        document.getElementById('editBanner').classList.remove('show');
        const lc = document.querySelector('.leaflet-container');
        if (lc) lc.classList.remove('pin-cursor');
        map.doubleClickZoom.enable();
    }
    toast(pinMode ? 'Click on map to place a pin' : 'Pin mode OFF', 'info');
};

// Pin click is handled in the main map.on('click') handler below

// === COLOR PALETTE ===
const GIS_COLORS = [
    '#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6',
    '#06b6d4','#0ea5e9','#3b82f6','#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899',
    '#f43f5e','#78716c','#64748b','#1e293b','#ffffff','#000000','#00ff00','#ff00ff'
];
let colorPaletteTarget = null; // 'selected', 'folder:id', or callback function

window.showColorPalette = function(btn) {
    const pal = document.getElementById('colorPalette');
    if (pal.classList.contains('show')) { pal.classList.remove('show'); return; }
    colorPaletteTarget = 'selected';
    const rect = btn.getBoundingClientRect();
    pal.style.left = rect.left + 'px';
    pal.style.top = (rect.bottom + 4) + 'px';
    renderColorSwatches();
    pal.classList.add('show');
};

window.showColorPaletteForSelected = function() {
    if (!selectedLayerId) { toast('Select a layer first', 'error'); return; }
    colorPaletteTarget = 'selected';
    const pal = document.getElementById('colorPalette');
    pal.style.left = '50%'; pal.style.top = '80px';
    renderColorSwatches();
    pal.classList.add('show');
};

function renderColorSwatches() {
    const container = document.getElementById('colorSwatches');
    container.innerHTML = '';
    const currentColor = selectedLayerId && projectData.layers[selectedLayerId] ? projectData.layers[selectedLayerId].color : '';
    GIS_COLORS.forEach(c => {
        const s = document.createElement('div');
        s.className = 'color-swatch' + (c === currentColor ? ' active' : '');
        s.style.background = c;
        if (c === '#ffffff') s.style.border = '2px solid #ddd';
        s.addEventListener('click', () => applyPaletteColor(c));
        container.appendChild(s);
    });
    document.getElementById('customColorPicker').value = currentColor || '#3b82f6';
    document.getElementById('customColorPicker').onchange = (e) => applyPaletteColor(e.target.value);
}

function applyPaletteColor(color) {
    if (colorPaletteTarget === 'selected') {
        const l = projectData.layers[selectedLayerId];
        if (l) { l.color = color; renderAll(); updatePropsPanel(); }
    } else if (typeof colorPaletteTarget === 'function') {
        colorPaletteTarget(color);
    }
    document.getElementById('colorPalette').classList.remove('show');
}

// Close palette on outside click
document.addEventListener('click', (e) => {
    const pal = document.getElementById('colorPalette');
    if (pal.classList.contains('show') && !pal.contains(e.target) && !e.target.closest('#btnColorPick')) {
        pal.classList.remove('show');
    }
});

// Update ctxChangeColor to use palette
window.ctxChangeColor = function() {
    const pal = document.getElementById('colorPalette');
    pal.style.left = (event.clientX || 100) + 'px';
    pal.style.top = (event.clientY || 100) + 'px';
    if (ctxTargetFolderId) {
        colorPaletteTarget = (color) => {
            applyToFolderLayers(ctxTargetFolderId, l => { l.color = color; });
            renderAll(); updatePropsPanel();
            ctxTargetFolderId = null;
        };
    } else if (ctxTargetId) {
        const prev = selectedLayerId;
        selectedLayerId = ctxTargetId;
        colorPaletteTarget = 'selected';
        // Restore after
        setTimeout(() => { selectedLayerId = prev; }, 0);
        selectedLayerId = ctxTargetId;
        colorPaletteTarget = (color) => {
            const l = projectData.layers[ctxTargetId];
            if (l) l.color = color;
            renderAll(); updatePropsPanel();
        };
    }
    renderColorSwatches();
    pal.classList.add('show');
};

// === LINE WIDTH PROMPT ===
window.promptLineWidth = function() {
    const l = projectData.layers[selectedLayerId];
    if (!l) { toast('Select a layer first', 'error'); return; }
    const w = prompt('Line width (1-12):', l.width || '3');
    if (w) {
        l.width = Math.max(1, Math.min(12, parseFloat(w)));
        renderAll(); updatePropsPanel();
    }
};

// === LOGO OVERLAY ===
let logoData = { src: null, x: 10, y: null, width: 150 };

window.loadLogoImage = function() { document.getElementById('logoInput').click(); };

window.handleLogoUpload = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        logoData.src = ev.target.result;
        const overlay = document.getElementById('logoOverlay');
        const img = document.getElementById('logoImage');
        img.src = logoData.src;
        img.style.maxWidth = logoData.width + 'px';
        overlay.classList.add('show');
        // Position bottom-left by default
        const mapRect = document.getElementById('mapContainer').getBoundingClientRect();
        logoData.x = 10;
        logoData.y = mapRect.height - 90;
        overlay.style.left = logoData.x + 'px';
        overlay.style.bottom = '10px';
        overlay.style.top = 'auto';
        toast('Logo added — drag to reposition', 'success');
    };
    reader.readAsDataURL(file);
    e.target.value = '';
};

window.removeLogo = function() {
    logoData.src = null;
    document.getElementById('logoOverlay').classList.remove('show');
    toast('Logo removed', 'info');
};

window.toggleLogoSettings = function() {
    if (!logoData.src) { toast('No logo loaded — use View > Add Logo first', 'error'); return; }
    const size = prompt('Logo max width in pixels (50-400):', logoData.width);
    if (size) {
        logoData.width = Math.max(50, Math.min(400, parseInt(size)));
        document.getElementById('logoImage').style.maxWidth = logoData.width + 'px';
    }
};

// Logo drag
(function() {
    const overlay = document.getElementById('logoOverlay');
    let dragging = false, startX, startY, origX, origY;

    overlay.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('logo-remove') || e.target.classList.contains('logo-resize')) return;
        dragging = true;
        startX = e.clientX; startY = e.clientY;
        const rect = overlay.getBoundingClientRect();
        const mapRect = document.getElementById('mapContainer').getBoundingClientRect();
        origX = rect.left - mapRect.left;
        origY = rect.top - mapRect.top;
        overlay.style.bottom = 'auto';
        overlay.style.top = origY + 'px';
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX, dy = e.clientY - startY;
        overlay.style.left = (origX + dx) + 'px';
        overlay.style.top = (origY + dy) + 'px';
        overlay.style.bottom = 'auto';
    });

    document.addEventListener('mouseup', () => { dragging = false; });

    // Resize handle
    const resizeHandle = document.getElementById('logoResizeHandle');
    let resizing = false, resizeStartX, resizeOrigW;

    resizeHandle.addEventListener('mousedown', (e) => {
        resizing = true;
        resizeStartX = e.clientX;
        resizeOrigW = logoData.width;
        e.stopPropagation(); e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!resizing) return;
        const dw = e.clientX - resizeStartX;
        logoData.width = Math.max(50, Math.min(400, resizeOrigW + dw));
        document.getElementById('logoImage').style.maxWidth = logoData.width + 'px';
    });

    document.addEventListener('mouseup', () => { resizing = false; });
})();

// === BATCH SIMPLIFY ===
window.batchSimplifyAll = function() {
    const target = prompt('Target total points across all lines (default 300):', '300');
    if (!target) return;
    pushUndo();
    const TARGET = parseInt(target);
    const lines = Object.values(projectData.layers).filter(l => l.type === 'line');
    const totalBefore = lines.reduce((s, l) => s + l.coords.length, 0);

    if (totalBefore <= TARGET) {
        toast('Already under target (' + totalBefore + ' pts)', 'info'); return;
    }

    let lo = 0.0001, hi = 1.0, best = hi;
    for (let iter = 0; iter < 30; iter++) {
        const mid = (lo + hi) / 2;
        const count = lines.reduce((s, l) => s + douglasPeucker(l.coords, mid).length, 0);
        if (count > TARGET) { lo = mid; } else { best = mid; hi = mid; }
    }

    lines.forEach(l => { l.coords = douglasPeucker(l.coords, best); });
    const totalAfter = lines.reduce((s, l) => s + l.coords.length, 0);
    renderAll(); updatePropsPanel(); updateStatus();
    toast(`Simplified: ${totalBefore} → ${totalAfter} points`, 'success');
};

// === PROJECT STATS ===
window.showProjectStats = function() {
    const layers = Object.values(projectData.layers);
    const lines = layers.filter(l => l.type === 'line');
    const points = layers.filter(l => l.type === 'point');
    const totalPts = lines.reduce((s, l) => s + l.coords.length, 0);
    const folders = projectData.folders.length;
    alert(
        `Project Statistics\n` +
        `─────────────────\n` +
        `Folders: ${folders}\n` +
        `Line segments: ${lines.length}\n` +
        `Pin markers: ${points.length}\n` +
        `Total vertices: ${totalPts.toLocaleString()}\n` +
        `Avg pts/line: ${lines.length ? Math.round(totalPts / lines.length) : 0}`
    );
};

// === ENHANCED GEOJSON EXPORT/IMPORT (with pins) ===
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'o') { e.preventDefault(); openFile(); }
    if (e.ctrlKey && e.shiftKey && e.key === 'Z') { e.preventDefault(); redo(); return; }
    if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); return; }
    if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); return; }
    if (e.ctrlKey && e.shiftKey && e.key === 'S') { e.preventDefault(); fileSaveAs(); }
    else if (e.ctrlKey && e.key === 's') { e.preventDefault(); fileSave(); }
    if (e.key === 'Delete' && selectedLayerId) { deleteSelected(); }
    if (e.key === 'Escape') {
        if (eraserMode) { toggleEraserMode(); }
        else if (rulerMode) { deactivateRuler(); }
        else if (measureMode) { measureMode = false; measureClicks = []; measureClickData = []; clearMeasureMarkers(); document.getElementById('btnMeasurePath').classList.remove('active'); if (!editMode) document.getElementById('editBanner').classList.remove('show'); const lcm = document.querySelector('.leaflet-container'); if (lcm) lcm.classList.remove('measure-cursor'); map.doubleClickZoom.enable(); renderVertexDots(); toast('Measure cancelled', 'info'); }
        else if (pinMode) { pinMode = false; document.getElementById('btnPlacePin').classList.remove('active'); document.getElementById('editBanner').classList.remove('show'); const lc2 = document.querySelector('.leaflet-container'); if (lc2) lc2.classList.remove('pin-cursor'); map.doubleClickZoom.enable(); toast('Pin mode cancelled', 'info'); }
        else if (drawMode) { drawCoords = []; if (drawPreviewLayer) { map.removeLayer(drawPreviewLayer); drawPreviewLayer = null; } drawDotMarkers.forEach(m => map.removeLayer(m)); drawDotMarkers = []; drawMode = false; document.getElementById('btnDrawLine').classList.remove('active'); document.getElementById('editBanner').classList.remove('show'); const lcD = document.querySelector('.leaflet-container'); if (lcD) lcD.classList.remove('draw-cursor'); renderVertexDots(); toast('Draw cancelled', 'info'); }
        else if (editMode) toggleEditMode();
        if (addPointMode) toggleAddPointMode();
        document.getElementById('colorPalette').classList.remove('show');
        document.getElementById('pinTypeWindow').classList.remove('show');
        closeDistancePanel();
    }
    if (e.key === 'Enter' && rulerMode && rulerCoords.length >= 2) { deactivateRuler(); }
    else if (e.key === 'Enter' && drawMode) { finishDraw(); }
});

// === UTILS ===
function downloadFile(content, filename, mime) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([content], { type: mime }));
    a.download = filename;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
}
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
function hexToRgb(h) {
    const r = parseInt(h.slice(1,3),16), g = parseInt(h.slice(3,5),16), b = parseInt(h.slice(5,7),16);
    return `rgb(${r}, ${g}, ${b})`;
}
function escXml(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); }

function toast(msg, type) {
    const c = document.getElementById('toastContainer');
    const t = document.createElement('div');
    t.className = 'toast ' + (type || 'info');
    t.textContent = msg;
    c.appendChild(t);
    setTimeout(() => { t.style.opacity = '0'; t.style.transition = 'opacity 0.3s'; setTimeout(() => t.remove(), 300); }, 3000);
}

function updateStatus() {
    const lc = Object.keys(projectData.layers).length;
    const tp = Object.values(projectData.layers).reduce((s, l) => s + l.coords.length, 0);
    document.getElementById('statusText').textContent = lc + ' layers · ' + tp.toLocaleString() + ' vertices';
}

// Resize handle
const leftResize = document.getElementById('leftResize');
leftResize.addEventListener('mousedown', () => {
    const onMove = (e) => {
        document.getElementById('leftPanel').style.width = Math.max(180, Math.min(400, e.clientX)) + 'px';
    };
    const onUp = () => { document.removeEventListener('mousemove', onMove); map.invalidateSize(); };
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp, { once: true });
});

updateStatus();


// === SETTINGS (fiber slack) ===
let fiberSlackPct = 10;
let viewportBiasEnabled = false;

window.openSlackSettings = function() {
    document.getElementById('settingsSlackPct').value = fiberSlackPct;
    document.getElementById('settingsVertexZoom').value = vertexMinZoom;
    document.getElementById('settingsVertexMax').value = vertexMaxDots;
    document.getElementById('settingsViewportBias').checked = viewportBiasEnabled;
    document.getElementById('settingsOverlay').classList.add('show');
};
window.closeSlackSettings = function() {
    document.getElementById('settingsOverlay').classList.remove('show');
};
window.saveSlackSettings = function() {
    fiberSlackPct = parseFloat(document.getElementById('settingsSlackPct').value) || 0;
    vertexMinZoom = parseInt(document.getElementById('settingsVertexZoom').value) || 13;
    vertexMaxDots = parseInt(document.getElementById('settingsVertexMax').value) || 2000;
    toggleViewportBias(document.getElementById('settingsViewportBias').checked);
    document.getElementById('settingsOverlay').classList.remove('show');
    renderVertexDots();
    updateVertexZoomHint();
    updateSearchBiasHint();
    toast('Settings saved', 'success');
    updatePropsPanel();
};

// === PIN TYPES (Enhancement 7) ===
const PIN_TYPES = [
    { id: 'default', name: 'Default', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><path d="M12 0C5.4 0 0 5.4 0 12c0 9 12 24 12 24s12-15 12-24C24 5.4 18.6 0 12 0z" fill="'+c+'"/><circle cx="12" cy="12" r="5" fill="white" opacity="0.9"/></svg>' },
    { id: 'square', name: 'Square', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="2" y="2" width="20" height="20" rx="3" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><rect x="7" y="7" width="10" height="10" rx="1" fill="white" opacity="0.9"/></svg>' },
    { id: 'diamond', name: 'Diamond', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><polygon points="12,0 24,12 12,24 0,12" fill="'+c+'"/><polygon points="12,30 9,24 15,24" fill="'+c+'"/><circle cx="12" cy="12" r="4" fill="white" opacity="0.9"/></svg>' },
    { id: 'star', name: 'Star', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><polygon points="12,0 15,8 24,9 17,15 19,24 12,19 5,24 7,15 0,9 9,8" fill="'+c+'"/><polygon points="12,36 9,24 15,24" fill="'+c+'"/><circle cx="12" cy="12" r="3" fill="white" opacity="0.9"/></svg>' },
    { id: 'triangle', name: 'Triangle', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><polygon points="12,0 24,20 0,20" fill="'+c+'"/><polygon points="12,36 9,20 15,20" fill="'+c+'"/><circle cx="12" cy="11" r="3" fill="white" opacity="0.9"/></svg>' },
    { id: 'flag', name: 'Flag', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="3" y="0" width="2" height="36" fill="'+c+'"/><polygon points="5,0 24,0 20,8 24,16 5,16" fill="'+c+'"/><rect x="8" y="4" width="10" height="8" rx="1" fill="white" opacity="0.6"/></svg>' },
    { id: 'circle', name: 'Circle', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><circle cx="12" cy="12" r="12" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><circle cx="12" cy="12" r="5" fill="white" opacity="0.9"/></svg>' },
    { id: 'house', name: 'Building', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><polygon points="12,0 24,10 24,22 0,22 0,10" fill="'+c+'"/><polygon points="12,36 9,22 15,22" fill="'+c+'"/><rect x="9" y="12" width="6" height="10" fill="white" opacity="0.9"/></svg>' },
    { id: 'tower', name: 'Tower', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="8" y="4" width="8" height="20" rx="1" fill="'+c+'"/><polygon points="12,0 8,4 16,4" fill="'+c+'"/><polygon points="12,36 8,24 16,24" fill="'+c+'"/><circle cx="12" cy="10" r="2.5" fill="white" opacity="0.9"/><rect x="10" y="15" width="4" height="4" rx="0.5" fill="white" opacity="0.7"/></svg>' },
    { id: 'server', name: 'Data Center', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="2" y="2" width="20" height="22" rx="2" fill="'+c+'"/><polygon points="12,36 8,24 16,24" fill="'+c+'"/><rect x="5" y="5" width="14" height="4" rx="1" fill="white" opacity="0.8"/><rect x="5" y="11" width="14" height="4" rx="1" fill="white" opacity="0.8"/><rect x="5" y="17" width="14" height="4" rx="1" fill="white" opacity="0.8"/><circle cx="16" cy="7" r="1" fill="'+c+'"/><circle cx="16" cy="13" r="1" fill="'+c+'"/><circle cx="16" cy="19" r="1" fill="'+c+'"/></svg>' },
    { id: 'splice', name: 'Splice', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><ellipse cx="12" cy="12" rx="10" ry="7" fill="'+c+'"/><polygon points="12,36 9,19 15,19" fill="'+c+'"/><line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="2"/><circle cx="10" cy="12" r="1.5" fill="white"/><circle cx="14" cy="12" r="1.5" fill="white"/></svg>' },
    { id: 'manhole', name: 'Manhole', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="2" y="4" width="20" height="18" rx="9" fill="'+c+'"/><polygon points="12,36 9,22 15,22" fill="'+c+'"/><ellipse cx="12" cy="13" rx="6" ry="5" fill="none" stroke="white" stroke-width="1.5"/><line x1="6" y1="13" x2="18" y2="13" stroke="white" stroke-width="1.5"/><line x1="12" y1="8" x2="12" y2="18" stroke="white" stroke-width="1.5"/></svg>' },
    { id: 'antenna', name: 'Antenna', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="10" y="10" width="4" height="16" fill="'+c+'"/><polygon points="12,36 9,26 15,26" fill="'+c+'"/><line x1="12" y1="2" x2="12" y2="10" stroke="'+c+'" stroke-width="2"/><path d="M6 4a8 8 0 0 1 12 0" fill="none" stroke="white" stroke-width="1.5"/><path d="M8 7a5 5 0 0 1 8 0" fill="none" stroke="white" stroke-width="1.5"/><circle cx="12" cy="2" r="2" fill="white"/></svg>' },
    { id: 'pole', name: 'Pole', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="10.5" y="2" width="3" height="34" fill="'+c+'"/><line x1="4" y1="8" x2="20" y2="8" stroke="'+c+'" stroke-width="2.5"/><line x1="6" y1="14" x2="18" y2="14" stroke="'+c+'" stroke-width="2"/><circle cx="6" cy="8" r="1.5" fill="white"/><circle cx="18" cy="8" r="1.5" fill="white"/><circle cx="8" cy="14" r="1.2" fill="white"/><circle cx="16" cy="14" r="1.2" fill="white"/></svg>' },
    { id: 'cabinet', name: 'Cabinet', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="3" y="3" width="18" height="19" rx="2" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><line x1="12" y1="5" x2="12" y2="20" stroke="white" stroke-width="1.2"/><rect x="5" y="5" width="5" height="13" rx="1" fill="none" stroke="white" stroke-width="1" opacity="0.7"/><rect x="14" y="5" width="5" height="13" rx="1" fill="none" stroke="white" stroke-width="1" opacity="0.7"/><circle cx="9" cy="16" r="0.8" fill="white"/><circle cx="15" cy="16" r="0.8" fill="white"/></svg>' },
    { id: 'exchange', name: 'Exchange', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><rect x="2" y="4" width="20" height="18" rx="2" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><rect x="5" y="6" width="14" height="3" rx="1" fill="white" opacity="0.8"/><rect x="5" y="11" width="14" height="3" rx="1" fill="white" opacity="0.8"/><rect x="5" y="16" width="14" height="3" rx="1" fill="white" opacity="0.8"/><path d="M4 7h2M4 12h2M4 17h2" stroke="white" stroke-width="0.8"/></svg>' },
    { id: 'warning', name: 'Warning', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><polygon points="12,1 23,22 1,22" fill="'+c+'"/><polygon points="12,36 9,22 15,22" fill="'+c+'"/><line x1="12" y1="8" x2="12" y2="15" stroke="white" stroke-width="2.5" stroke-linecap="round"/><circle cx="12" cy="18.5" r="1.5" fill="white"/></svg>' },
    { id: 'cross', name: 'Marker X', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><circle cx="12" cy="12" r="11" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><line x1="7" y1="7" x2="17" y2="17" stroke="white" stroke-width="2.5" stroke-linecap="round"/><line x1="17" y1="7" x2="7" y2="17" stroke="white" stroke-width="2.5" stroke-linecap="round"/></svg>' },
    { id: 'info', name: 'Info', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><circle cx="12" cy="12" r="11" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><circle cx="12" cy="7" r="1.8" fill="white"/><rect x="10.2" y="10.5" width="3.6" height="8" rx="1" fill="white"/></svg>' },
    { id: 'check', name: 'Complete', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><circle cx="12" cy="12" r="11" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><polyline points="7,12 10.5,16 17,8" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>' },
    { id: 'wrench', name: 'Repair', svg: (c) => '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><circle cx="12" cy="12" r="11" fill="'+c+'"/><polygon points="12,36 8,22 16,22" fill="'+c+'"/><path d="M8 8l2 2-1.5 1.5L10 13l3-3 1.5 1.5L16 10l-2-2c1.5-0.5 3.2 0 4 1.2a3.5 3.5 0 0 1-1 4.3L11 19.5a3.5 3.5 0 0 1-4.3 1 3.5 3.5 0 0 1-1.2-4L8 8z" fill="white" opacity="0.9"/></svg>' },
];

let selectedPinType = 'default';

function renderPinTypeGrid() {
    const grid = document.getElementById('pinTypeGrid');
    grid.innerHTML = '';
    PIN_TYPES.forEach(pt => {
        const opt = document.createElement('div');
        opt.className = 'pin-type-option' + (pt.id === selectedPinType ? ' active' : '');
        opt.innerHTML = pt.svg('#0096D6') + '<span>' + pt.name + '</span>';
        opt.addEventListener('click', () => {
            selectedPinType = pt.id;
            document.querySelectorAll('.pin-type-option').forEach(o => o.classList.remove('active'));
            opt.classList.add('active');
            toast('Pin type: ' + pt.name, 'info');
        });
        grid.appendChild(opt);
    });
}

function getPinSvg(pinTypeId, color) {
    const pt = PIN_TYPES.find(p => p.id === pinTypeId) || PIN_TYPES[0];
    return pt.svg(color);
}

window.togglePinTypeWindow = function() {
    const w = document.getElementById('pinTypeWindow');
    if (w.classList.contains('show')) { w.classList.remove('show'); return; }
    renderPinTypeGrid();
    const btn = document.getElementById('btnPinTypes');
    const r = btn.getBoundingClientRect();
    w.style.left = r.left + 'px';
    w.style.top = (r.bottom + 4) + 'px';
    w.classList.add('show');
};

// Make pin type window draggable
(function() {
    const el = document.getElementById('pinTypeWindow');
    const handle = document.getElementById('pinTypeDragHandle');
    let dragging = false, sx, sy, ox, oy;
    handle.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON') return;
        dragging = true; sx = e.clientX; sy = e.clientY;
        const r = el.getBoundingClientRect(); ox = r.left; oy = r.top;
        e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        el.style.left = (ox + e.clientX - sx) + 'px';
        el.style.top = (oy + e.clientY - sy) + 'px';
    });
    document.addEventListener('mouseup', () => { dragging = false; });
})();

// === MAP LAYER SELECTOR TOGGLE + DRAG (Enhancement 1) ===
window.toggleMapLayerSelector = function() {
    document.getElementById('mapLayerSelector').classList.toggle('hidden');
};

(function() {
    const el = document.getElementById('mapLayerSelector');
    const handle = document.getElementById('mapLayerDragHandle');
    let dragging = false, sx, sy, ox, oy;
    handle.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON') return;
        dragging = true; sx = e.clientX; sy = e.clientY;
        const r = el.getBoundingClientRect();
        const mr = document.getElementById('mapContainer').getBoundingClientRect();
        ox = r.left - mr.left; oy = r.top - mr.top;
        el.style.right = 'auto'; el.classList.add('dragging');
        e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        el.style.left = (ox + e.clientX - sx) + 'px';
        el.style.top = (oy + e.clientY - sy) + 'px';
    });
    document.addEventListener('mouseup', () => { dragging = false; el.classList.remove('dragging'); });
})();

// === PIN DESCRIPTION (Enhancement 2) ===
window.updatePinDescription = function(val) {
    const l = projectData.layers[selectedLayerId];
    if (l && l.type === 'point') l.description = val;
};

window.togglePinLabel = function(show) {
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'point') return;
    l.showLabel = show;
    document.getElementById('propPinLabelStatus').textContent = show ? 'Visible' : 'Hidden';
    renderMapLayers();
};


// === PIN GPS EDITING (v1.7) ===
window.updatePinGPS = function(which, val) {
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'point') return;
    const num = parseFloat(val);
    if (isNaN(num)) { toast('Invalid coordinate value', 'error'); updatePropsPanel(); return; }
    if (which === 'lat') {
        if (num < -90 || num > 90) { toast('Latitude must be between -90 and 90', 'error'); updatePropsPanel(); return; }
        l.coords[0][0] = num;
    } else {
        if (num < -180 || num > 180) { toast('Longitude must be between -180 and 180', 'error'); updatePropsPanel(); return; }
        l.coords[0][1] = num;
    }
    l.originalCoords = JSON.parse(JSON.stringify(l.coords));
    renderMapLayers();
    // Pan map to new location
    map.panTo(l.coords[0]);
    toast('Pin moved to ' + l.coords[0][0].toFixed(4) + ', ' + l.coords[0][1].toFixed(4), 'info');
};

// === COMPACT PIN COLOR TOGGLE (v1.7) ===
window.togglePinColorExpand = function() {
    document.getElementById('propColorExpandPanel').classList.toggle('show');
};
window.updateCompactColorDisplay = function() {
    const l = projectData.layers[selectedLayerId];
    if (!l) return;
    document.getElementById('propColorCompactSwatch').style.background = l.color;
    document.getElementById('propColorCompactHex').textContent = l.color;
    // Also update pin type icon color
    if (l.type === 'point') {
        const pt = PIN_TYPES.find(p => p.id === (l.pinType || 'default')) || PIN_TYPES[0];
        document.getElementById('propPinTypeCurrent').innerHTML = pt.svg(l.color);
    }
};

// === PIN TYPE IN PROPERTIES PANEL (v1.7) ===
window.togglePropPinTypeGrid = function() {
    document.getElementById('propPinTypeGrid').classList.toggle('show');
};
function renderPropPinTypeGrid(layer) {
    const grid = document.getElementById('propPinTypeGrid');
    grid.innerHTML = '';
    grid.classList.remove('show');
    PIN_TYPES.forEach(pt => {
        const opt = document.createElement('div');
        opt.className = 'prop-pin-type-opt' + (pt.id === (layer.pinType || 'default') ? ' active' : '');
        opt.innerHTML = pt.svg(layer.color) + '<span>' + pt.name + '</span>';
        opt.addEventListener('click', () => {
            layer.pinType = pt.id;
            renderMapLayers();
            updatePropsPanel();
            toast('Pin type: ' + pt.name, 'info');
        });
        grid.appendChild(opt);
    });
}


// === MULTI-SELECT ACTION FUNCTIONS (v1.8) ===
window.zoomToMultiSelected = function() {
    const bounds = L.latLngBounds([]);
    selectedLayerIds.forEach(id => {
        const l = projectData.layers[id];
        if (l && l.leafletLayer) {
            if (l.leafletLayer.getBounds) bounds.extend(l.leafletLayer.getBounds());
            else if (l.leafletLayer.getLatLng) bounds.extend(l.leafletLayer.getLatLng());
        }
    });
    if (bounds.isValid()) map.fitBounds(bounds, { padding: [40, 40] });
};

window.deleteMultiSelected = function() {
    if (selectedLayerIds.size === 0) return;
    if (!confirm('Delete ' + selectedLayerIds.size + ' selected layer(s)?')) return;
    pushUndo();
    selectedLayerIds.forEach(id => {
        const l = projectData.layers[id];
        if (l) {
            if (l.leafletLayer) map.removeLayer(l.leafletLayer);
            l.vertexMarkers.forEach(m => map.removeLayer(m));
            delete projectData.layers[id];
            projectData.folders.forEach(f => { f.items = f.items.filter(i => i !== id); });
        }
    });
    selectedLayerId = null; selectedLayerIds.clear(); selectedFolderId = null;
    renderAll(); updatePropsPanel(); updateStatus();
    toast('Deleted layers', 'success');
};

window.calcSelectedDistance = function() {
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'line') { toast('Select a line to calculate distance', 'error'); return; }
    const geo = calcLineDistance(l.coords);
    const est = geo * (1 + fiberSlackPct / 100);
    showDistancePanel({ title: l.name, geo, est, slack: fiberSlackPct });
};

window.calcMultiDistance = function() {
    let totalGeo = 0;
    selectedLayerIds.forEach(id => {
        const l = projectData.layers[id];
        if (l && l.type === 'line') totalGeo += calcLineDistance(l.coords);
    });
    const est = totalGeo * (1 + fiberSlackPct / 100);
    const label = selectedFolderId
        ? (projectData.folders.find(f => f.id === selectedFolderId) || {}).name || 'Folder'
        : selectedLayerIds.size + ' layers';
    showDistancePanel({ title: label, geo: totalGeo, est, slack: fiberSlackPct });
};

window.startMeasureFromProps = function() {
    if (!measureMode) toggleMeasureMode();
};


// Render compact color swatch for folder selection (v2.1)
function renderCompactColorForFolder(currentColor) {
    document.getElementById('propColorCompactSwatch').style.background = currentColor;
    if (currentColor === '#ffffff') document.getElementById('propColorCompactSwatch').style.borderColor = '#ddd';
    else document.getElementById('propColorCompactSwatch').style.borderColor = '#ccc';
    document.getElementById('propColorCompactHex').textContent = currentColor;
    document.getElementById('propColorExpandCustom').value = currentColor;
    // Render expand swatches
    const expandContainer = document.getElementById('propColorExpandSwatches');
    expandContainer.innerHTML = '';
    GIS_COLORS.forEach(c => {
        const s = document.createElement('div');
        s.className = 'prop-color-swatch' + (c === currentColor ? ' active' : '');
        s.style.background = c;
        if (c === '#ffffff') s.style.border = '2px solid #ddd';
        s.addEventListener('click', () => { updateSelectedColor(c); updateCompactColorDisplay(); updatePropsPanel(); });
        expandContainer.appendChild(s);
    });
}

function renderMultiColorSwatches(currentColor) {
    const swatchContainer = document.getElementById('propColorSwatches');
    swatchContainer.innerHTML = '';
    GIS_COLORS.forEach(c => {
        const s = document.createElement('div');
        s.className = 'prop-color-swatch' + (c === currentColor ? ' active' : '');
        s.style.background = c;
        if (c === '#ffffff') s.style.border = '2px solid #ddd';
        s.addEventListener('click', () => { updateSelectedColor(c); updatePropsPanel(); });
        swatchContainer.appendChild(s);
    });
    document.getElementById('propColorCustom').value = currentColor;
    document.getElementById('propColorHex').textContent = currentColor;
}


// === EXPORT IMAGE (v1.9) ===
window.showExportImageDialog = function() {
    // Create dialog overlay
    const overlay = document.createElement('div');
    overlay.className = 'export-overlay';
    overlay.id = 'exportImageOverlay';
    overlay.innerHTML = `
        <div class="export-dialog">
            <h3>🖼️ Export Map Image</h3>
            <label>File name</label>
            <input type="text" id="exportImgName" value="neximap_map">
            <label>Format</label>
            <select id="exportImgFormat">
                <option value="png" selected>PNG (best quality)</option>
                <option value="jpeg">JPG (smaller file)</option>
                <option value="svg">SVG (vector)</option>
            </select>
            <label>Quality <span id="exportQualityLabel" style="color:var(--text-muted);">(JPG only)</span></label>
            <input type="range" id="exportImgQuality" min="0.1" max="1" step="0.05" value="0.92" style="margin-bottom:14px;">
            <div class="export-dialog-btns">
                <button onclick="closeExportImageDialog()">Cancel</button>
                <button class="primary" onclick="doExportImage()">Export</button>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) closeExportImageDialog(); });
};

window.closeExportImageDialog = function() {
    const el = document.getElementById('exportImageOverlay');
    if (el) el.remove();
};

window.doExportImage = async function() {
    const name = document.getElementById('exportImgName').value || 'neximap_map';
    const format = document.getElementById('exportImgFormat').value;
    const quality = parseFloat(document.getElementById('exportImgQuality').value);
    closeExportImageDialog();
    toast('Rendering map image…', 'info');

    if (format === 'svg') {
        exportMapSVG(name);
        return;
    }

    // Use html2canvas approach via leaflet tiles + canvas
    try {
        const mapEl = document.getElementById('map');
        const rect = mapEl.getBoundingClientRect();
        const canvas = document.createElement('canvas');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);

        // Draw white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, rect.width, rect.height);

        // Capture tile images
        const tilePane = mapEl.querySelector('.leaflet-tile-pane');
        if (tilePane) {
            const tiles = tilePane.querySelectorAll('img');
            const tilePromises = Array.from(tiles).map(img => {
                return new Promise(resolve => {
                    if (img.complete && img.naturalWidth > 0) { resolve(img); return; }
                    const clone = new Image();
                    clone.crossOrigin = 'anonymous';
                    clone.onload = () => resolve(clone);
                    clone.onerror = () => resolve(null);
                    clone.src = img.src;
                });
            });
            const loadedTiles = await Promise.all(tilePromises);

            // Get transform offset
            const tileCont = tilePane.querySelector('.leaflet-tile-container');
            let tx = 0, ty = 0;
            if (tileCont) {
                const style = tileCont.style.transform || '';
                const match = style.match(/translate3d\((-?\d+)px,\s*(-?\d+)px/);
                if (match) { tx = parseInt(match[1]); ty = parseInt(match[2]); }
            }

            tiles.forEach((img, i) => {
                const loaded = loadedTiles[i];
                if (!loaded) return;
                const imgRect = img.getBoundingClientRect();
                const x = imgRect.left - rect.left;
                const y = imgRect.top - rect.top;
                try { ctx.drawImage(loaded, x, y, imgRect.width, imgRect.height); } catch(e) {}
            });
        }

        // Draw polylines
        Object.values(projectData.layers).forEach(layer => {
            if (!layer.visible) return;
            if (layer.type === 'line' && layer.coords.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = layer.color;
                ctx.lineWidth = layer.width;
                ctx.globalAlpha = layer.opacity;
                ctx.lineJoin = 'round'; ctx.lineCap = 'round';
                layer.coords.forEach((c, i) => {
                    const pt = map.latLngToContainerPoint(c);
                    if (i === 0) ctx.moveTo(pt.x, pt.y);
                    else ctx.lineTo(pt.x, pt.y);
                });
                ctx.stroke();
                ctx.globalAlpha = 1;
            } else if (layer.type === 'point' && layer.coords.length > 0) {
                const pt = map.latLngToContainerPoint(layer.coords[0]);
                // Draw pin as circle marker
                ctx.beginPath();
                ctx.arc(pt.x, pt.y - 8, 8, 0, Math.PI * 2);
                ctx.fillStyle = layer.color;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(pt.x, pt.y - 8, 3.5, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                // Pin tail
                ctx.beginPath();
                ctx.moveTo(pt.x - 4, pt.y - 2);
                ctx.lineTo(pt.x, pt.y + 4);
                ctx.lineTo(pt.x + 4, pt.y - 2);
                ctx.fillStyle = layer.color;
                ctx.fill();
            }
        });

        // Export
        const mime = format === 'jpeg' ? 'image/jpeg' : 'image/png';
        const ext = format === 'jpeg' ? '.jpg' : '.png';
        canvas.toBlob(blob => {
            if (!blob) { toast('Export failed', 'error'); return; }
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = name + ext;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            toast('Exported ' + name + ext, 'success');
        }, mime, quality);

    } catch (err) {
        toast('Export failed: ' + err.message, 'error');
    }
};

function exportMapSVG(name) {
    const mapEl = document.getElementById('map');
    const rect = mapEl.getBoundingClientRect();
    const w = Math.round(rect.width), h = Math.round(rect.height);

    let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">\n`;
    svg += `<rect width="${w}" height="${h}" fill="#f2f2f2"/>\n`;

    // Draw polylines
    Object.values(projectData.layers).forEach(layer => {
        if (!layer.visible) return;
        if (layer.type === 'line' && layer.coords.length > 1) {
            const pts = layer.coords.map(c => {
                const p = map.latLngToContainerPoint(c);
                return p.x.toFixed(1) + ',' + p.y.toFixed(1);
            }).join(' ');
            svg += `<polyline points="${pts}" fill="none" stroke="${layer.color}" stroke-width="${layer.width}" stroke-opacity="${layer.opacity}" stroke-linejoin="round" stroke-linecap="round"/>\n`;
        } else if (layer.type === 'point' && layer.coords.length > 0) {
            const p = map.latLngToContainerPoint(layer.coords[0]);
            svg += `<circle cx="${p.x.toFixed(1)}" cy="${(p.y - 8).toFixed(1)}" r="8" fill="${layer.color}"/>\n`;
            svg += `<circle cx="${p.x.toFixed(1)}" cy="${(p.y - 8).toFixed(1)}" r="3.5" fill="white"/>\n`;
            svg += `<polygon points="${(p.x-4).toFixed(1)},${(p.y-2).toFixed(1)} ${p.x.toFixed(1)},${(p.y+4).toFixed(1)} ${(p.x+4).toFixed(1)},${(p.y-2).toFixed(1)}" fill="${layer.color}"/>\n`;
        }
    });

    svg += '</svg>';
    downloadFile(svg, name + '.svg', 'image/svg+xml');
    toast('Exported ' + name + '.svg', 'success');
}

// === PRINT MAP (v1.9) ===
window.printMap = function() {
    toast('Preparing print view…', 'info');
    // Brief delay to let toast show, then trigger print
    setTimeout(() => { window.print(); }, 200);
};


// === RULER POLYLINE TOOL (v2.1) ===
let rulerMode = false;
let rulerCoords = [];
let rulerPolyline = null;
let rulerCircles = [];
let rulerPreviewLine = null;

window.toggleRulerMode = function() {
    if (rulerMode) {
        deactivateRuler();
        return;
    }
    // Deactivate other modes
    if (drawMode) { drawCoords = []; if (drawPreviewLayer) { map.removeLayer(drawPreviewLayer); drawPreviewLayer = null; } drawDotMarkers.forEach(m => map.removeLayer(m)); drawDotMarkers = []; drawMode = false; document.getElementById('btnDrawLine').classList.remove('active'); }
    if (pinMode) { pinMode = false; document.getElementById('btnPlacePin').classList.remove('active'); const lc0 = document.querySelector('.leaflet-container'); if (lc0) lc0.classList.remove('pin-cursor'); map.doubleClickZoom.enable(); }
    if (measureMode) { measureMode = false; measureClicks = []; measureClickData = []; clearMeasureMarkers(); document.getElementById('btnMeasurePath').classList.remove('active'); const lcm0 = document.querySelector('.leaflet-container'); if (lcm0) lcm0.classList.remove('measure-cursor'); map.doubleClickZoom.enable(); renderVertexDots(); }
    if (addPointMode) { addPointMode = false; document.getElementById('btnAddPoint').classList.remove('active'); }

    rulerMode = true;
    rulerCoords = [];
    document.getElementById('btnRuler').classList.add('active');
    document.getElementById('editBanner').textContent = '📏 RULER — Click to add points, double-click or Enter to finish, Escape to cancel';
    document.getElementById('editBanner').classList.add('show');
    document.getElementById('rulerPanel').classList.add('show');
    updateRulerDisplay();
    const lc = document.querySelector('.leaflet-container');
    if (lc) lc.classList.add('ruler-cursor');
    map.doubleClickZoom.disable();
    toast('Ruler: click to start measuring', 'info');
};

function deactivateRuler() {
    rulerMode = false;
    rulerCoords = [];
    document.getElementById('btnRuler').classList.remove('active');
    if (!editMode) document.getElementById('editBanner').classList.remove('show');
    document.getElementById('rulerPanel').classList.remove('show');
    // Remove all ruler visuals
    if (rulerPolyline) { map.removeLayer(rulerPolyline); rulerPolyline = null; }
    if (rulerPreviewLine) { map.removeLayer(rulerPreviewLine); rulerPreviewLine = null; }
    rulerCircles.forEach(c => map.removeLayer(c));
    rulerCircles = [];
    const lc = document.querySelector('.leaflet-container');
    if (lc) lc.classList.remove('ruler-cursor');
    map.doubleClickZoom.enable();
    toast('Ruler off', 'info');
}

function addRulerPoint(latlng) {
    rulerCoords.push([latlng.lat, latlng.lng]);
    // Add circle marker at point
    const c = L.circleMarker(latlng, {
        radius: 5, color: '#f59e0b', fillColor: '#fff', fillOpacity: 1, weight: 2.5, zIndexOffset: 2000
    }).addTo(map);
    rulerCircles.push(c);
    // Update polyline
    if (rulerPolyline) map.removeLayer(rulerPolyline);
    if (rulerCoords.length >= 2) {
        rulerPolyline = L.polyline(rulerCoords, {
            color: '#f59e0b', weight: 3, opacity: 0.9, dashArray: '8,6'
        }).addTo(map);
    }
    updateRulerDisplay();
}

function updateRulerDisplay() {
    let dist = 0;
    for (let i = 0; i < rulerCoords.length - 1; i++) {
        dist += haversineDistance(rulerCoords[i][0], rulerCoords[i][1], rulerCoords[i+1][0], rulerCoords[i+1][1]);
    }
    document.getElementById('rulerDistance').textContent = formatDistance(dist);
    const estDist = dist * (1 + fiberSlackPct / 100);
    const pts = rulerCoords.length;
    let info = pts + ' point' + (pts !== 1 ? 's' : '');
    if (pts >= 2) info += ' — Est: ' + formatDistance(estDist) + ' (+' + fiberSlackPct + '% slack)';
    else info += ' — Click to add points';
    document.getElementById('rulerPoints').textContent = info;
}

// Hook into map click for ruler
// We patch the main click handler below

// Re-render vertex dots on pan/zoom (v2.4)
map.on('moveend', () => { scheduleVertexDotsUpdate(); });
map.on('zoomend', () => { scheduleVertexDotsUpdate(); });

// Hook into map mousemove for ruler preview line
map.on('mousemove', (e) => {
    if (!rulerMode || rulerCoords.length === 0) {
        if (rulerPreviewLine) { map.removeLayer(rulerPreviewLine); rulerPreviewLine = null; }
        return;
    }
    const lastPt = rulerCoords[rulerCoords.length - 1];
    if (rulerPreviewLine) map.removeLayer(rulerPreviewLine);
    rulerPreviewLine = L.polyline([lastPt, [e.latlng.lat, e.latlng.lng]], {
        color: '#f59e0b', weight: 2, opacity: 0.5, dashArray: '4,4'
    }).addTo(map);
});


// === KMZ SUPPORT (v2.2) ===
let currentFileIsKMZ = false;

// Extract KML text from a KMZ file (which is a ZIP containing doc.kml or *.kml)
async function extractKMLFromKMZ(file) {
    if (typeof JSZip === 'undefined') {
        throw new Error('JSZip library not loaded. Check your internet connection and reload.');
    }
    const buf = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(buf);
    // Look for doc.kml first, then any .kml file
    let kmlFile = zip.file('doc.kml');
    if (!kmlFile) {
        // Search for any .kml file in the root or subdirectories
        const kmlFiles = zip.file(/\.kml$/i);
        if (kmlFiles.length > 0) kmlFile = kmlFiles[0];
    }
    if (!kmlFile) throw new Error('No KML file found inside KMZ archive');
    return await kmlFile.async('string');
}

// Build a KMZ blob (ZIP containing doc.kml)
async function buildKMZBlob() {
    if (typeof JSZip === 'undefined') {
        throw new Error('JSZip library not loaded. Check your internet connection and reload.');
    }
    const kml = buildKML();
    const zip = new JSZip();
    zip.file('doc.kml', kml);
    return await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
}


// === GEOCODING SEARCH (v2.3) ===
// Viewport bias toggle — syncs inline toggle, settings checkbox, and label
window.toggleViewportBias = function(val) {
    viewportBiasEnabled = val;
    // Sync inline toggle
    const inlineEl = document.getElementById('biasToggleInline');
    if (inlineEl) inlineEl.checked = val;
    // Sync settings dialog checkbox
    const settingsEl = document.getElementById('settingsViewportBias');
    if (settingsEl) settingsEl.checked = val;
    // Update label style
    const label = document.getElementById('biasLabel');
    if (label) {
        if (val) { label.classList.add('active'); label.textContent = '📍 Bias'; }
        else { label.classList.remove('active'); label.textContent = 'Bias'; }
    }
};
function updateSearchBiasHint() {
    toggleViewportBias(viewportBiasEnabled);
}

// Uses OpenStreetMap Nominatim — free, no API key, 1 req/sec rate limit
let searchTimeout = null;
let searchResults = [];
let searchActiveIdx = -1;

const searchInput = document.getElementById('searchInput');
const searchResultsEl = document.getElementById('searchResults');

searchInput.addEventListener('input', (e) => {
    const q = e.target.value.trim();
    if (q.length < 2) { hideSearchResults(); return; }
    // Debounce: wait 400ms after user stops typing
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => geocodeSearch(q), 400);
});

searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown') {
        e.preventDefault();
        searchActiveIdx = Math.min(searchActiveIdx + 1, searchResults.length - 1);
        highlightSearchResult();
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        searchActiveIdx = Math.max(searchActiveIdx - 1, 0);
        highlightSearchResult();
    } else if (e.key === 'Enter') {
        e.preventDefault();
        if (searchActiveIdx >= 0 && searchActiveIdx < searchResults.length) {
            goToSearchResult(searchResults[searchActiveIdx]);
        } else if (searchInput.value.trim().length >= 2) {
            geocodeSearch(searchInput.value.trim());
        }
    } else if (e.key === 'Escape') {
        hideSearchResults();
        searchInput.blur();
    }
});

// Close results when clicking outside
document.addEventListener('click', (e) => {
    if (!document.getElementById('searchContainer').contains(e.target)) {
        hideSearchResults();
    }
});

async function geocodeSearch(query) {
    searchResultsEl.innerHTML = '<div class="search-loading">Searching…</div>';
    searchResultsEl.classList.add('show');
    searchActiveIdx = -1;

    try {
        let url = 'https://nominatim.openstreetmap.org/search?'
            + 'q=' + encodeURIComponent(query)
            + '&format=json&addressdetails=1&limit=8&accept-language=en';
        // Viewport bias: send current map bounds as viewbox hint
        if (viewportBiasEnabled && map) {
            const b = map.getBounds();
            url += '&viewbox=' + b.getWest().toFixed(6) + ',' + b.getNorth().toFixed(6)
                + ',' + b.getEast().toFixed(6) + ',' + b.getSouth().toFixed(6)
                + '&bounded=0';
        }
        const resp = await fetch(url, {
            headers: { 'User-Agent': 'NexiMapKMLStudio/2.6.2 (geocoding)' }
        });
        if (!resp.ok) throw new Error('Search failed');
        const data = await resp.json();
        searchResults = data;
        renderSearchResults(data, query);
    } catch (err) {
        searchResultsEl.innerHTML = '<div class="search-no-results">Search failed. Check internet connection.</div>';
    }
}

function renderSearchResults(results, query) {
    if (results.length === 0) {
        searchResultsEl.innerHTML = '<div class="search-no-results">No results for "' + esc(query) + '"</div>';
        return;
    }
    searchResultsEl.innerHTML = '';
    results.forEach((r, i) => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.idx = i;

        const typeIcon = getSearchTypeIcon(r.type, r.class);
        const displayName = r.display_name.split(',')[0];
        const fullAddr = r.display_name;

        item.innerHTML = `
            <div class="search-result-icon">${typeIcon}</div>
            <div class="search-result-text">
                <div class="search-result-name">${esc(displayName)}</div>
                <div class="search-result-addr" title="${esc(fullAddr)}">${esc(fullAddr)}</div>
            </div>
            <button class="search-result-pin" title="Create pin marker here">+Pin</button>
        `;

        item.addEventListener('click', (e) => {
            if (e.target.closest('.search-result-pin')) {
                createPinFromSearch(r);
            } else {
                goToSearchResult(r);
            }
        });

        searchResultsEl.appendChild(item);
    });
}

function getSearchTypeIcon(type, cls) {
    // Return appropriate SVG icon based on OSM type
    if (cls === 'building' || type === 'house' || type === 'apartments')
        return '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="2" width="16" height="20" rx="2"/><path d="M9 22v-4h6v4"/><path d="M8 6h.01M16 6h.01M8 10h.01M16 10h.01M8 14h.01M16 14h.01"/></svg>';
    if (cls === 'highway' || type === 'road' || type === 'street' || type === 'motorway')
        return '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 4l2 16"/><path d="M17 4l2 16"/><path d="M12 4v16"/></svg>';
    if (cls === 'amenity' || cls === 'shop')
        return '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>';
    if (cls === 'place' || type === 'city' || type === 'town' || type === 'village')
        return '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 21h18"/><path d="M5 21V7l5-4v18"/><path d="M19 21V11l-5-2v12"/></svg>';
    if (cls === 'boundary' || type === 'administrative')
        return '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M9 3v18"/></svg>';
    // Default: location pin
    return '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>';
}

function goToSearchResult(r) {
    const lat = parseFloat(r.lat);
    const lng = parseFloat(r.lon);
    // Zoom level based on bounding box size or type
    let zoom = 15;
    if (r.boundingbox) {
        const bb = r.boundingbox.map(parseFloat);
        const latSpan = Math.abs(bb[1] - bb[0]);
        const lngSpan = Math.abs(bb[3] - bb[2]);
        const maxSpan = Math.max(latSpan, lngSpan);
        if (maxSpan > 5) zoom = 6;
        else if (maxSpan > 1) zoom = 9;
        else if (maxSpan > 0.1) zoom = 12;
        else if (maxSpan > 0.01) zoom = 15;
        else zoom = 17;
    }
    map.setView([lat, lng], zoom);
    hideSearchResults();

    // Show temporary marker (fades after 5 seconds)
    const tempIcon = L.divIcon({
        className: 'search-temp-marker',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    const tempMarker = L.marker([lat, lng], { icon: tempIcon, zIndexOffset: 5000 }).addTo(map);
    const displayName = r.display_name.split(',')[0];
    tempMarker.bindPopup(
        '<div style="font-size:12px;max-width:220px;">'
        + '<b>' + esc(displayName) + '</b><br>'
        + '<span style="font-size:10px;color:#666;">' + esc(r.display_name) + '</span><br>'
        + '<span style="font-size:10px;color:#999;">' + lat.toFixed(5) + ', ' + lng.toFixed(5) + '</span><br>'
        + '<button onclick="createPinAtCoords(' + lat + ',' + lng + ',\'' + esc(displayName).replace(/'/g, "\\'") + '\');this.closest(\'.leaflet-popup\').remove();" '
        + 'style="margin-top:6px;padding:3px 10px;background:#0096D6;color:white;border:none;border-radius:4px;font-size:11px;cursor:pointer;">Create Pin Here</button>'
        + '</div>'
    ).openPopup();
    // Auto-remove after 8 seconds
    setTimeout(() => { if (tempMarker) map.removeLayer(tempMarker); }, 8000);

    toast('Found: ' + displayName, 'info');
}

function createPinFromSearch(r) {
    const lat = parseFloat(r.lat);
    const lng = parseFloat(r.lon);
    const displayName = r.display_name.split(',')[0];
    createPinAtCoords(lat, lng, displayName);
    hideSearchResults();
    map.setView([lat, lng], 16);
}

window.createPinAtCoords = function(lat, lng, name) {
    pushUndo();
    const id = genId();
    const coords = [[lat, lng]];
    let folderId;
    const existing = projectData.folders.filter(f => !f.parentId);
    if (existing.length > 0) { folderId = existing[0].id; }
    else { folderId = genFolderId(); projectData.folders.push({ id: folderId, name: 'Markers', expanded: true, items: [], checked: true }); }
    projectData.layers[id] = { id, name: name || 'Search Pin', type: 'point', coords, originalCoords: JSON.parse(JSON.stringify(coords)),
        color: '#0096D6', width: 3, opacity: 1, visible: true, folderId, leafletLayer: null, vertexMarkers: [],
        pinType: 'default', description: '' };
    const folder = projectData.folders.find(f => f.id === folderId);
    if (folder) folder.items.push(id);
    selectLayer(id); renderAll(); updateStatus();
    toast('Pin "' + name + '" created', 'success');
};

function highlightSearchResult() {
    searchResultsEl.querySelectorAll('.search-result-item').forEach((el, i) => {
        el.classList.toggle('active', i === searchActiveIdx);
    });
    const active = searchResultsEl.querySelector('.search-result-item.active');
    if (active) active.scrollIntoView({ block: 'nearest' });
}

function hideSearchResults() {
    searchResultsEl.classList.remove('show');
    searchActiveIdx = -1;
}

window.clearSearch = function() {
    searchInput.value = '';
    hideSearchResults();
    searchInput.focus();
};

// === HAVERSINE DISTANCE UTILITY ===
function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function calcLineDistance(coords) {
    let total = 0;
    for (let i = 0; i < coords.length - 1; i++) {
        total += haversineDistance(coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
    }
    return total;
}

function calcPathDistance(coords, fromIdx, toIdx) {
    let total = 0;
    const start = Math.min(fromIdx, toIdx);
    const end = Math.max(fromIdx, toIdx);
    for (let i = start; i < end; i++) {
        total += haversineDistance(coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
    }
    return total;
}

function formatDistance(km) {
    if (km < 1) return (km * 1000).toFixed(1) + ' m';
    return km.toFixed(3) + ' km';
}

function calcFolderDistance(folderId) {
    let total = 0;
    function recurse(fId) {
        const f = projectData.folders.find(ff => ff.id === fId);
        if (!f) return;
        f.items.forEach(id => {
            const l = projectData.layers[id];
            if (l && l.type === 'line') total += calcLineDistance(l.coords);
        });
        projectData.folders.filter(ff => ff.parentId === fId).forEach(sf => recurse(sf.id));
    }
    recurse(folderId);
    return total;
}

// === DISTANCE IN CONTEXT MENU (Enhancement 5) ===
window.ctxCalcDistance = function() {
    let geo = 0;
    if (ctxTargetFolderId) {
        geo = calcFolderDistance(ctxTargetFolderId);
    } else if (ctxTargetId) {
        const l = projectData.layers[ctxTargetId];
        if (l && l.type === 'line') geo = calcLineDistance(l.coords);
        else if (l && l.type === 'point') { toast('Pins have no path distance', 'info'); return; }
    }
    const est = geo * (1 + fiberSlackPct / 100);
    showDistancePanel({
        title: ctxTargetFolderId ? 'Folder Distance' : 'Segment Distance',
        geo, est, slack: fiberSlackPct
    });
    ctxTargetFolderId = null;
};

let _distPanelData = null;
let _distModeStrict = true;

function showDistancePanel(data) {
    _distPanelData = data;
    _distModeStrict = true;
    _buildDistancePanel();
}

window.toggleDistMode = function(toStrict) {
    if (_distModeStrict === toStrict) return;
    _distModeStrict = toStrict;
    _updateDistValues();
    // Swap the polyline on the map
    const result = window._lastMeasureResult;
    if (result && measureLineLayer) {
        map.removeLayer(measureLineLayer);
        const coords = _distModeStrict ? result.pathCoords : result.bestEstCoords;
        if (coords && coords.length > 1) {
            const color = _distModeStrict ? '#f59e0b' : '#e67e22';
            measureLineLayer = L.polyline(coords, { color, weight: 6, opacity: 0.85, dashArray: '10,6' }).addTo(map);
        }
    }
};

function _buildDistancePanel() {
    const data = _distPanelData;
    if (!data) return;
    const dp = document.getElementById('distancePanel');
    const dc = document.getElementById('distanceContent');

    let html = '<div class="dist-row"><span class="dist-label" style="font-weight:600;">' + (data.title || 'Distance') + '</span></div>';

    // Mode toggle - only for cross-segment with gaps
    if (data.hasBestEst) {
        html += '<div class="dist-mode-toggle">';
        html += '<label id="distLabelStrict" class="active" style="cursor:pointer;">&#x1F517; Strict Cable</label>';
        html += '<div class="dist-mode-switch"><input type="checkbox" id="distModeSwitch"><span class="slider"></span></div>';
        html += '<label id="distLabelEst" style="cursor:pointer;">&#x1F4D0; Best Estimate</label>';
        html += '</div>';
    }

    html += '<div class="dist-row"><span class="dist-label">Geometric distance:</span><span class="dist-value" id="distValGeo">' + formatDistance(data.geo) + '</span></div>';
    html += '<div class="dist-row"><span class="dist-label">Fiber slack:</span><span class="dist-value">' + data.slack + '%</span></div>';
    html += '<div class="dist-row"><span class="dist-label">Estimated distance:</span><span class="dist-value" id="distValEst">' + formatDistance(data.geo * (1 + data.slack / 100)) + '</span></div>';

    // Cable vs gap breakdown
    if (data.hasBestEst) {
        html += '<div style="margin-top:6px;border-top:1px solid #eee;padding-top:6px;">';
        html += '<div class="dist-row"><span class="dist-label">Cable segments:</span><span class="dist-value">' + formatDistance(data.cableDist) + '</span></div>';
        html += '<div class="dist-row"><span class="dist-label">Gap jumps (' + data.gapCount + '):</span><span class="dist-value orange">' + formatDistance(data.gapDist) + '</span></div>';
        html += '<div class="dist-gap-info" id="distModeHint">&#x26A0;&#xFE0F; Strict mode routes through all cable segments including loops &#x2014; actual path may be shorter</div>';
        html += '</div>';
    }

    if (data.aEnd !== undefined) {
        html += '<div style="margin-top:6px;border-top:1px solid #eee;padding-top:6px;">';
        html += '<div class="dist-row"><span class="dist-label">A-End (green):</span><span class="dist-value green">vertex ' + (data.aEnd + 1) + '</span></div>';
        html += '<div class="dist-row"><span class="dist-label">B-End (red):</span><span class="dist-value" style="color:var(--danger);">vertex ' + (data.bEnd + 1) + '</span></div>';
        if (data.crossSegment) {
            html += '<div class="dist-row"><span class="dist-label">Route type:</span><span class="dist-value" id="distValRoute" style="color:var(--accent);">cross-segment</span></div>';
        }
        if (data.segNames && data.segNames.length > 0) {
            html += '<div style="margin-top:6px;border-top:1px solid #eee;padding-top:6px;">';
            html += '<div class="dist-row"><span class="dist-label" style="font-weight:600;">Segments (' + data.segNames.length + '):</span></div>';
            html += '<div style="max-height:120px;overflow-y:auto;">';
            data.segNames.forEach((name, i) => {
                const d = data.segDistances ? data.segDistances[i] : 0;
                html += '<div class="dist-row" style="font-size:10px;padding-left:8px;">';
                html += '<span class="dist-label" style="color:var(--text-muted);">' + (i+1) + '. ' + name + '</span>';
                html += '<span class="dist-value" style="font-size:10px;">' + formatDistance(d) + '</span>';
                html += '</div>';
            });
            html += '</div></div>';
        }
        html += '</div>';
    }
    dc.innerHTML = html;
    dp.classList.add('show');

    // Attach toggle event listeners AFTER innerHTML is set
    if (data.hasBestEst) {
        const sw = document.getElementById('distModeSwitch');
        const lblStrict = document.getElementById('distLabelStrict');
        const lblEst = document.getElementById('distLabelEst');
        if (sw) {
            sw.addEventListener('change', function() {
                toggleDistMode(!this.checked);
            });
        }
        if (lblStrict) {
            lblStrict.addEventListener('click', function() {
                if (sw) sw.checked = false;
                toggleDistMode(true);
            });
        }
        if (lblEst) {
            lblEst.addEventListener('click', function() {
                if (sw) sw.checked = true;
                toggleDistMode(false);
            });
        }
    }
}

function _updateDistValues() {
    const data = _distPanelData;
    if (!data) return;
    const isStrict = _distModeStrict;
    const geo = isStrict ? data.geo : data.bestEstDist;
    const est = geo * (1 + data.slack / 100);
    const modeColor = isStrict ? 'var(--accent)' : '#e67e22';

    const elGeo = document.getElementById('distValGeo');
    const elEst = document.getElementById('distValEst');
    const elRoute = document.getElementById('distValRoute');
    const elHint = document.getElementById('distModeHint');
    const lblStrict = document.getElementById('distLabelStrict');
    const lblEst = document.getElementById('distLabelEst');
    const sw = document.getElementById('distModeSwitch');

    if (elGeo) { elGeo.textContent = formatDistance(geo); elGeo.style.color = modeColor; }
    if (elEst) { elEst.textContent = formatDistance(est); elEst.style.color = modeColor; }
    if (elRoute) { elRoute.style.color = modeColor; }
    if (elHint) {
        elHint.innerHTML = isStrict
            ? '&#x26A0;&#xFE0F; Strict mode routes through all cable segments including loops &#x2014; actual path may be shorter'
            : '&#x2139;&#xFE0F; Best Estimate uses straight-line distance for gaps instead of routing through cable loops';
    }
    if (lblStrict) { lblStrict.classList.toggle('active', isStrict); }
    if (lblEst) { lblEst.classList.toggle('active', !isStrict); }
    if (sw) { sw.checked = !isStrict; }
}

window.closeDistancePanel = function() {
    const dp = document.getElementById('distancePanel');
    dp.classList.remove('show', 'minimized');
    dp.style.position = 'absolute';
    dp.style.left = '50%'; dp.style.top = ''; dp.style.bottom = '20px';
    dp.style.transform = 'translateX(-50%)';
    dp.style.height = ''; dp.style.width = '';
    clearMeasureMarkers();
};

window.toggleDistMinimize = function() {
    const dp = document.getElementById('distancePanel');
    const btn = document.getElementById('distMinBtn');
    dp.classList.toggle('minimized');
    btn.innerHTML = dp.classList.contains('minimized') ? '&#9650;' : '&#9660;';
};

// Draggable distance panel
(function() {
    let dragging = false, offsetX = 0, offsetY = 0;
    const getPanel = () => document.getElementById('distancePanel');
    document.addEventListener('mousedown', function(e) {
        const handle = e.target.closest('#distDragHandle');
        if (!handle) return;
        if (e.target.tagName === 'BUTTON') return;
        const dp = getPanel();
        const rect = dp.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        // Immediately switch to fixed positioning at current visual location
        dp.style.position = 'fixed';
        dp.style.left = rect.left + 'px';
        dp.style.top = rect.top + 'px';
        dp.style.bottom = 'auto';
        dp.style.transform = 'none';
        dragging = true;
        e.preventDefault();
    });
    document.addEventListener('mousemove', function(e) {
        if (!dragging) return;
        const dp = getPanel();
        dp.style.left = (e.clientX - offsetX) + 'px';
        dp.style.top = (e.clientY - offsetY) + 'px';
    });
    document.addEventListener('mouseup', function() { dragging = false; });
})();

// ═══════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════
// JOIN / MERGE SEGMENTS INTO SINGLE LINE
// ═══════════════════════════════════════════════════════════

// Context menu entry point
window.ctxJoinSegments = function() {
    // If right-clicked on a folder, select all its line layers first
    if (ctxTargetFolderId) {
        const folder = projectData.folders.find(f => f.id === ctxTargetFolderId);
        if (folder) {
            selectedLayerIds.clear();
            function collectLines(fId) {
                const f = projectData.folders.find(ff => ff.id === fId);
                if (!f) return;
                f.items.forEach(id => {
                    const l = projectData.layers[id];
                    if (l && l.type === 'line' && l.visible) selectedLayerIds.add(id);
                });
                projectData.folders.filter(ff => ff.parentId === fId).forEach(sf => collectLines(sf.id));
            }
            collectLines(ctxTargetFolderId);
        }
    } else if (ctxTargetId) {
        // Single layer right-click — not enough to join
        if (selectedLayerIds.size < 2) {
            toast('Select 2 or more line segments to join', 'info');
            return;
        }
    }
    joinSelectedSegments();
    ctxTargetFolderId = null;
};

// Main join function — works with selectedLayerIds
window.joinSelectedSegments = function() {
    pushUndo();
    // Collect all selected line layers
    const lines = [];
    for (const id of selectedLayerIds) {
        const l = projectData.layers[id];
        if (l && l.type === 'line' && l.coords && l.coords.length >= 2) {
            lines.push({ id, name: l.name, coords: l.coords.slice() });
        }
    }
    if (lines.length < 2) {
        toast('Select at least 2 line segments to join', 'info');
        return;
    }

    toast('Joining ' + lines.length + ' segments...', 'info');

    // ─── Build chain by nearest-endpoint greedy algorithm (optimized with spatial grid) ───
    const DEG2R = Math.PI / 180;
    const midLat = lines.reduce((s, l) => s + l.coords[0][0], 0) / lines.length * DEG2R;
    const cosLat = Math.cos(midLat);
    function qDist(a, b) {
        const dl = a[0] - b[0], dn = (a[1] - b[1]) * cosLat;
        return dl*dl + dn*dn;
    }

    // Build spatial grid of segment endpoints for O(1) neighbor lookup
    const allEndpoints = []; // {segIdx, end:'s'|'e', coord}
    for (let i = 0; i < lines.length; i++) {
        allEndpoints.push({ segIdx: i, end: 's', coord: lines[i].coords[0] });
        allEndpoints.push({ segIdx: i, end: 'e', coord: lines[i].coords[lines[i].coords.length - 1] });
    }
    const JG_RES = 0.02; // ~2km grid cells
    const joinGrid = new Map();
    for (const ep of allEndpoints) {
        const key = Math.floor(ep.coord[1] / JG_RES) + ',' + Math.floor(ep.coord[0] / JG_RES);
        if (!joinGrid.has(key)) joinGrid.set(key, []);
        joinGrid.get(key).push(ep);
    }
    function findNearestEndpoint(coord, excludeSet) {
        const gx0 = Math.floor(coord[1] / JG_RES), gy0 = Math.floor(coord[0] / JG_RES);
        let bestEp = null, bestDist = Infinity;
        for (let r = 0; r <= 50; r++) {
            for (let dx = -r; dx <= r; dx++) {
                for (let dy = -r; dy <= r; dy++) {
                    if (r > 0 && Math.abs(dx) < r && Math.abs(dy) < r) continue;
                    const cell = joinGrid.get((gx0 + dx) + ',' + (gy0 + dy));
                    if (!cell) continue;
                    for (const ep of cell) {
                        if (excludeSet.has(ep.segIdx)) continue;
                        const d = qDist(coord, ep.coord);
                        if (d < bestDist) { bestDist = d; bestEp = ep; }
                    }
                }
            }
            if (bestEp) break; // found in this shell
        }
        // Fallback brute force if grid missed (very sparse)
        if (!bestEp) {
            for (const ep of allEndpoints) {
                if (excludeSet.has(ep.segIdx)) continue;
                const d = qDist(coord, ep.coord);
                if (d < bestDist) { bestDist = d; bestEp = ep; }
            }
        }
        return bestEp;
    }

    // Find chain start: endpoint with the greatest minimum distance to any other segment
    let bestStartIdx = 0, bestStartEnd = 's', bestMaxMinDist = 0;
    for (const ep of allEndpoints) {
        const nearest = findNearestEndpoint(ep.coord, new Set([ep.segIdx]));
        if (nearest) {
            const d = qDist(ep.coord, nearest.coord);
            if (d > bestMaxMinDist) {
                bestMaxMinDist = d;
                bestStartIdx = ep.segIdx;
                bestStartEnd = ep.end;
            }
        }
    }

    // Build ordered chain using spatial lookup
    const used = new Set();
    const chain = [];
    let currentCoords = bestStartEnd === 'e' ? lines[bestStartIdx].coords.slice().reverse() : lines[bestStartIdx].coords.slice();
    chain.push({ coords: currentCoords, name: lines[bestStartIdx].name });
    used.add(bestStartIdx);

    while (used.size < lines.length) {
        const tip = currentCoords[currentCoords.length - 1];
        const nearest = findNearestEndpoint(tip, used);
        if (!nearest) break;
        used.add(nearest.segIdx);
        const seg = lines[nearest.segIdx];
        currentCoords = nearest.end === 'e' ? seg.coords.slice().reverse() : seg.coords.slice();
        chain.push({ coords: currentCoords, name: seg.name });
    }

    // Concatenate all coords into one polyline
    let mergedCoords = [];
    for (const seg of chain) {
        // Skip first point if it's very close to previous last point (avoid duplicates)
        if (mergedCoords.length > 0) {
            const last = mergedCoords[mergedCoords.length - 1];
            const first = seg.coords[0];
            if (qDist(last, first) < 0.0000001) { // ~10m threshold
                mergedCoords = mergedCoords.concat(seg.coords.slice(1));
            } else {
                mergedCoords = mergedCoords.concat(seg.coords);
            }
        } else {
            mergedCoords = seg.coords.slice();
        }
    }

    // Create the merged layer
    const mergedName = 'Joined (' + lines.length + ' segments)';
    const firstLayer = projectData.layers[lines[0].id];
    const color = firstLayer ? firstLayer.color : '#0055ff';
    const width = firstLayer ? firstLayer.width : 3;
    const newId = 'layer_' + Date.now() + '_joined';

    // Find the folder of the first selected layer
    let targetFolderId = projectData.folders[0].id;
    for (const f of projectData.folders) {
        if (f.items.includes(lines[0].id)) { targetFolderId = f.id; break; }
    }

    // Add the new layer
    projectData.layers[newId] = {
        id: newId, name: mergedName, type: 'line',
        coords: mergedCoords, color, width, opacity: 1, visible: true
    };
    const folder = projectData.folders.find(f => f.id === targetFolderId);
    if (folder) folder.items.push(newId);

    // Render the new line on map
    const polyline = L.polyline(mergedCoords, { color, weight: width, opacity: 1 }).addTo(map);
    polyline._layerId = newId;
    polyline.on('click', function(e) { L.DomEvent.stopPropagation(e); selectLayer(newId); });
    mapLayers[newId] = polyline;

    // Clear selection
    selectedLayerIds.clear();
    selectLayer(newId);
    renderLayerTree();
    renderVertexDots();

    toast('Joined ' + lines.length + ' segments into "' + mergedName + '" (' + mergedCoords.length + ' vertices)', 'success');
};

// TOPOLOGY DIAGRAM
// ═══════════════════════════════════════════════════════════
let topoState = { nodes: [], edges: [], zoom: 1, panX: 0, panY: 0, dragging: null, hovered: null };

window.showTopologyDiagram = function() {
    const allLines = Object.values(projectData.layers).filter(l => l.visible && l.type === 'line' && l.coords.length >= 2);
    if (allLines.length < 1) { toast('No visible line layers to diagram', 'error'); return; }

    const t0 = performance.now();

    // ═══════════════════════════════════════════════════════════
    // SIMPLIFIED TOPOLOGY — 4-pass reduction
    //   1. Cluster endpoints into junctions, walk chains (degree-2 merge)
    //   2. Spatially cluster junctions into hubs
    //   3. Merge parallel edges, prune short stubs
    //   4. Degree-2 elimination on hub graph (second pass)
    // ═══════════════════════════════════════════════════════════

    const cosLat = Math.cos((allLines.reduce((s,l) => s + l.coords[0][0], 0) / allLines.length) * Math.PI / 180);
    function fastKm(a, b) {
        const dlat = a[0] - b[0], dlng = (a[1] - b[1]) * cosLat;
        return Math.sqrt(dlat * dlat + dlng * dlng) * 111.32;
    }
    function segLen(layer) {
        let d = 0;
        for (let i = 0; i < layer.coords.length - 1; i++) d += fastKm(layer.coords[i], layer.coords[i+1]);
        return d;
    }

    // ─── PASS 1: Cluster endpoints, walk chains ───
    const SNAP = 0.02; // ~2km snap (handles GPS/digitization offsets)
    const epGrid = new Map();
    const allEps = [];
    for (let li = 0; li < allLines.length; li++) {
        const l = allLines[li];
        for (const [end, coord] of [['s', l.coords[0]], ['e', l.coords[l.coords.length - 1]]]) {
            const ep = { li, end, coord, jid: -1 };
            allEps.push(ep);
            const gk = Math.floor(coord[0] / SNAP) + ',' + Math.floor(coord[1] / SNAP);
            if (!epGrid.has(gk)) epGrid.set(gk, []);
            epGrid.get(gk).push(ep);
        }
    }

    let nextJ = 0;
    for (const ep of allEps) {
        if (ep.jid >= 0) continue;
        const queue = [ep]; ep.jid = nextJ;
        while (queue.length) {
            const cur = queue.shift();
            const gx = Math.floor(cur.coord[0] / SNAP), gy = Math.floor(cur.coord[1] / SNAP);
            for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) {
                const cell = epGrid.get((gx+dx)+','+(gy+dy));
                if (!cell) continue;
                for (const o of cell) {
                    if (o.jid >= 0) continue;
                    if (Math.abs(cur.coord[0]-o.coord[0]) < SNAP && Math.abs(cur.coord[1]-o.coord[1]) < SNAP) {
                        o.jid = nextJ; queue.push(o);
                    }
                }
            }
        }
        nextJ++;
    }

    const juncs = new Map();
    for (const ep of allEps) {
        if (!juncs.has(ep.jid)) juncs.set(ep.jid, { coord: ep.coord, segs: new Set() });
        juncs.get(ep.jid).segs.add(ep.li);
    }
    for (const [,j] of juncs) j.degree = j.segs.size;

    const segJ = [];
    for (let li = 0; li < allLines.length; li++) {
        segJ.push({ s: allEps[li*2].jid, e: allEps[li*2+1].jid });
    }

    const usedSeg = new Set();
    const simEdges = [];
    for (let li = 0; li < allLines.length; li++) {
        if (usedSeg.has(li)) continue;
        const sj = segJ[li].s, ej = segJ[li].e;
        if (sj === ej) { usedSeg.add(li); continue; }
        usedSeg.add(li);
        let dist = segLen(allLines[li]), segs = 1;
        let chainStart = sj, chainEnd = ej;

        let cur = ej;
        while (juncs.has(cur) && juncs.get(cur).degree === 2) {
            let nxt = -1;
            for (const s of juncs.get(cur).segs) { if (!usedSeg.has(s)) { nxt = s; break; } }
            if (nxt < 0) break;
            usedSeg.add(nxt); dist += segLen(allLines[nxt]); segs++;
            cur = segJ[nxt].s === cur ? segJ[nxt].e : segJ[nxt].s;
        }
        chainEnd = cur;

        cur = sj;
        while (juncs.has(cur) && juncs.get(cur).degree === 2) {
            let nxt = -1;
            for (const s of juncs.get(cur).segs) { if (!usedSeg.has(s)) { nxt = s; break; } }
            if (nxt < 0) break;
            usedSeg.add(nxt); dist += segLen(allLines[nxt]); segs++;
            cur = segJ[nxt].s === cur ? segJ[nxt].e : segJ[nxt].s;
        }
        chainStart = cur;

        simEdges.push({ from: chainStart, to: chainEnd, dist, segCount: segs, color: allLines[li].color || '#0096D6' });
    }

    // ─── PASS 2: Spatially cluster junctions into hubs ───
    const activeJids = new Set();
    for (const e of simEdges) { activeJids.add(e.from); activeJids.add(e.to); }
    const activeList = Array.from(activeJids).map(jid => ({ jid, coord: juncs.get(jid).coord, degree: juncs.get(jid).degree }));

    const aLats = activeList.map(a => a.coord[0]), aLngs = activeList.map(a => a.coord[1]);
    const geoSpan = Math.max((Math.max(...aLats)-Math.min(...aLats))*111, (Math.max(...aLngs)-Math.min(...aLngs))*111*cosLat) || 1;
    const CLUSTER_R = Math.max(2, Math.min(20, geoSpan / 15));

    activeList.sort((a,b) => b.degree - a.degree);
    const hubOf = new Map();
    const hubs = [];
    for (const item of activeList) {
        if (hubOf.has(item.jid)) continue;
        const hub = { id: hubs.length, coord: item.coord, jids: [item.jid], totalDegree: item.degree };
        hubOf.set(item.jid, hub.id);
        for (const other of activeList) {
            if (hubOf.has(other.jid)) continue;
            if (fastKm(item.coord, other.coord) < CLUSTER_R) {
                hub.jids.push(other.jid);
                hub.totalDegree += other.degree;
                hubOf.set(other.jid, hub.id);
            }
        }
        hubs.push(hub);
    }

    // ─── PASS 3: Remap to hubs, merge parallel edges ───
    let hubEdges = [];
    for (const e of simEdges) {
        const hf = hubOf.get(e.from), ht = hubOf.get(e.to);
        if (hf === undefined || ht === undefined || hf === ht) continue;
        hubEdges.push({ from: hf, to: ht, dist: e.dist, segCount: e.segCount, color: e.color });
    }

    const edgeKey = (a,b) => Math.min(a,b) + ':' + Math.max(a,b);
    let merged = new Map();
    for (const e of hubEdges) {
        const k = edgeKey(e.from, e.to);
        if (merged.has(k)) {
            const m = merged.get(k); m.dist += e.dist; m.segCount += e.segCount; m.count++;
        } else {
            merged.set(k, { from: e.from, to: e.to, dist: e.dist, segCount: e.segCount, color: e.color, count: 1 });
        }
    }

    // Prune short stubs
    let hubDeg = new Map();
    for (const [,e] of merged) { hubDeg.set(e.from, (hubDeg.get(e.from)||0)+1); hubDeg.set(e.to, (hubDeg.get(e.to)||0)+1); }
    const STUB_MIN = Math.max(2, geoSpan * 0.01);
    const toRemove = new Set();
    for (const [k, e] of merged) {
        if (((hubDeg.get(e.from)||0) === 1 || (hubDeg.get(e.to)||0) === 1) && e.dist < STUB_MIN) toRemove.add(k);
    }
    for (const k of toRemove) merged.delete(k);

    // ─── PASS 4: Second-pass degree-2 elimination on hub graph ───
    // Rebuild adjacency from merged edges
    let adj = new Map(); // hubId -> [{otherHub, edgeKey}]
    for (const [k, e] of merged) {
        if (!adj.has(e.from)) adj.set(e.from, []);
        if (!adj.has(e.to)) adj.set(e.to, []);
        adj.get(e.from).push({ other: e.to, key: k, edge: e });
        adj.get(e.to).push({ other: e.from, key: k, edge: e });
    }

    // Iteratively merge through degree-2 hubs
    let changed = true;
    while (changed) {
        changed = false;
        for (const [hubId, neighbors] of adj) {
            if (neighbors.length !== 2) continue;
            // This hub has exactly 2 connections — merge through it
            const n0 = neighbors[0], n1 = neighbors[1];
            const newDist = n0.edge.dist + n1.edge.dist;
            const newSegCount = n0.edge.segCount + n1.edge.segCount;
            const newCount = Math.max(n0.edge.count, n1.edge.count);
            const newColor = n0.edge.segCount >= n1.edge.segCount ? n0.edge.color : n1.edge.color;

            // Remove old edges
            merged.delete(n0.key);
            merged.delete(n1.key);

            // Add new merged edge
            const newKey = edgeKey(n0.other, n1.other);
            if (merged.has(newKey)) {
                // Parallel path to existing edge — merge
                const existing = merged.get(newKey);
                existing.dist += newDist;
                existing.segCount += newSegCount;
                existing.count++;
            } else {
                merged.set(newKey, { from: Math.min(n0.other, n1.other), to: Math.max(n0.other, n1.other), dist: newDist, segCount: newSegCount, color: newColor, count: newCount });
            }

            // Remove this hub from adjacency
            adj.delete(hubId);
            // Update neighbors' adjacency
            for (const nb of [n0, n1]) {
                const nbAdj = adj.get(nb.other);
                if (nbAdj) {
                    // Remove reference to deleted hub, add reference to new edge
                    const filtered = nbAdj.filter(x => x.other !== hubId);
                    const otherEnd = nb === n0 ? n1.other : n0.other;
                    const newEdge = merged.get(newKey);
                    if (newEdge) filtered.push({ other: otherEnd, key: newKey, edge: newEdge });
                    adj.set(nb.other, filtered);
                }
            }

            changed = true;
            break; // restart iteration since adjacency changed
        }
    }

    // ─── Build final output ───
    const finalHubs = new Set();
    for (const [,e] of merged) { finalHubs.add(e.from); finalHubs.add(e.to); }

    hubDeg = new Map();
    for (const [,e] of merged) { hubDeg.set(e.from, (hubDeg.get(e.from)||0)+1); hubDeg.set(e.to, (hubDeg.get(e.to)||0)+1); }

    const tNodes = [];
    const hubToNode = new Map();
    for (const hid of finalHubs) {
        const hub = hubs[hid];
        const deg = hubDeg.get(hid) || 1;
        const jCount = hub.jids.length;
        const nodeColor = deg === 1 ? '#10b981' : deg === 2 ? '#0096D6' : '#ef4444';
        const label = (deg === 1 ? 'Terminal' : deg === 2 ? 'Waypoint' : 'Branch\u00d7' + deg)
            + (jCount > 1 ? ' (' + jCount + ' junctions)' : '');
        hubToNode.set(hid, tNodes.length);
        tNodes.push({ id: 'h' + hid, label, x: 0, y: 0, geoLat: hub.coord[0], geoLng: hub.coord[1], color: nodeColor, layerId: null });
    }

    const tEdges = [];
    for (const [, e] of merged) {
        const fi = hubToNode.get(e.from), ti = hubToNode.get(e.to);
        if (fi === undefined || ti === undefined) continue;
        const lbl = e.dist.toFixed(1) + 'km (' + e.segCount + ' seg)'
            + (e.count > 1 ? ' [' + e.count + ' paths]' : '');
        tEdges.push({ from: fi, to: ti, type: 'internal', dist: e.dist, segCount: e.segCount, pathCount: e.count, color: e.color, label: lbl });
    }

    // ─── PASS 5: Bridge disconnected components (islands) ───
    // If hub-level graph has multiple components, connect them with dashed gap edges
    const ufH = new Int32Array(tNodes.length);
    for (let i = 0; i < tNodes.length; i++) ufH[i] = i;
    function ufHFind(x) { while (ufH[x] !== x) { ufH[x] = ufH[ufH[x]]; x = ufH[x]; } return x; }
    function ufHUnion(a, b) { a = ufHFind(a); b = ufHFind(b); if (a === b) return false; ufH[b] = a; return true; }
    for (const e of tEdges) ufHUnion(e.from, e.to);

    let numComp = new Set(Array.from({length: tNodes.length}, (_, i) => ufHFind(i))).size;
    if (numComp > 1) {
        // Find shortest gap between each pair of components using hub coords
        const compNodes = new Map();
        for (let i = 0; i < tNodes.length; i++) {
            const r = ufHFind(i);
            if (!compNodes.has(r)) compNodes.set(r, []);
            compNodes.get(r).push(i);
        }
        const compRoots = Array.from(compNodes.keys());
        const bridges = [];
        for (let ci = 0; ci < compRoots.length; ci++) {
            for (let cj = ci + 1; cj < compRoots.length; cj++) {
                let bestD = Infinity, bestI = -1, bestJ = -1;
                for (const a of compNodes.get(compRoots[ci])) {
                    for (const b of compNodes.get(compRoots[cj])) {
                        const d = fastKm([tNodes[a].geoLat, tNodes[a].geoLng], [tNodes[b].geoLat, tNodes[b].geoLng]);
                        if (d < bestD) { bestD = d; bestI = a; bestJ = b; }
                    }
                }
                if (bestI >= 0) bridges.push({ i: bestI, j: bestJ, d: bestD });
            }
        }
        bridges.sort((a, b) => a.d - b.d);
        let bridgeCount = 0;
        for (const br of bridges) {
            if (ufHFind(br.i) !== ufHFind(br.j)) {
                tEdges.push({
                    from: br.i, to: br.j, type: 'gap',
                    dist: br.d, segCount: 0, pathCount: 0,
                    color: '#e67e22', label: 'bridge ' + br.d.toFixed(1) + 'km'
                });
                ufHUnion(br.i, br.j);
                bridgeCount++;
            }
        }
        if (bridgeCount > 0) numComp = new Set(Array.from({length: tNodes.length}, (_, i) => ufHFind(i))).size;
    }

    const elapsed = (performance.now() - t0).toFixed(0);
    const compNote = numComp > 1 ? ' [' + numComp + ' islands]' : '';
    toast('Topology: ' + allLines.length + ' seg \u2192 ' + tNodes.length + ' nodes, ' + tEdges.length + ' edges' + compNote + ' (' + elapsed + 'ms)', 'success');

    if (tNodes.length === 0) { toast('No topology nodes after simplification', 'info'); return; }

    const nLngs = tNodes.map(n => n.geoLng), nLats = tNodes.map(n => n.geoLat);
    const minLng = Math.min(...nLngs), maxLng = Math.max(...nLngs);
    const minLat = Math.min(...nLats), maxLat = Math.max(...nLats);
    const lngRange = maxLng - minLng || 1, latRange = maxLat - minLat || 1;

    document.getElementById('topoModal').classList.add('show');

    requestAnimationFrame(() => {
        const canvas = document.getElementById('topoCanvas');
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * window.devicePixelRatio;
        canvas.height = rect.height * window.devicePixelRatio;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';

        const padding = 80;
        const w = rect.width - padding * 2, h = rect.height - padding * 2;
        tNodes.forEach(n => {
            n.x = padding + ((n.geoLng - minLng) / lngRange) * w;
            n.y = padding + ((maxLat - n.geoLat) / latRange) * h;
        });

        topoState = { nodes: tNodes, edges: tEdges, zoom: 1, panX: 0, panY: 0, dragging: null, hovered: null, canvasW: rect.width, canvasH: rect.height };
        renderTopology();
        setupTopoInteraction();
    });
};


function renderTopology() {
    const canvas = document.getElementById('topoCanvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio;
    const { nodes, edges, zoom, panX, panY, hovered } = topoState;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);

    // Draw edges
    edges.forEach((e, idx) => {
        const from = nodes[e.from], to = nodes[e.to];
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);

        if (e.type === 'gap') {
            ctx.strokeStyle = hovered && hovered.type === 'edge' && hovered.idx === idx ? '#f59e0b' : (e.color || '#ccc');
            ctx.lineWidth = hovered && hovered.type === 'edge' && hovered.idx === idx ? 2 : 1;
            ctx.setLineDash([4, 4]);
        } else {
            ctx.strokeStyle = hovered && hovered.type === 'edge' && hovered.idx === idx ? '#f59e0b' : e.color;
            const pcMul = e.pathCount > 1 ? 1.3 : 1;
            const baseWidth = (e.segCount ? Math.min(6, 1.5 + Math.log2(e.segCount)) : 2) * pcMul;
            ctx.lineWidth = hovered && hovered.type === 'edge' && hovered.idx === idx ? baseWidth + 1.5 : baseWidth;
            ctx.setLineDash([]);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // Distance label on edges when zoomed in
        if ((e.type === 'internal' || e.type === 'gap') && zoom > 0.7) {
            const mx = (from.x + to.x) / 2, my = (from.y + to.y) / 2;
            const distLabel = (e.dist < 1 ? (e.dist * 1000).toFixed(0) + 'm' : e.dist.toFixed(1) + 'km')
                + (e.segCount > 1 ? ' (' + e.segCount + ' seg)' : '');
            ctx.font = '9px sans-serif';
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.textAlign = 'center';
            ctx.fillText(distLabel, mx, my - 4);
        }
    });

    // Draw nodes
    const nodeRadius = Math.max(3, 5 / Math.sqrt(zoom));
    nodes.forEach((n, idx) => {
        const isHovered = hovered && hovered.type === 'node' && hovered.idx === idx;
        ctx.beginPath();
        ctx.arc(n.x, n.y, isHovered ? nodeRadius + 3 : nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = isHovered ? '#f59e0b' : n.color;
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Label on hover or if zoomed in
        if (isHovered || zoom > 2) {
            ctx.font = (isHovered ? 'bold ' : '') + '10px sans-serif';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.fillText(n.label, n.x + nodeRadius + 4, n.y + 3);
        }
    });

    ctx.restore();
}

function setupTopoInteraction() {
    const canvas = document.getElementById('topoCanvas');
    let isPanning = false, lastX = 0, lastY = 0;

    canvas.onmousedown = function(e) {
        isPanning = true;
        lastX = e.clientX; lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    };
    canvas.onmousemove = function(e) {
        if (isPanning) {
            topoState.panX += e.clientX - lastX;
            topoState.panY += e.clientY - lastY;
            lastX = e.clientX; lastY = e.clientY;
            renderTopology();
            return;
        }
        // Hit testing for hover
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left - topoState.panX) / topoState.zoom;
        const my = (e.clientY - rect.top - topoState.panY) / topoState.zoom;
        let found = null;

        // Check nodes
        topoState.nodes.forEach((n, idx) => {
            const dx = n.x - mx, dy = n.y - my;
            if (dx * dx + dy * dy < 100) found = { type: 'node', idx };
        });

        // Check edges if no node hit
        if (!found) {
            topoState.edges.forEach((e, idx) => {
                const from = topoState.nodes[e.from], to = topoState.nodes[e.to];
                // Point-to-line distance
                const dx = to.x - from.x, dy = to.y - from.y;
                const len2 = dx * dx + dy * dy;
                if (len2 === 0) return;
                let t = ((mx - from.x) * dx + (my - from.y) * dy) / len2;
                t = Math.max(0, Math.min(1, t));
                const px = from.x + t * dx, py = from.y + t * dy;
                const d2 = (mx - px) * (mx - px) + (my - py) * (my - py);
                if (d2 < 30) found = { type: 'edge', idx };
            });
        }

        if (JSON.stringify(found) !== JSON.stringify(topoState.hovered)) {
            topoState.hovered = found;
            renderTopology();
            // Update info panel
            const info = document.getElementById('topoInfo');
            if (found && found.type === 'node') {
                const n = topoState.nodes[found.idx];
                info.innerHTML = '<b>' + n.label + '</b><br>Lat: ' + n.geoLat.toFixed(4) + '<br>Lng: ' + n.geoLng.toFixed(4);
            } else if (found && found.type === 'edge') {
                const e = topoState.edges[found.idx];
                const distStr = e.dist < 1 ? (e.dist * 1000).toFixed(0) + ' m' : e.dist.toFixed(2) + ' km';
                info.innerHTML = '<b>' + e.label + '</b><br>Type: ' + e.type + '<br>Distance: ' + distStr;
            } else {
                info.innerHTML = 'Hover over a node or edge for details';
            }
        }
        canvas.style.cursor = found ? 'pointer' : 'grab';
    };
    canvas.onmouseup = function() { isPanning = false; canvas.style.cursor = 'grab'; };
    canvas.onmouseleave = function() { isPanning = false; canvas.style.cursor = 'grab'; };
    canvas.onwheel = function(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const oldZoom = topoState.zoom;
        const factor = e.deltaY < 0 ? 1.15 : 0.87;
        topoState.zoom = Math.max(0.1, Math.min(20, topoState.zoom * factor));
        // Zoom toward cursor
        topoState.panX = mx - (mx - topoState.panX) * (topoState.zoom / oldZoom);
        topoState.panY = my - (my - topoState.panY) * (topoState.zoom / oldZoom);
        renderTopology();
    };
    canvas.style.cursor = 'grab';
}

window.closeTopologyDiagram = function() {
    document.getElementById('topoModal').classList.remove('show');
};

window.topoZoomIn = function() {
    topoState.zoom *= 1.3;
    topoState.panX = topoState.canvasW / 2 - (topoState.canvasW / 2 - topoState.panX) * 1.3;
    topoState.panY = topoState.canvasH / 2 - (topoState.canvasH / 2 - topoState.panY) * 1.3;
    renderTopology();
};
window.topoZoomOut = function() {
    topoState.zoom *= 0.77;
    topoState.panX = topoState.canvasW / 2 - (topoState.canvasW / 2 - topoState.panX) * 0.77;
    topoState.panY = topoState.canvasH / 2 - (topoState.canvasH / 2 - topoState.panY) * 0.77;
    renderTopology();
};
window.topoResetView = function() {
    topoState.zoom = 1; topoState.panX = 0; topoState.panY = 0;
    renderTopology();
};

window.togglePropertiesPanel = function() {
    const rp = document.getElementById('rightPanel');
    const btn = document.getElementById('btnToggleProps');
    rp.classList.toggle('hidden');
    btn.classList.toggle('active', !rp.classList.contains('hidden'));
    // Trigger Leaflet map resize after panel animation
    setTimeout(() => { if (map) map.invalidateSize(); }, 250);
};


// Shared measure click handler - called from both map click and polyline click
// Cross-segment measurement data
let measureClickData = []; // [{layerId, vertexIdx, coord}]

function handleMeasureClick(latlng, knownIdx, knownLayerId) {
    // Find nearest vertex across ALL visible line layers
    let bestLayerId = null, bestIdx = 0, bestDist = Infinity, bestCoord = null;

    if (knownIdx !== undefined && knownLayerId) {
        // Direct vertex dot click — use exact values
        bestLayerId = knownLayerId;
        bestIdx = knownIdx;
        const l = projectData.layers[knownLayerId];
        bestCoord = l ? l.coords[knownIdx] : null;
    } else {
        // Find nearest vertex by pixel distance across all visible lines
        const clickPt = map.latLngToContainerPoint(latlng);
        Object.values(projectData.layers).forEach(layer => {
            if (!layer.visible || layer.type !== 'line' || layer.coords.length < 1) return;
            layer.coords.forEach((c, i) => {
                const pt = map.latLngToContainerPoint(c);
                const dx = clickPt.x - pt.x, dy = clickPt.y - pt.y;
                const d = dx * dx + dy * dy;
                if (d < bestDist) { bestDist = d; bestLayerId = layer.id; bestIdx = i; bestCoord = c; }
            });
        });
    }

    if (!bestLayerId || !bestCoord) { toast('No line found nearby', 'error'); return; }

    if (measureClickData.length === 0) {
        // FIRST CLICK: A-End (green)
        measureClickData.push({ layerId: bestLayerId, vertexIdx: bestIdx, coord: bestCoord });
        const icon = L.divIcon({ className: 'measure-marker-a', iconSize: [14,14], iconAnchor: [7,7] });
        const m = L.marker(bestCoord, { icon, zIndexOffset: 3000 }).addTo(map);
        measureMarkers.push(m);
        const lName = projectData.layers[bestLayerId] ? projectData.layers[bestLayerId].name : '';
        document.getElementById('editBanner').textContent = '📏 MEASURE — 🟢 A-End set — now click 🔴 B-End on any line';
        toast('🟢 A-End set — now click B-End on any line', 'info');
    } else if (measureClickData.length === 1) {
        // SECOND CLICK: B-End (red)
        measureClickData.push({ layerId: bestLayerId, vertexIdx: bestIdx, coord: bestCoord });
        const icon = L.divIcon({ className: 'measure-marker-b', iconSize: [14,14], iconAnchor: [7,7] });
        const m = L.marker(bestCoord, { icon, zIndexOffset: 3000 }).addTo(map);
        measureMarkers.push(m);

        // Calculate cross-segment distance
        const a = measureClickData[0], b = measureClickData[1];
        console.log('Measure: A layer=' + a.layerId + ' vtx=' + a.vertexIdx + ', B layer=' + b.layerId + ' vtx=' + b.vertexIdx);
        const result = calcCrossSegmentDistance(a, b);
        console.log('Measure result: segments=' + result.segments + ', usedLayers=' + (result.usedLayerIds||[]).length + ', dist=' + result.distance.toFixed(2) + 'km');
        if (result.segNames) console.log('Segments:', result.segNames.join(' → '));

        // Store result globally for mode toggling
        window._lastMeasureResult = result;

        // Draw highlight polyline (strict cable path by default)
        if (result.pathCoords.length > 1) {
            measureLineLayer = L.polyline(result.pathCoords, { color: '#f59e0b', weight: 6, opacity: 0.85, dashArray: '10,6' }).addTo(map);
        }

        // Dim all non-used layers and highlight used ones
        if (result.usedLayerIds && result.usedLayerIds.length > 0) {
            dimNonMeasuredLayers(result.usedLayerIds);
        }

        const est = result.distance * (1 + fiberSlackPct / 100);
        const hasBestEst = result.gapCount > 0 && result.bestEstDist > 0;
        showDistancePanel({
            title: 'A-End to B-End' + (result.segments > 1 ? ' (' + result.segments + ' segments)' : ''),
            geo: result.distance, est, slack: fiberSlackPct,
            aEnd: a.vertexIdx, bEnd: b.vertexIdx,
            crossSegment: result.segments > 1,
            segNames: result.segNames || [],
            segDistances: result.segDistances || [],
            hasBestEst,
            cableDist: result.cableDist || 0,
            gapDist: result.gapDist || 0,
            gapCount: result.gapCount || 0,
            bestEstDist: result.bestEstDist || 0
        });

        // Reset measure mode
        measureMode = false;
        document.getElementById('btnMeasurePath').classList.remove('active');
        if (!editMode) document.getElementById('editBanner').classList.remove('show');
        const lc = document.querySelector('.leaflet-container');
        if (lc) lc.classList.remove('measure-cursor');
        map.doubleClickZoom.enable();
        renderVertexDots();
        measureClickData = [];
        measureClicks = [];
    } else {
        measureClickData = [];
        measureClicks = [];
        handleMeasureClick(latlng, knownIdx, knownLayerId);
    }
}

// Build topology graph and find shortest path using Dijkstra
// Topology: each layer has 2 nodes (start/end endpoints) connected by internal edge.
// Layers connect via gap edges between nearest endpoint nodes.
// Every node must connect to at least one other layer's node — no orphans.
function calcCrossSegmentDistance(a, b) {
    const layerA = projectData.layers[a.layerId];
    const layerB = projectData.layers[b.layerId];
    const emptyResult = { distance: 0, pathCoords: [], segments: 0, usedLayerIds: [], segNames: [], segDistances: [] };
    if (!layerA || !layerB) return emptyResult;

    // SAME LAYER: simple case
    if (a.layerId === b.layerId) {
        const d = calcPathDistance(layerA.coords, a.vertexIdx, b.vertexIdx);
        const sI = Math.min(a.vertexIdx, b.vertexIdx), eI = Math.max(a.vertexIdx, b.vertexIdx);
        return { distance: d, pathCoords: layerA.coords.slice(sI, eI + 1), segments: 1, usedLayerIds: [a.layerId], segNames: [layerA.name], segDistances: [d] };
    }

    // ─── STEP 1: Collect all visible line layers ───
    const allLines = Object.values(projectData.layers).filter(l => l.visible && l.type === 'line' && l.coords.length >= 2);
    if (allLines.length < 2) {
        const d = haversineDistance(a.coord[0], a.coord[1], b.coord[0], b.coord[1]);
        return { distance: d, pathCoords: [a.coord, b.coord], segments: 0, usedLayerIds: [], segNames: [], segDistances: [] };
    }

    // ─── STEP 2: Build node-based topology ───
    // Node IDs: "layerId:s" (start) and "layerId:e" (end)
    // Edges: internal (within layer, real distance) and gap (between layers, straight-line)
    const tNodes = new Map(); // nodeId -> {layerId, end, coord, vertexIdx?}
    const tEdges = new Map(); // nodeId -> [{to, cost, type, layerId?}]

    // Create nodes and internal edges for each layer
    for (const layer of allLines) {
        const sId = layer.id + ':s', eId = layer.id + ':e';
        tNodes.set(sId, { layerId: layer.id, end: 's', coord: layer.coords[0] });
        tNodes.set(eId, { layerId: layer.id, end: 'e', coord: layer.coords[layer.coords.length - 1] });
        tEdges.set(sId, []);
        tEdges.set(eId, []);

        // Internal edge: layer's geometric distance
        let iDist = 0;
        for (let i = 0; i < layer.coords.length - 1; i++) {
            iDist += haversineDistance(layer.coords[i][0], layer.coords[i][1], layer.coords[i+1][0], layer.coords[i+1][1]);
        }
        tEdges.get(sId).push({ to: eId, cost: iDist, type: 'internal', layerId: layer.id });
        tEdges.get(eId).push({ to: sId, cost: iDist, type: 'internal', layerId: layer.id });
    }

    // ─── STEP 3: Gap edges with optimized spatial grid + fast distance ───
    const nodeArr = Array.from(tNodes.entries());
    const nodeIds = nodeArr.map(e => e[0]);
    const K_GAP = 3;

    // Fast equirectangular distance
    const DEG2R = Math.PI / 180;
    const avgLat = (nodeArr.reduce((s,e) => s + e[1].coord[0], 0) / nodeArr.length) * DEG2R;
    const cosAvgLat = Math.cos(avgLat);
    function fastDistDJ(aI, bI) {
        const dl = aI.coord[0] - bI.coord[0];
        const dn = (aI.coord[1] - bI.coord[1]) * cosAvgLat;
        return Math.sqrt(dl*dl + dn*dn) * 111.32;
    }

    // Union-Find
    const ufMap = new Map();
    for (const [nId] of nodeArr) ufMap.set(nId, nId);
    function djFind(x) { while (ufMap.get(x) !== x) { ufMap.set(x, ufMap.get(ufMap.get(x))); x = ufMap.get(x); } return x; }
    function djUnion(a, b) { a = djFind(a); b = djFind(b); if (a === b) return false; ufMap.set(b, a); return true; }
    for (const [nId] of nodeArr) {
        for (const e of tEdges.get(nId)) { if (e.type === 'internal') djUnion(nId, e.to); }
    }

    // Adaptive spatial grid
    const allCLats = nodeArr.map(e => e[1].coord[0]);
    const allCLngs = nodeArr.map(e => e[1].coord[1]);
    const djSpan = Math.max(Math.max(...allCLngs) - Math.min(...allCLngs), Math.max(...allCLats) - Math.min(...allCLats)) || 1;
    const DJ_GRID = Math.max(0.01, Math.min(0.5, djSpan / 50));
    const djGrid = new Map();
    for (const [nId, nInfo] of nodeArr) {
        const key = Math.floor(nInfo.coord[1] / DJ_GRID) + ',' + Math.floor(nInfo.coord[0] / DJ_GRID);
        if (!djGrid.has(key)) djGrid.set(key, []);
        djGrid.get(key).push([nId, nInfo]);
    }

    for (const [nId, nInfo] of nodeArr) {
        const gx0 = Math.floor(nInfo.coord[1] / DJ_GRID);
        const gy0 = Math.floor(nInfo.coord[0] / DJ_GRID);
        let candidates = [];
        for (let r = 0; r <= 5 && candidates.length < K_GAP; r++) {
            for (let dx = -r; dx <= r; dx++) {
                for (let dy = -r; dy <= r; dy++) {
                    if (r > 0 && Math.abs(dx) < r && Math.abs(dy) < r) continue;
                    const cell = djGrid.get((gx0 + dx) + ',' + (gy0 + dy));
                    if (!cell) continue;
                    for (const [mId, mInfo] of cell) {
                        if (mInfo.layerId === nInfo.layerId) continue;
                        const d = fastDistDJ(nInfo, mInfo);
                        candidates.push({ mId, d });
                    }
                }
            }
            if (candidates.length >= K_GAP) break;
        }
        candidates.sort((a, b) => a.d - b.d);
        for (const { mId: bestId, d: bestDist } of candidates.slice(0, K_GAP)) {
            const gapCost = bestDist * 100;
            if (!tEdges.get(nId).some(e => e.to === bestId && e.type === 'gap')) {
                tEdges.get(nId).push({ to: bestId, cost: gapCost, type: 'gap', realDist: bestDist });
            }
            if (!tEdges.get(bestId).some(e => e.to === nId && e.type === 'gap')) {
                tEdges.get(bestId).push({ to: nId, cost: gapCost, type: 'gap', realDist: bestDist });
            }
            djUnion(nId, bestId);
        }
    }

        // ─── STEP 4: Bridge disconnected components (optimized with representatives) ───
    const compRoots = new Set(nodeIds.map(id => djFind(id)));
    if (compRoots.size > 1) {
        const compNodes = new Map();
        for (const nId of nodeIds) {
            const r = djFind(nId);
            if (!compNodes.has(r)) compNodes.set(r, []);
            compNodes.get(r).push(nId);
        }
        const roots = Array.from(compNodes.keys());
        // Use max 10 representative nodes per component for speed
        const MAX_REP = 10;
        const compReps = new Map();
        for (const [root, nodes] of compNodes) {
            if (nodes.length <= MAX_REP) { compReps.set(root, nodes); continue; }
            const reps = [];
            const step = Math.max(1, Math.floor(nodes.length / MAX_REP));
            for (let k = 0; k < nodes.length && reps.length < MAX_REP; k += step) reps.push(nodes[k]);
            compReps.set(root, reps);
        }
        const bridges = [];
        for (let ci = 0; ci < roots.length; ci++) {
            const rA = compReps.get(roots[ci]);
            for (let cj = ci + 1; cj < roots.length; cj++) {
                const rB = compReps.get(roots[cj]);
                let bestD = Infinity, bestA = null, bestB = null;
                for (const a of rA) {
                    const aI = tNodes.get(a);
                    for (const b of rB) {
                        const d = fastDistDJ(aI, tNodes.get(b));
                        if (d < bestD) { bestD = d; bestA = a; bestB = b; }
                    }
                }
                if (bestA) bridges.push({ a: bestA, b: bestB, d: bestD });
            }
        }
        bridges.sort((a, b) => a.d - b.d);
        for (const br of bridges) {
            if (djFind(br.a) !== djFind(br.b)) {
                const gapCost = br.d * 100;
                tEdges.get(br.a).push({ to: br.b, cost: gapCost, type: 'gap', realDist: br.d });
                tEdges.get(br.b).push({ to: br.a, cost: gapCost, type: 'gap', realDist: br.d });
                djUnion(br.a, br.b);
            }
        }
    }

        // ─── STEP 5: Insert virtual nodes for A and B measurement points ───
    function insertVNode(layerId, vertexIdx, coord) {
        const layer = projectData.layers[layerId];
        const sId = layerId + ':s', eId = layerId + ':e';
        const vId = layerId + ':v' + vertexIdx;

        let distFromStart = 0;
        for (let i = 0; i < vertexIdx; i++) {
            distFromStart += haversineDistance(layer.coords[i][0], layer.coords[i][1], layer.coords[i+1][0], layer.coords[i+1][1]);
        }
        let distToEnd = 0;
        for (let i = vertexIdx; i < layer.coords.length - 1; i++) {
            distToEnd += haversineDistance(layer.coords[i][0], layer.coords[i][1], layer.coords[i+1][0], layer.coords[i+1][1]);
        }

        tNodes.set(vId, { layerId, end: 'v', coord, vertexIdx });
        tEdges.set(vId, [
            { to: sId, cost: distFromStart, type: 'internal', layerId },
            { to: eId, cost: distToEnd, type: 'internal', layerId }
        ]);
        tEdges.get(sId).push({ to: vId, cost: distFromStart, type: 'internal', layerId });
        tEdges.get(eId).push({ to: vId, cost: distToEnd, type: 'internal', layerId });
        return vId;
    }

    const vA = insertVNode(a.layerId, a.vertexIdx, a.coord);
    const vB = insertVNode(b.layerId, b.vertexIdx, b.coord);

    // ─── STEP 6: Dijkstra from vA to vB ───
    const dMap = new Map();
    const prev = new Map();
    for (const [nId] of tNodes) dMap.set(nId, Infinity);
    dMap.set(vA, 0);

    const pq = [{ id: vA, cost: 0 }];
    const settled = new Set();

    while (pq.length > 0) {
        let mi = 0;
        for (let i = 1; i < pq.length; i++) { if (pq[i].cost < pq[mi].cost) mi = i; }
        const cur = pq.splice(mi, 1)[0];
        if (settled.has(cur.id)) continue;
        settled.add(cur.id);
        if (cur.id === vB) break;

        for (const e of (tEdges.get(cur.id) || [])) {
            if (settled.has(e.to)) continue;
            const nc = cur.cost + e.cost;
            if (nc < dMap.get(e.to)) {
                dMap.set(e.to, nc);
                prev.set(e.to, { from: cur.id, edge: e });
                pq.push({ id: e.to, cost: nc });
            }
        }
    }

    if (!settled.has(vB)) {
        const d = haversineDistance(a.coord[0], a.coord[1], b.coord[0], b.coord[1]);
        return { distance: d, pathCoords: [a.coord, b.coord], segments: 0, usedLayerIds: [], segNames: [], segDistances: [] };
    }

    // ─── STEP 7: Reconstruct path ───
    const pathNodeIds = [];
    let c = vB;
    while (c !== vA) {
        pathNodeIds.unshift(c);
        const p = prev.get(c);
        if (!p) break;
        c = p.from;
    }
    pathNodeIds.unshift(vA);

    // Walk path, build coordinate chain
    let pathCoords = [];
    const usedLayerIds = [];
    const segNames = [];
    const segDistances = [];
    let totalDist = 0;
    const seenLayers = new Set();

    for (let i = 0; i < pathNodeIds.length - 1; i++) {
        const fromId = pathNodeIds[i];
        const toId = pathNodeIds[i + 1];
        const pe = prev.get(toId);
        if (!pe) continue;
        const edge = pe.edge;

        if (edge.type === 'internal' && edge.layerId) {
            const layer = projectData.layers[edge.layerId];
            if (!layer) continue;

            const fromInfo = tNodes.get(fromId);
            const toInfo = tNodes.get(toId);

            let fromIdx = fromInfo.end === 's' ? 0 : fromInfo.end === 'e' ? layer.coords.length - 1 : fromInfo.vertexIdx;
            let toIdx = toInfo.end === 's' ? 0 : toInfo.end === 'e' ? layer.coords.length - 1 : toInfo.vertexIdx;

            const sI = Math.min(fromIdx, toIdx), eI = Math.max(fromIdx, toIdx);
            let slice = layer.coords.slice(sI, eI + 1);
            if (fromIdx > toIdx) slice = slice.slice().reverse();

            let segDist = 0;
            for (let j = 0; j < slice.length - 1; j++) {
                segDist += haversineDistance(slice[j][0], slice[j][1], slice[j+1][0], slice[j+1][1]);
            }

            pathCoords = pathCoords.concat(slice);
            totalDist += segDist;

            if (!seenLayers.has(edge.layerId)) {
                usedLayerIds.push(edge.layerId);
                segNames.push(layer.name);
                segDistances.push(segDist);
                seenLayers.add(edge.layerId);
            } else {
                const idx = usedLayerIds.indexOf(edge.layerId);
                if (idx >= 0) segDistances[idx] += segDist;
            }
        } else if (edge.type === 'gap') {
            const fromCoord = tNodes.get(fromId).coord;
            const toCoord = tNodes.get(toId).coord;
            const gapDist = edge.realDist || haversineDistance(fromCoord[0], fromCoord[1], toCoord[0], toCoord[1]);
            pathCoords.push(fromCoord, toCoord);
            totalDist += gapDist;
        }
    }

    // Compute dual-mode: cable vs gap breakdown + best estimate path
    let cableDist = 0, gapDist = 0;
    const gapDetails = [];
    for (let i = 0; i < pathNodeIds.length - 1; i++) {
        const toId = pathNodeIds[i + 1];
        const pe = prev.get(toId);
        if (!pe) continue;
        const edge = pe.edge;
        if (edge.type === 'gap') {
            const fromCoord = tNodes.get(pathNodeIds[i]).coord;
            const toCoord = tNodes.get(toId).coord;
            const gd = edge.realDist || haversineDistance(fromCoord[0], fromCoord[1], toCoord[0], toCoord[1]);
            gapDist += gd;
            gapDetails.push({ fromCoord, toCoord, dist: gd });
        }
    }
    cableDist = totalDist - gapDist;

    // Best estimate: cable portions + haversine for gaps (skip loop traversal)
    let bestEstCoords = [];
    let bestEstDist = 0;
    for (let i = 0; i < pathNodeIds.length - 1; i++) {
        const fromId = pathNodeIds[i];
        const toId = pathNodeIds[i + 1];
        const pe = prev.get(toId);
        if (!pe) continue;
        const edge = pe.edge;
        if (edge.type === 'internal' && edge.layerId) {
            const layer = projectData.layers[edge.layerId];
            if (!layer) continue;
            const fromInfo = tNodes.get(fromId);
            const toInfo = tNodes.get(toId);
            let fromIdx = fromInfo.end === 's' ? 0 : fromInfo.end === 'e' ? layer.coords.length - 1 : fromInfo.vertexIdx;
            let toIdx = toInfo.end === 's' ? 0 : toInfo.end === 'e' ? layer.coords.length - 1 : toInfo.vertexIdx;
            const sI = Math.min(fromIdx, toIdx), eI = Math.max(fromIdx, toIdx);
            let slice = layer.coords.slice(sI, eI + 1);
            if (fromIdx > toIdx) slice = slice.slice().reverse();
            let sd = 0;
            for (let j = 0; j < slice.length - 1; j++) sd += haversineDistance(slice[j][0], slice[j][1], slice[j+1][0], slice[j+1][1]);
            bestEstCoords = bestEstCoords.concat(slice);
            bestEstDist += sd;
        } else if (edge.type === 'gap') {
            const fc = tNodes.get(fromId).coord;
            const tc = tNodes.get(toId).coord;
            const gd = haversineDistance(fc[0], fc[1], tc[0], tc[1]);
            bestEstCoords.push(fc, tc);
            bestEstDist += gd;
        }
    }

    return {
        distance: totalDist, pathCoords, segments: usedLayerIds.length,
        usedLayerIds, segNames, segDistances,
        cableDist, gapDist, gapDetails, gapCount: gapDetails.length,
        bestEstDist, bestEstCoords
    };
}

// Get all line layers in folder order (depth-first, items order) — kept for other uses
function getOrderedLineLayers(folderId) {
    const result = [];
    function recurse(fId) {
        const f = projectData.folders.find(ff => ff.id === fId);
        if (!f) return;
        f.items.forEach(id => {
            if (projectData.folders.find(ff => ff.id === id)) return;
            const l = projectData.layers[id];
            if (l && l.type === 'line') result.push(l);
        });
        projectData.folders.filter(ff => ff.parentId === fId).forEach(sf => recurse(sf.id));
    }
    recurse(folderId);
    return result;
}

// Find nearest vertex using PIXEL distance for accuracy (v2.0)
function findNearestVertexByPixel(latlng, coords) {
    const clickPt = map.latLngToContainerPoint(latlng);
    let minD = Infinity, idx = 0;
    coords.forEach((c, i) => {
        const pt = map.latLngToContainerPoint(c);
        const dx = clickPt.x - pt.x, dy = clickPt.y - pt.y;
        const d = dx * dx + dy * dy; // squared pixel distance
        if (d < minD) { minD = d; idx = i; }
    });
    return idx;
}

// === MEASURE A-END → B-END (Enhancement 5) ===
let measureMode = false;
let measureClicks = [];
let measureMarkers = [];
let measureLineLayer = null;

window.toggleMeasureMode = function() {
    measureMode = !measureMode;
    document.getElementById('btnMeasurePath').classList.toggle('active', measureMode);
    if (measureMode) {
        // Deactivate edit/draw/addPoint modes
        if (editMode) { editMode = false; document.getElementById('btnEditMode').classList.remove('active'); }
        if (addPointMode) { addPointMode = false; document.getElementById('btnAddPoint').classList.remove('active'); }
        if (drawMode) { drawMode = false; document.getElementById('btnDrawLine').classList.remove('active'); }
        measureClicks = [];
        measureClickData = [];
        clearMeasureMarkers();
        document.getElementById('editBanner').textContent = '📏 MEASURE — Click anywhere on a line to set 🟢 A-End (origin), then 🔴 B-End (destination)';
        document.getElementById('editBanner').classList.add('show');
        const lc = document.querySelector('.leaflet-container');
        if (lc) lc.classList.add('measure-cursor');
        map.doubleClickZoom.disable();
        renderVertexDots();
        toast('Click on any line: first = 🟢 A-End, second = 🔴 B-End', 'info');
    } else {
        clearMeasureMarkers();
        measureClickData = [];
        if (!editMode) document.getElementById('editBanner').classList.remove('show');
        const lc = document.querySelector('.leaflet-container');
        if (lc) lc.classList.remove('measure-cursor');
        map.doubleClickZoom.enable();
        renderVertexDots();
        toast('Measure mode OFF', 'info');
    }
};

window.ctxMeasureAB = function() {
    if (!measureMode) toggleMeasureMode();
    ctxTargetFolderId = null;
};

let measureDimmedLayers = []; // [{layerId, origOpacity}]
let measureGlowLayers = []; // Leaflet polyline layers for glow effect

function clearMeasureMarkers() {
    measureMarkers.forEach(m => map.removeLayer(m));
    measureMarkers = [];
    if (measureLineLayer) { map.removeLayer(measureLineLayer); measureLineLayer = null; }
    restoreMeasuredLayers();
}

function dimNonMeasuredLayers(usedIds) {
    restoreMeasuredLayers(); // clear any previous
    const usedSet = new Set(usedIds);
    Object.values(projectData.layers).forEach(layer => {
        if (!layer.visible || layer.type !== 'line' || !layer.leafletLayer) return;
        if (!usedSet.has(layer.id)) {
            // Dim non-used layers
            measureDimmedLayers.push({ layerId: layer.id, origOpacity: layer.opacity || 1 });
            layer.leafletLayer.setStyle({ opacity: 0.08 });
        } else {
            // Add glow effect behind used layers: wide semi-transparent bright halo
            const glowOuter = L.polyline(layer.coords, {
                color: '#00e5ff', weight: (layer.width || 2.5) + 10,
                opacity: 0.25, lineCap: 'round', lineJoin: 'round', interactive: false
            }).addTo(map);
            const glowInner = L.polyline(layer.coords, {
                color: '#ffffff', weight: (layer.width || 2.5) + 5,
                opacity: 0.35, lineCap: 'round', lineJoin: 'round', interactive: false
            }).addTo(map);
            // Ensure glow is below the actual line
            glowOuter.bringToBack();
            glowInner.bringToBack();
            measureGlowLayers.push(glowOuter, glowInner);
        }
    });
}

function restoreMeasuredLayers() {
    measureDimmedLayers.forEach(({ layerId, origOpacity }) => {
        const layer = projectData.layers[layerId];
        if (layer && layer.leafletLayer) {
            layer.leafletLayer.setStyle({ opacity: origOpacity });
        }
    });
    measureDimmedLayers = [];
    measureGlowLayers.forEach(gl => map.removeLayer(gl));
    measureGlowLayers = [];
}

// Keep the old haversine-based function as fallback
function findNearestVertexIdxLegacy(latlng, coords) {
    let minD = Infinity, idx = 0;
    coords.forEach((c, i) => {
        const d = haversineDistance(latlng.lat, latlng.lng, c[0], c[1]);
        if (d < minD) { minD = d; idx = i; }
    });
    return idx;
}

// Original haversine-based (kept for non-measure uses)
function findNearestVertexIdx(latlng, coords) {
    return findNearestVertexByPixel(latlng, coords);
}

// Intercept map click for measure mode - added in the main click handler override below

// === EXPORT CHECKED FOLDER AS KML (Enhancement 1) ===
// Unified context menu export (v2.5)
window.ctxExportAs = async function(format) {
    hideCtxMenu();
    let exportName = 'export';
    let layerIds = [];

    if (ctxTargetFolderId) {
        const folder = projectData.folders.find(f => f.id === ctxTargetFolderId);
        if (!folder) return;
        exportName = folder.name.replace(/[^a-zA-Z0-9_-]/g, '_');
        function collectChecked(fId) {
            const f = projectData.folders.find(ff => ff.id === fId);
            if (!f || f.checked === false) return;
            f.items.forEach(id => { const l = projectData.layers[id]; if (l && l.checked !== false) layerIds.push(id); });
            projectData.folders.filter(ff => ff.parentId === fId && ff.checked !== false).forEach(sf => collectChecked(sf.id));
        }
        collectChecked(ctxTargetFolderId);
    } else if (ctxTargetId) {
        const l = projectData.layers[ctxTargetId];
        if (!l) return;
        exportName = l.name.replace(/[^a-zA-Z0-9_-]/g, '_');
        layerIds = [ctxTargetId];
    }

    if (!layerIds.length) { toast('No layers to export', 'error'); return; }

    if (format === 'kml') {
        const kml = buildKMLForLayers(layerIds, exportName);
        downloadFile(kml, exportName + '.kml', 'application/vnd.google-earth.kml+xml');
        toast('Exported ' + layerIds.length + ' layer(s) as KML', 'success');
    } else if (format === 'kmz') {
        if (typeof JSZip === 'undefined') { toast('JSZip not loaded', 'error'); return; }
        const kml = buildKMLForLayers(layerIds, exportName);
        const zip = new JSZip();
        zip.file('doc.kml', kml);
        const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = exportName + '.kmz';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        toast('Exported ' + layerIds.length + ' layer(s) as KMZ', 'success');
    } else if (format === 'geojson') {
        const gj = buildGeoJSONForLayers(layerIds);
        downloadFile(gj, exportName + '.geojson', 'application/geo+json');
        toast('Exported ' + layerIds.length + ' layer(s) as GeoJSON', 'success');
    } else if (format === 'simplified') {
        const gj = buildSimplifiedGeoJSONForLayers(layerIds);
        const defaultFn = exportName + '_simplified.geojson';
        const fn = prompt('Export filename:', defaultFn);
        if (!fn) return;
        const finalFn = fn.endsWith('.geojson') ? fn : fn + '.geojson';
        downloadFile(gj, finalFn, 'application/geo+json');
        toast('Exported simplified GeoJSON', 'success');
    }
    ctxTargetFolderId = null;
    ctxTargetId = null;
};

function buildKMLForLayers(layerIds, docName) {
    let k = '<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n';
    k += '  <n>' + escXml(docName) + '</n>\n';
    layerIds.forEach(id => {
        const l = projectData.layers[id]; if (!l) return;
        k += buildPM(l, '  ');
    });
    k += '</Document>\n</kml>';
    return k;
}

window.ctxExportFolderKML = function() { ctxExportAs('kml'); };

function buildKMLFolderChecked(folder, ind) {
    let k = '';
    // Sub-folders that are checked
    projectData.folders.filter(f => f.parentId === folder.id && f.checked !== false).forEach(sf => {
        k += ind + '<Folder>\n' + ind + '  <name>' + escXml(sf.name) + '</name>\n';
        k += buildKMLFolderChecked(sf, ind + '  ');
        k += ind + '</Folder>\n';
    });
    folder.items.forEach(id => {
        if (projectData.folders.find(f => f.id === id)) return;
        const l = projectData.layers[id]; if (!l) return;
        k += buildPM(l, ind);
    });
    return k;
}

// === FOLDER DRAG NESTING (Enhancement 3) ===
// This is handled in the renderFolderTree by adding drag events to folder headers

function moveFolderIntoFolder(sourceFolderId, targetFolderId) {
    if (sourceFolderId === targetFolderId) return;
    // Prevent moving a folder into its own descendant
    function isDescendant(parentId, childId) {
        const children = projectData.folders.filter(f => f.parentId === parentId);
        for (const c of children) {
            if (c.id === childId) return true;
            if (isDescendant(c.id, childId)) return true;
        }
        return false;
    }
    if (isDescendant(sourceFolderId, targetFolderId)) {
        toast('Cannot move a folder into its own subfolder', 'error');
        return;
    }
    const src = projectData.folders.find(f => f.id === sourceFolderId);
    if (!src) return;
    // Remove from old parent
    if (src.parentId) {
        const oldParent = projectData.folders.find(f => f.id === src.parentId);
        if (oldParent) oldParent.items = oldParent.items.filter(id => id !== sourceFolderId);
    }
    // Set new parent
    src.parentId = targetFolderId;
    const target = projectData.folders.find(f => f.id === targetFolderId);
    if (target && !target.items.includes(sourceFolderId)) {
        target.items.push(sourceFolderId);
    }
    renderFolderTree();
    toast('Folder moved', 'info');
}
} // end initApp
</script>
</body>
</html>
