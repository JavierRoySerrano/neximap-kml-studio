<!DOCTYPE html>
<!-- NexiMap KML Studio v1.2 - Light theme, multi-map, vertex editing fix, GeoJSON import -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NexiMap KML Studio v1.2</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect x='2' y='2' width='28' height='28' rx='4' fill='%230096D6'/%3E%3Cpath d='M8 12L16 8L24 12L16 16Z' fill='white' opacity='0.9'/%3E%3Cpath d='M8 16L16 20L24 16' stroke='white' stroke-width='1.5' fill='none'/%3E%3Cpath d='M8 20L16 24L24 20' stroke='white' stroke-width='1.5' fill='none'/%3E%3C/svg%3E"/>
<style>
:root {
    --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    --bg: #ffffff;
    --bg-header: #fafafa;
    --bg-panel: #f8f9fa;
    --bg-hover: #e8e8e8;
    --bg-selected: #d0e8f5;
    --bg-active: #dbeafe;
    --border: #e0e0e0;
    --border-focus: #0096D6;
    --text: #333333;
    --text-secondary: #666666;
    --text-muted: #999999;
    --accent: #0096D6;
    --accent-hover: #0077aa;
    --accent-light: #e0f2fe;
    --accent-gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --shadow: 0 2px 8px rgba(0,0,0,0.1);
    --shadow-lg: 0 4px 20px rgba(0,0,0,0.15);
}

* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: var(--font); background: var(--bg); color: var(--text); overflow: hidden; height: 100vh; }

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: #f0f0f0; }
::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #aaa; }

/* === HEADER === */
header {
    display: flex;
    align-items: center;
    height: 40px;
    padding: 0 8px;
    background: var(--bg-header);
    border-bottom: 1px solid var(--border);
    gap: 4px;
    z-index: 2000;
    position: relative;
}

.app-logo {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 0 8px;
    font-weight: 700;
    font-size: 14px;
    color: var(--accent);
    white-space: nowrap;
}

.app-logo .ver {
    font-weight: 400;
    font-size: 10px;
    color: var(--text-muted);
    background: #eee;
    padding: 1px 5px;
    border-radius: 3px;
}

/* Menu items */
.menu-item {
    background: transparent;
    border: none;
    color: #444;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 13px;
    font-family: var(--font);
    border-radius: 4px;
    position: relative;
}
.menu-item:hover { background: var(--bg-hover); }

/* Dropdown menus */
.menu-dropdown {
    display: none;
    position: fixed;
    background: white;
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: var(--shadow-lg);
    min-width: 200px;
    padding: 4px 0;
    z-index: 9999;
    z-index: 1000;
}
.menu-dropdown.show { display: block; }

.menu-dropdown-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 14px;
    font-size: 13px;
    color: var(--text);
    cursor: pointer;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    font-family: var(--font);
}
.menu-dropdown-item:hover { background: var(--accent-light); color: var(--accent); }
.menu-dropdown-item .shortcut { margin-left: auto; font-size: 11px; color: var(--text-muted); }
.menu-sep { height: 1px; background: var(--border); margin: 4px 0; }

/* Toolbar buttons */
.tool-sep { width: 1px; height: 24px; background: #d0d0d0; margin: 0 4px; }

.tool-btn {
    background: transparent;
    border: 1px solid transparent;
    color: #555;
    padding: 5px 8px;
    cursor: pointer;
    font-size: 12px;
    font-family: var(--font);
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 4px;
    white-space: nowrap;
    transition: all 0.15s;
}
.tool-btn:hover { background: var(--bg-hover); border-color: #d0d0d0; }
.tool-btn.active {
    background: var(--bg-selected);
    color: #0066a0;
    border-color: var(--accent);
}
.tool-btn svg { width: 16px; height: 16px; flex-shrink: 0; }

.spacer { flex: 1; }

#statusText { font-size: 11px; color: var(--text-muted); padding-right: 8px; }

/* === MAIN LAYOUT === */
#mainLayout { display: flex; height: calc(100vh - 40px); position: relative; z-index: 1; }

/* === LEFT PANEL === */
#leftPanel {
    width: 260px;
    min-width: 180px;
    max-width: 400px;
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    position: relative;
}

.panel-header {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: white;
}

.panel-header h3 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
}

.panel-actions { display: flex; gap: 2px; }

.panel-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-muted);
    cursor: pointer;
    padding: 3px 5px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    font-size: 11px;
    font-family: var(--font);
    gap: 3px;
    transition: all 0.15s;
}
.panel-btn:hover { color: var(--text); background: var(--bg-hover); border-color: var(--border); }
.panel-btn svg { width: 14px; height: 14px; }

#folderTree { flex: 1; overflow-y: auto; padding: 4px 0; }

/* Tree folder */
.tree-folder { user-select: none; }

.tree-folder-header {
    display: flex;
    align-items: center;
    padding: 4px 6px;
    cursor: pointer;
    border-radius: 3px;
    margin: 1px 4px;
    transition: background 0.1s;
    gap: 3px;
}
.tree-folder-header:hover { background: var(--bg-hover); }
.tree-folder-header.selected { background: var(--bg-selected); }
.tree-folder-header.drag-over { outline: 2px dashed var(--accent); outline-offset: -2px; }

.tree-toggle {
    width: 16px; height: 16px;
    display: flex; align-items: center; justify-content: center;
    color: var(--text-muted); font-size: 9px; flex-shrink: 0;
    transition: transform 0.15s;
}
.tree-toggle.collapsed { transform: rotate(-90deg); }

.folder-icon { font-size: 14px; margin-right: 4px; }

.tree-folder-name {
    font-size: 12px; font-weight: 500; color: var(--text);
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

.tree-folder-count {
    font-size: 10px; color: var(--text-muted);
    background: #eee; padding: 0 5px; border-radius: 8px;
}

.tree-folder-children { padding-left: 14px; }
.tree-folder-children.hidden { display: none; }

/* Tree items */
.tree-item {
    display: flex; align-items: center;
    padding: 3px 6px 3px 8px;
    cursor: pointer; border-radius: 3px;
    margin: 1px 4px; transition: background 0.1s; gap: 5px;
}
.tree-item:hover { background: var(--bg-hover); }
.tree-item.selected { background: var(--bg-selected); }
.tree-item.drag-over { outline: 2px dashed var(--accent); }

.tree-item-color { width: 12px; height: 3px; border-radius: 2px; flex-shrink: 0; }

.tree-item-name {
    font-size: 11.5px; color: var(--text-secondary);
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

.tree-item-pts { font-size: 10px; color: var(--text-muted); }

.tree-item-vis {
    width: 16px; height: 16px; cursor: pointer; color: var(--text-muted);
    display: flex; align-items: center; flex-shrink: 0;
}
.tree-item-vis.hidden-item { opacity: 0.3; }

/* Resize handle */
#leftResize {
    position: absolute; right: -3px; top: 0; bottom: 0;
    width: 6px; cursor: col-resize; z-index: 10;
}
#leftResize:hover, #leftResize.active { background: var(--accent); opacity: 0.3; }

/* === MAP === */
#mapContainer { flex: 1; position: relative; z-index: 0; isolation: isolate; }
#map { width: 100%; height: 100%; }

/* Map layer selector */
#mapLayerSelector {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 500;
    background: white;
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: var(--shadow);
    padding: 6px;
}

.map-layer-btn {
    display: block;
    width: 100%;
    padding: 5px 10px;
    font-size: 11px;
    font-family: var(--font);
    background: none;
    border: 1px solid transparent;
    border-radius: 4px;
    cursor: pointer;
    text-align: left;
    color: var(--text-secondary);
    transition: all 0.1s;
    white-space: nowrap;
}
.map-layer-btn:hover { background: #f0f0f0; }
.map-layer-btn.active { background: var(--bg-selected); color: var(--accent); border-color: var(--accent); font-weight: 600; }

/* === RIGHT PANEL === */
#rightPanel {
    width: 250px;
    min-width: 200px;
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

.prop-section {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
    background: white;
}

.prop-section h4 {
    font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.5px;
    color: var(--text-muted); margin-bottom: 8px;
}

.prop-row { display: flex; align-items: center; margin-bottom: 6px; gap: 8px; }
.prop-label { font-size: 11px; color: var(--text-secondary); width: 60px; flex-shrink: 0; }

.prop-input {
    flex: 1; background: white;
    border: 1px solid var(--border); color: var(--text);
    font-family: var(--font); font-size: 11px;
    padding: 4px 7px; border-radius: 4px; outline: none;
    transition: border-color 0.15s;
}
.prop-input:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(0,150,214,0.1); }

.prop-input[type="color"] { width: 32px; height: 26px; padding: 2px; cursor: pointer; }

.prop-input[type="range"] {
    -webkit-appearance: none; height: 4px;
    background: #ddd; border: none; border-radius: 2px; padding: 0;
}
.prop-input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    background: var(--accent); border-radius: 50%; cursor: pointer;
    border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.prop-range-val { font-size: 10px; color: var(--text-muted); width: 30px; text-align: right; }

.prop-btn {
    background: white; border: 1px solid var(--border);
    color: var(--text-secondary); font-family: var(--font);
    font-size: 11px; padding: 6px 10px; border-radius: 4px;
    cursor: pointer; transition: all 0.15s; width: 100%; text-align: center;
}
.prop-btn:hover { background: var(--accent-light); color: var(--accent); border-color: var(--accent); }
.prop-btn.danger:hover { background: #fef2f2; color: var(--danger); border-color: var(--danger); }
.prop-btn.success { background: #ecfdf5; color: var(--success); border-color: rgba(16,185,129,0.3); }
.prop-btn.success:hover { border-color: var(--success); }
.prop-btn.primary { background: var(--accent); color: white; border-color: var(--accent); }
.prop-btn.primary:hover { background: var(--accent-hover); }

#simplifyPreview { font-size: 10px; color: var(--text-muted); padding: 4px 0; line-height: 1.6; }

/* Empty state */
#emptyState {
    position: absolute; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 400; pointer-events: none;
}
#emptyState.hidden { display: none; }
#emptyState svg { width: 48px; height: 48px; color: #ccc; margin-bottom: 12px; }
#emptyState p { font-size: 13px; color: var(--text-muted); text-align: center; line-height: 1.6; }
#emptyState .hint { font-size: 11px; }

/* Context menu */
.ctx-menu {
    position: fixed; background: white;
    border: 1px solid var(--border); border-radius: 6px;
    padding: 4px 0; min-width: 180px;
    box-shadow: var(--shadow-lg); z-index: 7000; display: none;
}
.ctx-menu.show { display: block; }

.ctx-item {
    padding: 6px 14px; font-size: 12px; color: var(--text-secondary);
    cursor: pointer; display: flex; align-items: center; gap: 8px;
    transition: background 0.1s;
}
.ctx-item:hover { background: var(--accent-light); color: var(--accent); }
.ctx-item.danger { color: var(--danger); }
.ctx-item.danger:hover { background: #fef2f2; }
.ctx-sep { height: 1px; background: var(--border); margin: 4px 0; }

/* Toast */
#toastContainer {
    position: fixed; bottom: 20px; right: 20px;
    z-index: 6000; display: flex; flex-direction: column; gap: 8px;
}
.toast {
    background: white; border: 1px solid var(--border);
    border-radius: 6px; padding: 10px 16px; font-size: 12px;
    color: var(--text); box-shadow: var(--shadow-lg);
    animation: toastIn 0.3s ease; max-width: 320px;
}
.toast.success { border-left: 3px solid var(--success); }
.toast.error { border-left: 3px solid var(--danger); }
.toast.info { border-left: 3px solid var(--accent); }

@keyframes toastIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Vertex markers */
.vertex-marker {
    width: 10px; height: 10px;
    background: white;
    border: 2px solid var(--accent);
    border-radius: 50%;
    cursor: grab;
    transition: transform 0.1s;
    position: relative;
    z-index: 800 !important;
}
.vertex-marker:hover { transform: scale(1.5); background: var(--accent-light); }
.vertex-marker.dragging { cursor: grabbing; background: var(--accent); }

.vertex-marker-endpoint {
    width: 12px; height: 12px;
    background: var(--accent);
    border: 2px solid white;
    border-radius: 50%;
    cursor: grab;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    z-index: 800 !important;
}

/* Edit mode banner */
#editBanner {
    display: none; position: absolute; top: 10px; left: 50%;
    transform: translateX(-50%); z-index: 600;
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: white; padding: 6px 16px; border-radius: 20px;
    font-size: 12px; font-weight: 600;
    box-shadow: 0 2px 10px rgba(245,158,11,0.4);
    white-space: nowrap;
}
#editBanner.show { display: block; }

/* Hidden inputs */
#fileInput, #mergeFileInput, #geojsonInput { display: none; }
</style>
</head>
<body>

<!-- HEADER -->
<header>
    <div class="app-logo">
        <svg width="20" height="20" viewBox="0 0 32 32"><rect x="2" y="2" width="28" height="28" rx="4" fill="#0096D6"/><path d="M8 12L16 8L24 12L16 16Z" fill="white" opacity="0.9"/><path d="M8 16L16 20L24 16" stroke="white" stroke-width="1.5" fill="none"/><path d="M8 20L16 24L24 20" stroke="white" stroke-width="1.5" fill="none"/></svg>
        NexiMap KML Studio
        <span class="ver">v1.2</span>
    </div>

    <!-- File Menu -->
    <button class="menu-item" onclick="toggleMenu('fileMenu', this)">File</button>
    <!-- Edit Menu -->
    <button class="menu-item" onclick="toggleMenu('editMenu', this)">Edit</button>
    <!-- View Menu -->
    <button class="menu-item" onclick="toggleMenu('viewMenu', this)">View</button>

    <div class="tool-sep"></div>

    <!-- Toolbar buttons -->
    <button class="tool-btn" id="btnEditMode" onclick="toggleEditMode()" title="Toggle vertex editing (drag dots to move)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
        Edit Vertices
    </button>
    <button class="tool-btn" id="btnAddPoint" onclick="toggleAddPointMode()" title="Click on map to insert vertices">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
        Add Point
    </button>

    <div class="spacer"></div>
    <span id="statusText">Ready</span>
</header>

<!-- MAIN LAYOUT -->
<div id="mainLayout">
    <!-- LEFT PANEL -->
    <div id="leftPanel">
        <div class="panel-header">
            <h3>Layers</h3>
            <div class="panel-actions">
                <button class="panel-btn" onclick="createNewFolder()" title="New folder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                    New
                </button>
                <button class="panel-btn" onclick="expandAllFolders()" title="Expand all">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                </button>
                <button class="panel-btn" onclick="collapseAllFolders()" title="Collapse all">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
                </button>
            </div>
        </div>
        <div id="folderTree"></div>
        <div id="leftResize"></div>
    </div>

    <!-- MAP -->
    <div id="mapContainer">
        <div id="map"></div>
        <div id="editBanner">‚úèÔ∏è EDIT MODE ‚Äî Drag vertices to reposition ‚Ä¢ Right-click vertex to delete</div>
        <div id="mapLayerSelector">
            <button class="map-layer-btn active" data-layer="osm" onclick="switchMapLayer('osm')">üó∫Ô∏è Street Map</button>
            <button class="map-layer-btn" data-layer="osm-hot" onclick="switchMapLayer('osm-hot')">üèôÔ∏è Humanitarian</button>
            <button class="map-layer-btn" data-layer="carto-voyager" onclick="switchMapLayer('carto-voyager')">üè∑Ô∏è Labels + Detail</button>
            <button class="map-layer-btn" data-layer="carto-light" onclick="switchMapLayer('carto-light')">‚òÅÔ∏è Light Clean</button>
            <button class="map-layer-btn" data-layer="carto-dark" onclick="switchMapLayer('carto-dark')">üåë Dark</button>
            <button class="map-layer-btn" data-layer="satellite" onclick="switchMapLayer('satellite')">üõ∞Ô∏è Satellite</button>
            <button class="map-layer-btn" data-layer="sat-labels" onclick="switchMapLayer('sat-labels')">üõ∞Ô∏è Satellite + Labels</button>
            <button class="map-layer-btn" data-layer="topo" onclick="switchMapLayer('topo')">‚õ∞Ô∏è Topographic</button>
        </div>
        <div id="emptyState">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/>
            </svg>
            <p>Open a KML or GeoJSON file to begin<br><span class="hint">Use File menu or drag &amp; drop onto the map</span></p>
        </div>
    </div>

    <!-- RIGHT PANEL -->
    <div id="rightPanel">
        <div class="panel-header"><h3>Properties</h3></div>
        <div id="propsContent">
            <div class="prop-section" id="propNone">
                <p style="font-size:11px;color:var(--text-muted);text-align:center;padding:20px 0;">Select a layer to edit properties</p>
            </div>
            <div class="prop-section" id="propName" style="display:none;">
                <h4>Layer Info</h4>
                <div class="prop-row">
                    <span class="prop-label">Name</span>
                    <input class="prop-input" type="text" id="propNameInput" onchange="updateSelectedName(this.value)">
                </div>
                <div class="prop-row">
                    <span class="prop-label">Points</span>
                    <span id="propPointCount" style="font-size:11px;color:var(--text-muted);">0</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Type</span>
                    <span id="propType" style="font-size:11px;color:var(--text-muted);">‚Äî</span>
                </div>
            </div>
            <div class="prop-section" id="propStyle" style="display:none;">
                <h4>Line Style</h4>
                <div class="prop-row">
                    <span class="prop-label">Color</span>
                    <input class="prop-input" type="color" id="propColor" value="#3b82f6" onchange="updateSelectedColor(this.value)">
                </div>
                <div class="prop-row">
                    <span class="prop-label">Width</span>
                    <input class="prop-input" type="range" id="propWidth" min="1" max="12" value="3" oninput="updateSelectedWidth(this.value)">
                    <span class="prop-range-val" id="propWidthVal">3</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Opacity</span>
                    <input class="prop-input" type="range" id="propOpacity" min="0.1" max="1" step="0.05" value="0.9" oninput="updateSelectedOpacity(this.value)">
                    <span class="prop-range-val" id="propOpacityVal">0.9</span>
                </div>
            </div>
            <div class="prop-section" id="propSimplify" style="display:none;">
                <h4>Simplification</h4>
                <p style="font-size:10px;color:var(--text-muted);margin-bottom:8px;">Douglas-Peucker algorithm. Lower tolerance = more detail.</p>
                <div class="prop-row">
                    <span class="prop-label">Tolerance</span>
                    <input class="prop-input" type="range" id="propTolerance" min="0.0001" max="0.1" step="0.0001" value="0.001" oninput="previewSimplify(this.value)">
                    <span class="prop-range-val" id="propToleranceVal">0.001</span>
                </div>
                <div id="simplifyPreview"></div>
                <div style="display:flex;gap:6px;margin-top:6px;">
                    <button class="prop-btn primary" onclick="applySimplify()" style="flex:1;">Apply</button>
                    <button class="prop-btn" onclick="undoSimplify()" style="flex:1;">Undo</button>
                </div>
            </div>
            <div class="prop-section" id="propActions" style="display:none;">
                <h4>Actions</h4>
                <button class="prop-btn" onclick="zoomToSelected()">Zoom to Layer</button>
                <div style="height:5px;"></div>
                <button class="prop-btn" onclick="duplicateSelected()">Duplicate</button>
                <div style="height:5px;"></div>
                <button class="prop-btn danger" onclick="deleteSelected()">Delete Layer</button>
            </div>
        </div>
    </div>
</div>

<!-- CONTEXT MENU -->
<div class="ctx-menu" id="ctxMenu">
    <div class="ctx-item" onclick="ctxRename()">‚úèÔ∏è Rename</div>
    <div class="ctx-item" onclick="ctxDuplicate()">üìã Duplicate</div>
    <div class="ctx-item" onclick="ctxZoomTo()">üîé Zoom to</div>
    <div class="ctx-sep"></div>
    <div class="ctx-item" onclick="ctxMoveToFolder()">üìÅ Move to folder‚Ä¶</div>
    <div class="ctx-sep"></div>
    <div class="ctx-item danger" onclick="ctxDelete()">üóëÔ∏è Delete</div>
</div>

<div id="toastContainer"></div>

<!-- Menu dropdowns (body-level for z-index above Leaflet) -->
<div class="menu-dropdown" id="fileMenu">
    <button class="menu-dropdown-item" onclick="openKMLFile(); closeMenus();">
        üìÇ Open KML‚Ä¶ <span class="shortcut">Ctrl+O</span>
    </button>
    <button class="menu-dropdown-item" onclick="openGeoJSONFile(); closeMenus();">
        üìÇ Open GeoJSON‚Ä¶
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="openMergeFiles(); closeMenus();">
        üìë Merge multiple KMLs‚Ä¶
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="saveKML(); closeMenus();">
        üíæ Save as KML <span class="shortcut">Ctrl+S</span>
    </button>
    <button class="menu-dropdown-item" onclick="exportSimplifiedGeoJSON(); closeMenus();">
        üì§ Export Simplified GeoJSON
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="clearProject(); closeMenus();">
        üóëÔ∏è Clear All
    </button>
</div>
<div class="menu-dropdown" id="editMenu">
    <button class="menu-dropdown-item" onclick="createNewFolder(); closeMenus();">
        üìÅ New Folder
    </button>
    <div class="menu-sep"></div>
    <button class="menu-dropdown-item" onclick="selectAllItems(); closeMenus();">
        ‚òëÔ∏è Select All Layers
    </button>
    <button class="menu-dropdown-item" onclick="deselectAll(); closeMenus();">
        ‚¨ú Deselect All
    </button>
</div>
<div class="menu-dropdown" id="viewMenu">
    <button class="menu-dropdown-item" onclick="zoomToAll(); closeMenus();">
        üîç Zoom to All Layers
    </button>
    <button class="menu-dropdown-item" onclick="zoomToSelected(); closeMenus();">
        üîé Zoom to Selected
    </button>
</div>

<input type="file" id="fileInput" accept=".kml" onchange="handleFileOpen(event)">
<input type="file" id="mergeFileInput" accept=".kml" multiple onchange="handleMergeFiles(event)">
<input type="file" id="geojsonInput" accept=".geojson,.json" onchange="handleGeoJSONOpen(event)">

<script>
// Load Leaflet dynamically with multi-CDN fallback
function loadScript(url) {
    return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url; s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
    });
}
function loadCSS(url) {
    return new Promise((resolve) => {
        const l = document.createElement('link');
        l.rel = 'stylesheet'; l.href = url;
        l.onload = resolve; l.onerror = resolve;
        document.head.appendChild(l);
    });
}

async function loadLeaflet() {
    const cssCDNs = [
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
        'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css',
        'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css'
    ];
    const jsCDNs = [
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
        'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js',
        'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js'
    ];
    for (const url of cssCDNs) { try { await loadCSS(url); break; } catch(e) {} }
    for (const url of jsCDNs) {
        try { await loadScript(url); if (typeof L !== 'undefined') return true; }
        catch(e) { console.warn('CDN failed:', url); }
    }
    return false;
}

(async function() {
    const ok = await loadLeaflet();
    if (!ok) {
        document.getElementById('emptyState').innerHTML = '<p style="color:#ef4444;font-size:14px;padding:30px;">Failed to load Leaflet map library.<br>Check internet connection and reload.</p>';
        return;
    }
    initApp();
})();

function initApp() {

// === DATA MODEL ===
let projectData = { folders: [], layers: {} };
let nextId = 1;
const genId = () => 'L' + (nextId++);
const genFolderId = () => 'F' + (nextId++);
let selectedLayerId = null;
let editMode = false;
let addPointMode = false;
let ctxTargetId = null;

// === MAP ===
const map = L.map('map', { center: [20, 0], zoom: 3, zoomControl: true, attributionControl: true });

const tileLayers = {
    'osm': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '¬© OpenStreetMap'
    }),
    'osm-hot': L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '¬© OpenStreetMap HOT'
    }),
    'carto-voyager': L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}{r}.png', {
        maxZoom: 19, subdomains: 'abcd', attribution: '¬© CARTO Voyager'
    }),
    'carto-light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19, subdomains: 'abcd', attribution: '¬© CARTO'
    }),
    'carto-dark': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19, subdomains: 'abcd', attribution: '¬© CARTO'
    }),
    'satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 18, attribution: '¬© Esri'
    }),
    'sat-labels': L.layerGroup([
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 18, attribution: '¬© Esri'
        }),
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
            maxZoom: 19, subdomains: 'abcd', pane: 'overlayPane'
        })
    ]),
    'topo': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17, attribution: '¬© OpenTopoMap'
    })
};

let currentTileLayer = tileLayers['osm'];
currentTileLayer.addTo(map);

window.switchMapLayer = function(key) {
    map.removeLayer(currentTileLayer);
    currentTileLayer = tileLayers[key];
    currentTileLayer.addTo(map);
    document.querySelectorAll('.map-layer-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.layer === key);
    });
};

// === FILE I/O ===
window.openKMLFile = () => document.getElementById('fileInput').click();
window.openMergeFiles = () => document.getElementById('mergeFileInput').click();
window.openGeoJSONFile = () => document.getElementById('geojsonInput').click();

window.handleFileOpen = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try { importKML(ev.target.result, file.name); toast('Opened ' + file.name, 'success'); }
        catch (err) { toast('Error: ' + err.message, 'error'); }
    };
    reader.readAsText(file);
    e.target.value = '';
};

window.handleMergeFiles = function(e) {
    const files = Array.from(e.target.files);
    if (!files.length) return;
    let loaded = 0;
    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (ev) => {
            try { importKML(ev.target.result, file.name); }
            catch (err) { toast('Error in ' + file.name + ': ' + err.message, 'error'); }
            loaded++;
            if (loaded === files.length) toast('Merged ' + files.length + ' KML files', 'success');
        };
        reader.readAsText(file);
    });
    e.target.value = '';
};

window.handleGeoJSONOpen = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try { importGeoJSON(ev.target.result, file.name); toast('Opened ' + file.name, 'success'); }
        catch (err) { toast('Error: ' + err.message, 'error'); }
    };
    reader.readAsText(file);
    e.target.value = '';
};

// Drag-and-drop
const mapContainer = document.getElementById('mapContainer');
mapContainer.addEventListener('dragover', (e) => { e.preventDefault(); });
mapContainer.addEventListener('drop', (e) => {
    e.preventDefault();
    Array.from(e.dataTransfer.files).forEach(file => {
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                if (file.name.endsWith('.geojson') || file.name.endsWith('.json')) {
                    importGeoJSON(ev.target.result, file.name);
                } else if (file.name.endsWith('.kml')) {
                    importKML(ev.target.result, file.name);
                }
                toast('Loaded ' + file.name, 'success');
            } catch (err) { toast('Error: ' + err.message, 'error'); }
        };
        reader.readAsText(file);
    });
});

// === KML PARSER (robust) ===
function importKML(kmlStr, fileName) {
    // Strip any non-XML content before the actual KML (e.g. email headers)
    const kmlStart = kmlStr.indexOf('<?xml');
    if (kmlStart > 0) kmlStr = kmlStr.substring(kmlStart);
    if (kmlStart < 0) {
        const kmlTag = kmlStr.indexOf('<kml');
        if (kmlTag >= 0) kmlStr = kmlStr.substring(kmlTag);
    }

    // Strip namespace prefixes that cause querySelector issues
    kmlStr = kmlStr.replace(/<kml:(\w)/g, '<$1').replace(/<\/kml:(\w)/g, '</$1');
    kmlStr = kmlStr.replace(/<gx:(\w)/g, '<gx_$1').replace(/<\/gx:(\w)/g, '</gx_$1');

    const doc = new DOMParser().parseFromString(kmlStr, 'text/xml');

    // Check for parse errors
    const parseErr = doc.querySelector('parsererror');
    if (parseErr) { toast('KML parse error ‚Äî file may be malformed', 'error'); }

    // Parse shared styles
    const sharedStyles = {};
    doc.querySelectorAll('Style[id]').forEach(s => {
        sharedStyles['#' + s.getAttribute('id')] = parseStyleEl(s);
    });
    // StyleMap support ‚Äî pick normal style
    doc.querySelectorAll('StyleMap[id]').forEach(sm => {
        const normal = sm.querySelector('Pair key');
        if (normal) {
            const pairs = sm.querySelectorAll('Pair');
            for (const pair of pairs) {
                const key = pair.querySelector('key');
                if (key && key.textContent.trim() === 'normal') {
                    const styleUrl = pair.querySelector('styleUrl');
                    if (styleUrl) {
                        const ref = styleUrl.textContent.trim();
                        if (sharedStyles[ref]) sharedStyles['#' + sm.getAttribute('id')] = sharedStyles[ref];
                    }
                    const inlineStyle = pair.querySelector('Style');
                    if (inlineStyle) sharedStyles['#' + sm.getAttribute('id')] = parseStyleEl(inlineStyle);
                }
            }
        }
    });

    const folderId = genFolderId();
    const folder = { id: folderId, name: fileName.replace(/\.kml$/i, ''), expanded: true, items: [] };

    function processFolder(parentEl, parentFolderId) {
        // Handle both <Folder> and <Document> as container elements
        const childContainers = parentEl.querySelectorAll(':scope > Folder, :scope > Document');
        childContainers.forEach(kf => {
            const sfId = genFolderId();
            const sfName = getKmlText(kf, 'name') || (kf.tagName === 'Document' ? 'Document' : 'Folder');
            const sf = { id: sfId, name: sfName, expanded: true, items: [], parentId: parentFolderId };

            // Collect styles scoped to this container
            const localStyles = {};
            kf.querySelectorAll(':scope > Style[id]').forEach(s => {
                localStyles['#' + s.getAttribute('id')] = parseStyleEl(s);
            });
            kf.querySelectorAll(':scope > StyleMap[id]').forEach(sm => {
                const pairs = sm.querySelectorAll('Pair');
                for (const pair of pairs) {
                    const key = pair.querySelector('key');
                    if (key && key.textContent.trim() === 'normal') {
                        const styleUrl = pair.querySelector('styleUrl');
                        if (styleUrl) {
                            const ref = styleUrl.textContent.trim();
                            const resolved = localStyles[ref] || sharedStyles[ref];
                            if (resolved) localStyles['#' + sm.getAttribute('id')] = resolved;
                        }
                        const inl = pair.querySelector('Style');
                        if (inl) localStyles['#' + sm.getAttribute('id')] = parseStyleEl(inl);
                    }
                }
            });
            // Merge local styles into shared for resolution within this scope
            const mergedStyles = { ...sharedStyles, ...localStyles };

            kf.querySelectorAll(':scope > Placemark').forEach(pm => {
                const layers = parsePlacemark(pm, sfId, mergedStyles);
                layers.forEach(layer => { sf.items.push(layer.id); projectData.layers[layer.id] = layer; });
            });

            processFolder(kf, sfId);

            if (sf.items.length > 0 || projectData.folders.some(f => f.parentId === sfId)) {
                projectData.folders.push(sf);
                const parent = projectData.folders.find(f => f.id === parentFolderId) || folder;
                parent.items.push(sfId);
            }
        });
    }

    // Root placemarks
    const rootSel = ['Document > Placemark', 'kml > Placemark', 'kml > Document > Placemark'];
    const rootPms = new Set();
    rootSel.forEach(sel => { try { doc.querySelectorAll(sel).forEach(pm => rootPms.add(pm)); } catch(e) {} });
    rootPms.forEach(pm => {
        const layers = parsePlacemark(pm, folderId, sharedStyles);
        layers.forEach(l => { folder.items.push(l.id); projectData.layers[l.id] = l; });
    });

    // Nested folders
    const docEl = doc.querySelector('Document') || doc.querySelector('kml');
    if (docEl) processFolder(docEl, folderId);

    // Fallback: grab all placemarks if nothing was found
    if (folder.items.filter(id => projectData.layers[id]).length === 0 &&
        !projectData.folders.some(f => f.parentId === folderId)) {
        doc.querySelectorAll('Placemark').forEach(pm => {
            const layers = parsePlacemark(pm, folderId, sharedStyles);
            layers.forEach(l => { folder.items.push(l.id); projectData.layers[l.id] = l; });
        });
    }

    projectData.folders.push(folder);
    renderAll();
    zoomToAllInternal();
    document.getElementById('emptyState').classList.add('hidden');
    updateStatus();
}

function parsePlacemark(pm, folderId, sharedStyles) {
    const name = getKmlText(pm, 'name') || 'Unnamed';
    const results = [];

    // Resolve style
    let style = { color: '#3b82f6', width: 3, opacity: 0.9 };
    const styleUrlEl = pm.querySelector(':scope > styleUrl');
    if (styleUrlEl) {
        const ref = styleUrlEl.textContent.trim();
        if (sharedStyles[ref]) style = { ...style, ...sharedStyles[ref] };
    }
    const inlineStyle = pm.querySelector(':scope > Style');
    if (inlineStyle) style = { ...style, ...parseStyleEl(inlineStyle) };

    // Collect all geometries from this placemark
    const geometries = [];

    // Direct geometries
    pm.querySelectorAll(':scope > LineString, :scope > Point, :scope > Polygon, :scope > LinearRing').forEach(g => {
        geometries.push(g);
    });

    // MultiGeometry
    pm.querySelectorAll('MultiGeometry LineString, MultiGeometry Point, MultiGeometry Polygon, MultiGeometry LinearRing').forEach(g => {
        geometries.push(g);
    });

    // gx:Track support
    pm.querySelectorAll('gx_Track').forEach(track => {
        const coords = [];
        track.querySelectorAll('gx_coord').forEach(c => {
            const parts = c.textContent.trim().split(/\s+/);
            if (parts.length >= 2) coords.push([parseFloat(parts[1]), parseFloat(parts[0])]);
        });
        if (coords.length > 0) {
            const id = genId();
            results.push({ id, name, type: 'line', coords, originalCoords: JSON.parse(JSON.stringify(coords)),
                color: style.color, width: style.width, opacity: style.opacity,
                visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
        }
    });

    // If no direct geometry elements found, try just finding coordinates anywhere
    if (geometries.length === 0 && results.length === 0) {
        const anyCoords = pm.querySelector('coordinates');
        if (anyCoords) {
            const coords = parseCoordStr(anyCoords.textContent);
            if (coords.length > 0) {
                const id = genId();
                const type = coords.length === 1 ? 'point' : 'line';
                results.push({ id, name, type, coords, originalCoords: JSON.parse(JSON.stringify(coords)),
                    color: style.color, width: style.width, opacity: style.opacity,
                    visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
            }
        }
        return results;
    }

    let gIdx = 0;
    geometries.forEach(g => {
        const tag = g.tagName.toLowerCase();
        const coordsEl = g.querySelector('coordinates');
        if (!coordsEl && tag !== 'polygon') return;

        if (tag === 'linestring' || tag === 'linearring') {
            const coords = parseCoordStr(coordsEl.textContent);
            if (coords.length > 0) {
                const id = genId();
                const suffix = geometries.length > 1 ? ' #' + (++gIdx) : '';
                results.push({ id, name: name + suffix, type: 'line', coords,
                    originalCoords: JSON.parse(JSON.stringify(coords)),
                    color: style.color, width: style.width, opacity: style.opacity,
                    visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
            }
        } else if (tag === 'point') {
            const coords = parseCoordStr(coordsEl.textContent);
            if (coords.length > 0) {
                const id = genId();
                results.push({ id, name, type: 'point', coords: [coords[0]],
                    originalCoords: JSON.parse(JSON.stringify([coords[0]])),
                    color: style.color, width: style.width, opacity: style.opacity,
                    visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
            }
        } else if (tag === 'polygon') {
            // Extract outer boundary as a line
            const outerCoords = g.querySelector('outerBoundaryIs coordinates') ||
                                g.querySelector('outerBoundaryIs LinearRing coordinates');
            if (outerCoords) {
                const coords = parseCoordStr(outerCoords.textContent);
                if (coords.length > 0) {
                    const id = genId();
                    const suffix = geometries.length > 1 ? ' #' + (++gIdx) : '';
                    results.push({ id, name: name + suffix + ' (polygon)', type: 'line', coords,
                        originalCoords: JSON.parse(JSON.stringify(coords)),
                        color: style.color, width: style.width, opacity: style.opacity,
                        visible: true, folderId, leafletLayer: null, vertexMarkers: [] });
                }
            }
        }
    });

    return results;
}

function parseCoordStr(str) {
    if (!str) return [];
    // Handle various formats: "lng,lat,alt" or "lng,lat" separated by whitespace or newlines
    return str.trim().split(/[\s\n\r]+/).map(s => {
        if (!s || s.length < 3) return null;
        const p = s.split(',');
        if (p.length >= 2) {
            const lng = parseFloat(p[0]);
            const lat = parseFloat(p[1]);
            if (!isNaN(lat) && !isNaN(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                return [lat, lng]; // [lat, lng] for Leaflet
            }
        }
        return null;
    }).filter(c => c !== null);
}

function parseStyleEl(styleEl) {
    const result = {};
    const ls = styleEl.querySelector('LineStyle');
    if (ls) {
        const kc = getKmlText(ls, 'color');
        if (kc && kc.length === 8) {
            result.opacity = Math.round(parseInt(kc.substr(0, 2), 16) / 255 * 100) / 100;
            result.color = '#' + kc.substr(6, 2) + kc.substr(4, 2) + kc.substr(2, 2);
        } else if (kc && kc.length === 6) {
            result.color = '#' + kc.substr(4, 2) + kc.substr(2, 2) + kc.substr(0, 2);
        }
        const w = getKmlText(ls, 'width');
        if (w) result.width = parseFloat(w);
    }
    // Also try PolyStyle for polygons
    const ps = styleEl.querySelector('PolyStyle');
    if (ps && !ls) {
        const kc = getKmlText(ps, 'color');
        if (kc && kc.length === 8) {
            result.opacity = Math.round(parseInt(kc.substr(0, 2), 16) / 255 * 100) / 100;
            result.color = '#' + kc.substr(6, 2) + kc.substr(4, 2) + kc.substr(2, 2);
        }
    }
    return result;
}

function parseStyle(pm) {
    return parseStyleEl(pm.querySelector('Style') || pm);
}

function getKmlText(parent, tag) {
    // Try direct child first, then any descendant
    let el = parent.querySelector(':scope > ' + tag);
    if (!el) {
        // Some KML files use different casing
        const children = parent.children;
        for (let i = 0; i < children.length; i++) {
            if (children[i].tagName.toLowerCase() === tag.toLowerCase()) { el = children[i]; break; }
        }
    }
    return el ? el.textContent.trim() : null;
}

// === GEOJSON PARSER ===
function importGeoJSON(jsonStr, fileName) {
    const data = JSON.parse(jsonStr);
    const folderId = genFolderId();
    const folder = { id: folderId, name: fileName.replace(/\.(geojson|json)$/i, ''), expanded: true, items: [] };

    const features = data.type === 'FeatureCollection' ? data.features :
                     data.type === 'Feature' ? [data] : [];

    features.forEach(f => {
        if (!f.geometry) return;
        const geom = f.geometry;
        const props = f.properties || {};
        const name = props.name || props.Name || props.title || 'Unnamed';
        const color = props.stroke || props.color || '#3b82f6';
        const width = props['stroke-width'] || 3;
        const opacity = props['stroke-opacity'] || 0.9;

        if (geom.type === 'LineString') {
            const coords = geom.coordinates.map(c => [c[1], c[0]]);
            if (coords.length > 0) {
                const id = genId();
                folder.items.push(id);
                projectData.layers[id] = {
                    id, name, type: 'line', coords,
                    originalCoords: JSON.parse(JSON.stringify(coords)),
                    color, width, opacity, visible: true,
                    folderId, leafletLayer: null, vertexMarkers: []
                };
            }
        } else if (geom.type === 'MultiLineString') {
            geom.coordinates.forEach((line, i) => {
                const coords = line.map(c => [c[1], c[0]]);
                if (coords.length > 0) {
                    const id = genId();
                    folder.items.push(id);
                    projectData.layers[id] = {
                        id, name: name + (geom.coordinates.length > 1 ? ' #' + (i + 1) : ''),
                        type: 'line', coords,
                        originalCoords: JSON.parse(JSON.stringify(coords)),
                        color, width, opacity, visible: true,
                        folderId, leafletLayer: null, vertexMarkers: []
                    };
                }
            });
        } else if (geom.type === 'Point') {
            const coords = [[geom.coordinates[1], geom.coordinates[0]]];
            const id = genId();
            folder.items.push(id);
            projectData.layers[id] = {
                id, name, type: 'point', coords,
                originalCoords: JSON.parse(JSON.stringify(coords)),
                color, width: 3, opacity, visible: true,
                folderId, leafletLayer: null, vertexMarkers: []
            };
        }
    });

    projectData.folders.push(folder);
    renderAll();
    zoomToAllInternal();
    document.getElementById('emptyState').classList.add('hidden');
    updateStatus();
}

// === RENDERING ===
function renderAll() { renderFolderTree(); renderMapLayers(); }

function renderMapLayers() {
    Object.values(projectData.layers).forEach(layer => {
        if (layer.leafletLayer) map.removeLayer(layer.leafletLayer);
        layer.vertexMarkers.forEach(m => map.removeLayer(m));
        layer.vertexMarkers = [];
    });

    Object.values(projectData.layers).forEach(layer => {
        if (!layer.visible) return;
        if (layer.type === 'line' && layer.coords.length > 1) {
            layer.leafletLayer = L.polyline(layer.coords, {
                color: layer.color, weight: layer.width, opacity: layer.opacity, interactive: true
            }).addTo(map);
            layer.leafletLayer.on('click', () => selectLayer(layer.id));
        } else if (layer.type === 'point' && layer.coords.length > 0) {
            layer.leafletLayer = L.circleMarker(layer.coords[0], {
                radius: 6, color: layer.color, fillColor: layer.color,
                fillOpacity: layer.opacity, weight: 2
            }).addTo(map);
            layer.leafletLayer.on('click', () => selectLayer(layer.id));
        }

        if (editMode && layer.id === selectedLayerId && layer.type === 'line') {
            renderVertexMarkers(layer);
        }
    });
}

function renderVertexMarkers(layer) {
    layer.vertexMarkers.forEach(m => map.removeLayer(m));
    layer.vertexMarkers = [];

    layer.coords.forEach((coord, idx) => {
        const isEnd = idx === 0 || idx === layer.coords.length - 1;
        const icon = L.divIcon({
            className: isEnd ? 'vertex-marker-endpoint' : 'vertex-marker',
            iconSize: isEnd ? [12, 12] : [10, 10],
            iconAnchor: isEnd ? [6, 6] : [5, 5]
        });

        const marker = L.marker(coord, { icon, draggable: true, zIndexOffset: 2000 }).addTo(map);

        // Prevent map drag when dragging marker
        marker.on('mousedown', () => { map.dragging.disable(); });
        marker.on('dragstart', () => {
            map.dragging.disable();
            if (marker.getElement()) marker.getElement().classList.add('dragging');
        });
        marker.on('drag', (e) => {
            const ll = e.target.getLatLng();
            layer.coords[idx] = [ll.lat, ll.lng];
            if (layer.leafletLayer) layer.leafletLayer.setLatLngs(layer.coords);
        });
        marker.on('dragend', (e) => {
            map.dragging.enable();
            const ll = e.target.getLatLng();
            layer.coords[idx] = [ll.lat, ll.lng];
            if (marker.getElement()) marker.getElement().classList.remove('dragging');
            updateStatus();
        });
        marker.on('contextmenu', (e) => {
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            if (layer.coords.length > 2) {
                layer.coords.splice(idx, 1);
                renderMapLayers();
                updatePropsPanel();
                toast('Removed vertex ' + (idx + 1), 'info');
            }
        });

        layer.vertexMarkers.push(marker);
    });
}

// === FOLDER TREE ===
function renderFolderTree() {
    const container = document.getElementById('folderTree');
    container.innerHTML = '';
    projectData.folders.filter(f => !f.parentId).forEach(f => {
        container.appendChild(createFolderEl(f));
    });
}

function createFolderEl(folder) {
    const div = document.createElement('div');
    div.className = 'tree-folder';
    div.dataset.folderId = folder.id;

    const header = document.createElement('div');
    header.className = 'tree-folder-header';
    const count = countItems(folder);
    header.innerHTML = `
        <span class="tree-toggle ${folder.expanded ? '' : 'collapsed'}">‚ñº</span>
        <span class="folder-icon">${folder.expanded ? 'üìÇ' : 'üìÅ'}</span>
        <span class="tree-folder-name">${esc(folder.name)}</span>
        <span class="tree-folder-count">${count}</span>
    `;

    header.addEventListener('click', () => { folder.expanded = !folder.expanded; renderFolderTree(); });

    header.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        const nameSpan = header.querySelector('.tree-folder-name');
        const input = document.createElement('input');
        input.className = 'prop-input';
        input.value = folder.name;
        input.style.cssText = 'width:100%;font-size:12px;';
        nameSpan.replaceWith(input);
        input.focus(); input.select();
        const done = () => { folder.name = input.value || folder.name; renderFolderTree(); };
        input.addEventListener('blur', done);
        input.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') input.blur(); });
    });

    // Folder drag-and-drop target
    header.addEventListener('dragover', (e) => { e.preventDefault(); header.classList.add('drag-over'); });
    header.addEventListener('dragleave', () => { header.classList.remove('drag-over'); });
    header.addEventListener('drop', (e) => {
        e.preventDefault();
        header.classList.remove('drag-over');
        const layerId = e.dataTransfer.getData('text/plain');
        if (layerId) moveLayerToFolder(layerId, folder.id);
    });

    div.appendChild(header);

    const children = document.createElement('div');
    children.className = 'tree-folder-children' + (folder.expanded ? '' : ' hidden');

    // Sub-folders
    projectData.folders.filter(f => f.parentId === folder.id).forEach(sf => {
        children.appendChild(createFolderEl(sf));
    });

    // Layer items
    folder.items.forEach(itemId => {
        if (projectData.folders.find(f => f.id === itemId)) return;
        const layer = projectData.layers[itemId];
        if (!layer) return;

        const item = document.createElement('div');
        item.className = 'tree-item' + (selectedLayerId === layer.id ? ' selected' : '');
        item.draggable = true;

        const typeIcon = layer.type === 'line' ? '‚îÅ' : '‚óè';
        item.innerHTML = `
            <span class="tree-item-color" style="background:${layer.color}"></span>
            <span style="font-size:10px;color:${layer.color};">${typeIcon}</span>
            <span class="tree-item-name">${esc(layer.name)}</span>
            <span class="tree-item-pts">${layer.coords.length}</span>
            <span class="tree-item-vis ${layer.visible ? '' : 'hidden-item'}" data-id="${layer.id}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                ${layer.visible
                    ? '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'
                    : '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>'
                }</svg>
            </span>
        `;

        item.addEventListener('click', (e) => {
            if (e.target.closest('.tree-item-vis')) {
                layer.visible = !layer.visible; renderAll(); return;
            }
            selectLayer(layer.id);
        });

        item.addEventListener('contextmenu', (e) => {
            e.preventDefault(); ctxTargetId = layer.id;
            showCtxMenu(e.clientX, e.clientY);
        });

        item.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            const nameSpan = item.querySelector('.tree-item-name');
            const input = document.createElement('input');
            input.className = 'prop-input';
            input.value = layer.name;
            input.style.cssText = 'flex:1;font-size:11px;';
            nameSpan.replaceWith(input);
            input.focus(); input.select();
            const done = () => { layer.name = input.value || layer.name; renderAll(); updatePropsPanel(); };
            input.addEventListener('blur', done);
            input.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') input.blur(); });
        });

        item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', layer.id);
            e.dataTransfer.effectAllowed = 'move';
        });

        children.appendChild(item);
    });

    div.appendChild(children);
    return div;
}

function countItems(folder) {
    let c = folder.items.filter(id => projectData.layers[id]).length;
    projectData.folders.filter(f => f.parentId === folder.id).forEach(sf => c += countItems(sf));
    return c;
}

function moveLayerToFolder(layerId, targetId) {
    projectData.folders.forEach(f => { f.items = f.items.filter(id => id !== layerId); });
    const target = projectData.folders.find(f => f.id === targetId);
    if (target) {
        target.items.push(layerId);
        const layer = projectData.layers[layerId];
        if (layer) layer.folderId = targetId;
    }
    renderFolderTree();
    toast('Layer moved', 'info');
}

// === SELECTION ===
function selectLayer(id) {
    selectedLayerId = id;
    renderFolderTree();
    renderMapLayers();
    updatePropsPanel();
}

function updatePropsPanel() {
    const layer = projectData.layers[selectedLayerId];
    const show = (id, v) => document.getElementById(id).style.display = v ? '' : 'none';
    if (!layer) {
        show('propNone', true); show('propName', false); show('propStyle', false);
        show('propSimplify', false); show('propActions', false);
        return;
    }
    show('propNone', false); show('propName', true); show('propStyle', true);
    show('propSimplify', layer.type === 'line'); show('propActions', true);

    document.getElementById('propNameInput').value = layer.name;
    document.getElementById('propPointCount').textContent = layer.coords.length + ' vertices';
    document.getElementById('propType').textContent = layer.type === 'line' ? 'LineString' : 'Point';
    document.getElementById('propColor').value = layer.color;
    document.getElementById('propWidth').value = layer.width;
    document.getElementById('propWidthVal').textContent = layer.width;
    document.getElementById('propOpacity').value = layer.opacity;
    document.getElementById('propOpacityVal').textContent = layer.opacity;
    if (layer.type === 'line') previewSimplify(document.getElementById('propTolerance').value);
}

// === PROPERTY UPDATES ===
window.updateSelectedName = (v) => { const l = projectData.layers[selectedLayerId]; if (l) { l.name = v; renderFolderTree(); } };
window.updateSelectedColor = (v) => { const l = projectData.layers[selectedLayerId]; if (l) { l.color = v; renderMapLayers(); renderFolderTree(); } };
window.updateSelectedWidth = (v) => {
    const l = projectData.layers[selectedLayerId]; if (!l) return;
    l.width = parseFloat(v); document.getElementById('propWidthVal').textContent = v;
    if (l.leafletLayer) l.leafletLayer.setStyle({ weight: l.width });
};
window.updateSelectedOpacity = (v) => {
    const l = projectData.layers[selectedLayerId]; if (!l) return;
    l.opacity = parseFloat(v); document.getElementById('propOpacityVal').textContent = v;
    if (l.leafletLayer) l.leafletLayer.setStyle({ opacity: l.opacity });
};

// === SIMPLIFICATION ===
function douglasPeucker(pts, tol) {
    if (pts.length <= 2) return pts;
    let maxD = 0, maxI = 0;
    for (let i = 1; i < pts.length - 1; i++) {
        const d = perpDist(pts[i], pts[0], pts[pts.length - 1]);
        if (d > maxD) { maxD = d; maxI = i; }
    }
    if (maxD > tol) {
        const left = douglasPeucker(pts.slice(0, maxI + 1), tol);
        const right = douglasPeucker(pts.slice(maxI), tol);
        return left.slice(0, -1).concat(right);
    }
    return [pts[0], pts[pts.length - 1]];
}

function perpDist(p, a, b) {
    const dx = b[1] - a[1], dy = b[0] - a[0];
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) return Math.sqrt((p[0] - a[0]) ** 2 + (p[1] - a[1]) ** 2);
    const u = ((p[1] - a[1]) * dx + (p[0] - a[0]) * dy) / (mag * mag);
    return Math.sqrt((p[0] - (a[0] + u * dy)) ** 2 + (p[1] - (a[1] + u * dx)) ** 2);
}

window.previewSimplify = function(tol) {
    tol = parseFloat(tol);
    document.getElementById('propToleranceVal').textContent = tol.toFixed(4);
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'line') return;
    const simp = douglasPeucker(l.coords, tol);
    const pct = ((1 - simp.length / l.coords.length) * 100).toFixed(1);
    document.getElementById('simplifyPreview').innerHTML =
        `Original: ${l.originalCoords.length} ‚Üí Current: ${l.coords.length} ‚Üí After: ${simp.length} pts (‚àí${pct}%)`;
};

window.applySimplify = function() {
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'line') return;
    const tol = parseFloat(document.getElementById('propTolerance').value);
    l.coords = douglasPeucker(l.coords, tol);
    renderAll(); updatePropsPanel();
    toast('Simplified to ' + l.coords.length + ' points', 'success');
};

window.undoSimplify = function() {
    const l = projectData.layers[selectedLayerId]; if (!l) return;
    l.coords = JSON.parse(JSON.stringify(l.originalCoords));
    renderAll(); updatePropsPanel();
    toast('Restored original coordinates', 'info');
};

// === EDIT MODE ===
window.toggleEditMode = function() {
    editMode = !editMode;
    addPointMode = false;
    document.getElementById('btnEditMode').classList.toggle('active', editMode);
    document.getElementById('btnAddPoint').classList.remove('active');
    document.getElementById('editBanner').classList.toggle('show', editMode);
    renderMapLayers();
    toast(editMode ? 'Edit mode ON' : 'Edit mode OFF', 'info');
};

window.toggleAddPointMode = function() {
    addPointMode = !addPointMode;
    if (addPointMode) { editMode = true; document.getElementById('btnEditMode').classList.add('active'); document.getElementById('editBanner').classList.add('show'); }
    document.getElementById('btnAddPoint').classList.toggle('active', addPointMode);
    if (addPointMode && !selectedLayerId) {
        toast('Select a line layer first', 'error');
        addPointMode = false; document.getElementById('btnAddPoint').classList.remove('active');
        return;
    }
    toast(addPointMode ? 'Click on map to add vertices' : 'Add point mode OFF', 'info');
};

map.on('click', (e) => {
    if (!addPointMode) return;
    const l = projectData.layers[selectedLayerId];
    if (!l || l.type !== 'line') return;
    let minD = Infinity, ins = l.coords.length;
    for (let i = 0; i < l.coords.length - 1; i++) {
        const d = distToSeg([e.latlng.lat, e.latlng.lng], l.coords[i], l.coords[i + 1]);
        if (d < minD) { minD = d; ins = i + 1; }
    }
    l.coords.splice(ins, 0, [e.latlng.lat, e.latlng.lng]);
    renderMapLayers(); updatePropsPanel(); updateStatus();
});

function distToSeg(p, a, b) {
    const dx = b[1] - a[1], dy = b[0] - a[0], len = dx * dx + dy * dy;
    if (len === 0) return Math.sqrt((p[0] - a[0]) ** 2 + (p[1] - a[1]) ** 2);
    let t = Math.max(0, Math.min(1, ((p[1] - a[1]) * dx + (p[0] - a[0]) * dy) / len));
    return Math.sqrt((p[0] - (a[0] + t * dy)) ** 2 + (p[1] - (a[1] + t * dx)) ** 2);
}

// === FOLDER OPS ===
window.createNewFolder = function() {
    projectData.folders.push({ id: genFolderId(), name: 'New Folder', expanded: true, items: [] });
    renderFolderTree(); toast('Created folder', 'info');
};

window.expandAllFolders = () => { projectData.folders.forEach(f => f.expanded = true); renderFolderTree(); };
window.collapseAllFolders = () => { projectData.folders.forEach(f => f.expanded = false); renderFolderTree(); };

window.selectAllItems = function() {
    const ids = Object.keys(projectData.layers);
    if (ids.length) selectLayer(ids[0]);
};
window.deselectAll = function() { selectedLayerId = null; renderAll(); updatePropsPanel(); };

// === CONTEXT MENU ===
function showCtxMenu(x, y) {
    const m = document.getElementById('ctxMenu');
    m.style.left = x + 'px'; m.style.top = y + 'px';
    m.classList.add('show');
}

document.addEventListener('click', () => { document.getElementById('ctxMenu').classList.remove('show'); closeMenus(); });

window.ctxRename = function() {
    const l = projectData.layers[ctxTargetId]; if (!l) return;
    const n = prompt('Rename:', l.name);
    if (n) { l.name = n; renderAll(); updatePropsPanel(); }
};
window.ctxDuplicate = () => duplicateLayer(ctxTargetId);
window.ctxZoomTo = function() {
    const l = projectData.layers[ctxTargetId];
    if (l && l.leafletLayer && l.leafletLayer.getBounds) map.fitBounds(l.leafletLayer.getBounds(), { padding: [40, 40] });
};
window.ctxMoveToFolder = function() {
    const folders = projectData.folders.filter(f => !f.parentId);
    const choice = prompt('Move to folder:\n' + folders.map((f, i) => (i + 1) + '. ' + f.name).join('\n') + '\n\nEnter number:');
    if (choice) {
        const idx = parseInt(choice) - 1;
        if (idx >= 0 && idx < folders.length) moveLayerToFolder(ctxTargetId, folders[idx].id);
    }
};
window.ctxDelete = () => deleteLayer(ctxTargetId);

// === ACTIONS ===
window.zoomToSelected = function() {
    const l = projectData.layers[selectedLayerId];
    if (l && l.leafletLayer && l.leafletLayer.getBounds) map.fitBounds(l.leafletLayer.getBounds(), { padding: [40, 40] });
};

function zoomToAllInternal() {
    const all = [];
    Object.values(projectData.layers).forEach(l => l.coords.forEach(c => all.push(c)));
    if (all.length) map.fitBounds(L.latLngBounds(all), { padding: [40, 40] });
}
window.zoomToAll = zoomToAllInternal;

window.duplicateSelected = () => duplicateLayer(selectedLayerId);

function duplicateLayer(id) {
    const l = projectData.layers[id]; if (!l) return;
    const nid = genId();
    projectData.layers[nid] = { ...l, id: nid, name: l.name + ' (copy)',
        coords: JSON.parse(JSON.stringify(l.coords)),
        originalCoords: JSON.parse(JSON.stringify(l.originalCoords)),
        leafletLayer: null, vertexMarkers: [] };
    const f = projectData.folders.find(f => f.id === l.folderId);
    if (f) f.items.push(nid);
    renderAll(); toast('Duplicated', 'info');
}

window.deleteSelected = () => deleteLayer(selectedLayerId);

function deleteLayer(id) {
    const l = projectData.layers[id]; if (!l) return;
    if (l.leafletLayer) map.removeLayer(l.leafletLayer);
    l.vertexMarkers.forEach(m => map.removeLayer(m));
    delete projectData.layers[id];
    projectData.folders.forEach(f => { f.items = f.items.filter(i => i !== id); });
    if (selectedLayerId === id) selectedLayerId = null;
    renderAll(); updatePropsPanel(); toast('Deleted', 'info'); updateStatus();
}

window.clearProject = function() {
    if (!confirm('Clear all layers and folders?')) return;
    Object.values(projectData.layers).forEach(l => {
        if (l.leafletLayer) map.removeLayer(l.leafletLayer);
        l.vertexMarkers.forEach(m => map.removeLayer(m));
    });
    projectData = { folders: [], layers: {} };
    selectedLayerId = null;
    renderAll(); updatePropsPanel();
    document.getElementById('emptyState').classList.remove('hidden');
    updateStatus(); toast('Cleared', 'info');
};

// === EXPORT KML ===
window.saveKML = function() {
    downloadFile(buildKML(), 'neximap_export.kml', 'application/vnd.google-earth.kml+xml');
    toast('KML saved', 'success');
};

function buildKML() {
    let k = '<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n';
    k += '  <name>NexiMap KML Studio Export</name>\n';
    projectData.folders.filter(f => !f.parentId).forEach(f => { k += buildKMLFolder(f, '  '); });
    k += '</Document>\n</kml>';
    return k;
}

function buildKMLFolder(folder, ind) {
    let k = ind + '<Folder>\n' + ind + '  <name>' + escXml(folder.name) + '</name>\n';
    projectData.folders.filter(f => f.parentId === folder.id).forEach(sf => { k += buildKMLFolder(sf, ind + '  '); });
    folder.items.forEach(id => {
        if (projectData.folders.find(f => f.id === id)) return;
        const l = projectData.layers[id]; if (!l) return;
        k += buildPM(l, ind + '  ');
    });
    k += ind + '</Folder>\n';
    return k;
}

function buildPM(l, ind) {
    const a = Math.round(l.opacity * 255).toString(16).padStart(2, '0');
    const r = l.color.substr(1, 2), g = l.color.substr(3, 2), b = l.color.substr(5, 2);
    let k = ind + '<Placemark>\n' + ind + '  <name>' + escXml(l.name) + '</name>\n';
    k += ind + '  <Style><LineStyle><color>' + a + b + g + r + '</color><width>' + l.width + '</width></LineStyle></Style>\n';
    if (l.type === 'line') {
        k += ind + '  <LineString><coordinates>\n';
        l.coords.forEach(c => { k += ind + '    ' + c[1] + ',' + c[0] + ',0\n'; });
        k += ind + '  </coordinates></LineString>\n';
    } else {
        k += ind + '  <Point><coordinates>' + l.coords[0][1] + ',' + l.coords[0][0] + ',0</coordinates></Point>\n';
    }
    k += ind + '</Placemark>\n';
    return k;
}

// === EXPORT GEOJSON ===
window.exportSimplifiedGeoJSON = function() {
    const features = [];
    Object.values(projectData.layers).forEach(l => {
        if (l.type !== 'line') return;
        features.push({
            type: 'Feature',
            properties: { name: l.name, stroke: l.color, 'stroke-width': l.width, 'stroke-opacity': l.opacity,
                originalPoints: l.originalCoords.length, simplifiedPoints: l.coords.length },
            geometry: { type: 'LineString', coordinates: l.coords.map(c => [c[1], c[0]]) }
        });
    });
    if (!features.length) { toast('No lines to export', 'error'); return; }
    const gj = { type: 'FeatureCollection',
        properties: { generator: 'NexiMap KML Studio v1.2', exportDate: new Date().toISOString() },
        features };
    const name = 'Simplified_GeoJSON_' + getProjectName() + '.geojson';
    downloadFile(JSON.stringify(gj, null, 2), name, 'application/geo+json');
    toast('Exported ' + features.length + ' lines as GeoJSON', 'success');
};

function getProjectName() {
    const rf = projectData.folders.filter(f => !f.parentId);
    if (rf.length === 1) return rf[0].name.replace(/[^a-zA-Z0-9_-]/g, '_');
    return rf.length > 1 ? 'merged_' + rf.length : 'export';
}

// === MENUS ===
window.toggleMenu = function(id, btn) {
    const m = document.getElementById(id);
    const wasOpen = m.classList.contains('show');
    closeMenus();
    if (!wasOpen) {
        const rect = btn.getBoundingClientRect();
        m.style.left = rect.left + 'px';
        m.style.top = rect.bottom + 2 + 'px';
        m.classList.add('show');
        event.stopPropagation();
    }
};
window.closeMenus = function() {
    document.querySelectorAll('.menu-dropdown').forEach(m => m.classList.remove('show'));
};

// === KEYBOARD SHORTCUTS ===
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'o') { e.preventDefault(); openKMLFile(); }
    if (e.ctrlKey && e.key === 's') { e.preventDefault(); saveKML(); }
    if (e.key === 'Delete' && selectedLayerId) { deleteSelected(); }
    if (e.key === 'Escape') { if (editMode) toggleEditMode(); if (addPointMode) toggleAddPointMode(); }
});

// === UTILS ===
function downloadFile(content, filename, mime) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([content], { type: mime }));
    a.download = filename;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
}
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
function escXml(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); }

function toast(msg, type) {
    const c = document.getElementById('toastContainer');
    const t = document.createElement('div');
    t.className = 'toast ' + (type || 'info');
    t.textContent = msg;
    c.appendChild(t);
    setTimeout(() => { t.style.opacity = '0'; t.style.transition = 'opacity 0.3s'; setTimeout(() => t.remove(), 300); }, 3000);
}

function updateStatus() {
    const lc = Object.keys(projectData.layers).length;
    const tp = Object.values(projectData.layers).reduce((s, l) => s + l.coords.length, 0);
    document.getElementById('statusText').textContent = lc + ' layers ¬∑ ' + tp.toLocaleString() + ' vertices';
}

// Resize handle
const leftResize = document.getElementById('leftResize');
leftResize.addEventListener('mousedown', () => {
    const onMove = (e) => {
        document.getElementById('leftPanel').style.width = Math.max(180, Math.min(400, e.clientX)) + 'px';
    };
    const onUp = () => { document.removeEventListener('mousemove', onMove); map.invalidateSize(); };
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp, { once: true });
});

updateStatus();

} // end initApp
</script>
</body>
</html>
