<!DOCTYPE html>
<!-- NexiMap KML Studio v1.0 -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NexiMap KML Studio v1.0</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
      onerror="this.href='https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css'"/>
<script>
// Multi-CDN Leaflet loader with fallback
function loadScript(url) {
    return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
    });
}

async function loadLeaflet() {
    const cdns = [
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
        'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js',
        'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js'
    ];
    for (const url of cdns) {
        try {
            await loadScript(url);
            if (typeof L !== 'undefined') {
                console.log('Leaflet loaded from:', url);
                return true;
            }
        } catch(e) { console.warn('CDN failed:', url); }
    }
    return false;
}
</script>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap');

:root {
    --bg-primary: #0a0e17;
    --bg-secondary: #111827;
    --bg-tertiary: #1a2236;
    --bg-panel: #0f1525;
    --border: #1e2d4a;
    --border-active: #3b82f6;
    --text-primary: #e2e8f0;
    --text-secondary: #94a3b8;
    --text-muted: #64748b;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --accent-glow: rgba(59, 130, 246, 0.15);
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --orange: #f97316;
    --purple: #8b5cf6;
    --cyan: #06b6d4;
    --folder-bg: #1a2236;
    --item-hover: rgba(59, 130, 246, 0.08);
    --item-selected: rgba(59, 130, 246, 0.15);
    --scrollbar-track: #111827;
    --scrollbar-thumb: #2a3a5c;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'IBM Plex Sans', sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
    height: 100vh;
    width: 100vw;
}

/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--scrollbar-track); }
::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #3a4a6c; }

/* === TOP BAR === */
#topBar {
    height: 44px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 16px;
    gap: 12px;
    z-index: 1000;
    position: relative;
}

#topBar .logo {
    font-family: 'JetBrains Mono', monospace;
    font-weight: 700;
    font-size: 14px;
    color: var(--accent);
    letter-spacing: -0.5px;
    white-space: nowrap;
}

#topBar .logo span {
    color: var(--text-muted);
    font-weight: 400;
    font-size: 11px;
    margin-left: 6px;
}

.toolbar-divider {
    width: 1px;
    height: 24px;
    background: var(--border);
}

.tb-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--text-secondary);
    font-family: 'IBM Plex Sans', sans-serif;
    font-size: 12px;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: all 0.15s;
    white-space: nowrap;
}

.tb-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
    border-color: var(--border);
}

.tb-btn.active {
    background: var(--accent-glow);
    color: var(--accent);
    border-color: var(--accent);
}

.tb-btn svg { width: 14px; height: 14px; }

.tb-spacer { flex: 1; }

#statusText {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--text-muted);
}

/* === MAIN LAYOUT === */
#mainLayout {
    display: flex;
    height: calc(100vh - 44px);
}

/* === LEFT PANEL: FOLDER TREE === */
#leftPanel {
    width: 280px;
    min-width: 200px;
    max-width: 450px;
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    position: relative;
}

#leftPanelHeader {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

#leftPanelHeader h3 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
}

.panel-actions {
    display: flex;
    gap: 4px;
}

.panel-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 3px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    transition: all 0.15s;
}

.panel-btn:hover {
    color: var(--text-primary);
    background: var(--bg-tertiary);
}

.panel-btn svg { width: 14px; height: 14px; }

#folderTree {
    flex: 1;
    overflow-y: auto;
    padding: 6px 0;
}

/* Tree items */
.tree-folder {
    user-select: none;
}

.tree-folder-header {
    display: flex;
    align-items: center;
    padding: 4px 8px 4px 0;
    cursor: pointer;
    border-radius: 3px;
    margin: 1px 4px;
    transition: background 0.1s;
    gap: 2px;
}

.tree-folder-header:hover { background: var(--item-hover); }
.tree-folder-header.selected { background: var(--item-selected); }

.tree-toggle {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 10px;
    flex-shrink: 0;
    transition: transform 0.15s;
}

.tree-toggle.collapsed { transform: rotate(-90deg); }

.tree-folder-icon {
    width: 16px;
    height: 16px;
    margin-right: 5px;
    flex-shrink: 0;
}

.tree-folder-name {
    font-size: 12px;
    font-weight: 500;
    color: var(--text-primary);
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.tree-folder-count {
    font-size: 10px;
    color: var(--text-muted);
    font-family: 'JetBrains Mono', monospace;
    margin-left: 4px;
}

.tree-folder-children {
    padding-left: 16px;
}

.tree-folder-children.hidden { display: none; }

.tree-item {
    display: flex;
    align-items: center;
    padding: 3px 8px 3px 22px;
    cursor: pointer;
    border-radius: 3px;
    margin: 1px 4px;
    transition: background 0.1s;
    gap: 5px;
}

.tree-item:hover { background: var(--item-hover); }
.tree-item.selected { background: var(--item-selected); }

.tree-item-color {
    width: 10px;
    height: 3px;
    border-radius: 2px;
    flex-shrink: 0;
}

.tree-item-name {
    font-size: 11.5px;
    color: var(--text-secondary);
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.tree-item-pts {
    font-size: 10px;
    color: var(--text-muted);
    font-family: 'JetBrains Mono', monospace;
}

.tree-item-vis {
    width: 14px;
    height: 14px;
    cursor: pointer;
    color: var(--text-muted);
    flex-shrink: 0;
    display: flex;
    align-items: center;
}

.tree-item-vis.hidden-item { opacity: 0.3; }

/* Drag-over visual */
.drag-over { outline: 1px dashed var(--accent); outline-offset: -1px; }

/* Resize handle */
#leftResize {
    position: absolute;
    right: -3px;
    top: 0;
    bottom: 0;
    width: 6px;
    cursor: col-resize;
    z-index: 10;
}

#leftResize:hover, #leftResize.active {
    background: var(--accent);
    opacity: 0.3;
}

/* === MAP AREA === */
#mapContainer {
    flex: 1;
    position: relative;
}

#map {
    width: 100%;
    height: 100%;
    background: #0a0e17;
}

/* Leaflet overrides */
.leaflet-container { background: #0a0e17 !important; }

/* === RIGHT PANEL: PROPERTIES === */
#rightPanel {
    width: 260px;
    min-width: 200px;
    max-width: 400px;
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

#rightPanelHeader {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
}

#rightPanelHeader h3 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
}

.prop-section {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
}

.prop-section h4 {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    margin-bottom: 8px;
}

.prop-row {
    display: flex;
    align-items: center;
    margin-bottom: 6px;
    gap: 8px;
}

.prop-label {
    font-size: 11px;
    color: var(--text-secondary);
    width: 65px;
    flex-shrink: 0;
}

.prop-input {
    flex: 1;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-family: 'IBM Plex Sans', sans-serif;
    font-size: 11px;
    padding: 4px 7px;
    border-radius: 3px;
    outline: none;
    transition: border-color 0.15s;
}

.prop-input:focus { border-color: var(--accent); }

.prop-input[type="color"] {
    width: 32px;
    height: 26px;
    padding: 2px;
    cursor: pointer;
}

.prop-input[type="range"] {
    -webkit-appearance: none;
    height: 4px;
    background: var(--border);
    border: none;
    border-radius: 2px;
    padding: 0;
}

.prop-input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
}

.prop-range-val {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-muted);
    width: 28px;
    text-align: right;
}

.prop-btn {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    font-family: 'IBM Plex Sans', sans-serif;
    font-size: 11px;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
    width: 100%;
    text-align: center;
}

.prop-btn:hover {
    background: var(--accent-glow);
    color: var(--accent);
    border-color: var(--accent);
}

.prop-btn.danger:hover {
    background: rgba(239,68,68,0.1);
    color: var(--danger);
    border-color: var(--danger);
}

.prop-btn.success {
    background: rgba(16,185,129,0.1);
    color: var(--success);
    border-color: rgba(16,185,129,0.3);
}

.prop-btn.success:hover {
    border-color: var(--success);
}

/* Simplification preview */
#simplifyPreview {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-muted);
    padding: 4px 0;
    line-height: 1.6;
}

/* === MODALS === */
.modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 5000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s;
}

.modal-overlay.show {
    opacity: 1;
    visibility: visible;
}

.modal {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 20px;
    min-width: 380px;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}

.modal h2 {
    font-size: 15px;
    font-weight: 600;
    margin-bottom: 12px;
    color: var(--text-primary);
}

.modal p {
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 10px;
    line-height: 1.5;
}

.modal-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 16px;
}

.modal-btn {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    font-family: 'IBM Plex Sans', sans-serif;
    font-size: 12px;
    padding: 6px 16px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
}

.modal-btn:hover {
    color: var(--text-primary);
    border-color: var(--text-muted);
}

.modal-btn.primary {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
}

.modal-btn.primary:hover { background: var(--accent-hover); }

/* === TOAST NOTIFICATIONS === */
#toastContainer {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 6000;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.toast {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 16px;
    font-size: 12px;
    color: var(--text-primary);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    animation: toastIn 0.3s ease;
    max-width: 320px;
}

.toast.success { border-left: 3px solid var(--success); }
.toast.error { border-left: 3px solid var(--danger); }
.toast.info { border-left: 3px solid var(--accent); }

@keyframes toastIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Vertex markers */
.vertex-marker {
    width: 10px;
    height: 10px;
    background: #fff;
    border: 2px solid var(--accent);
    border-radius: 50%;
    cursor: grab;
    transition: transform 0.1s;
}

.vertex-marker:hover {
    transform: scale(1.4);
}

.vertex-marker.dragging {
    cursor: grabbing;
    background: var(--accent);
}

.vertex-marker-endpoint {
    width: 12px;
    height: 12px;
    background: var(--accent);
    border: 2px solid #fff;
    border-radius: 50%;
    cursor: grab;
}

/* Hidden file input */
#fileInput { display: none; }
#mergeFileInput { display: none; }

/* Empty state */
#emptyState {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 400;
    pointer-events: none;
}

#emptyState.hidden { display: none; }

#emptyState .empty-icon {
    width: 64px;
    height: 64px;
    color: var(--text-muted);
    opacity: 0.3;
    margin-bottom: 16px;
}

#emptyState p {
    font-size: 13px;
    color: var(--text-muted);
    opacity: 0.6;
    text-align: center;
    line-height: 1.6;
}

#emptyState .hint {
    font-size: 11px;
    margin-top: 4px;
}

/* Context menu */
.ctx-menu {
    position: fixed;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 4px 0;
    min-width: 160px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.4);
    z-index: 7000;
    display: none;
}

.ctx-menu.show { display: block; }

.ctx-item {
    padding: 6px 12px;
    font-size: 12px;
    color: var(--text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background 0.1s;
}

.ctx-item:hover {
    background: var(--item-hover);
    color: var(--text-primary);
}

.ctx-item.danger { color: var(--danger); }
.ctx-item.danger:hover { background: rgba(239,68,68,0.1); }

.ctx-sep {
    height: 1px;
    background: var(--border);
    margin: 4px 0;
}
</style>
</head>
<body>

<!-- TOP BAR -->
<div id="topBar">
    <div class="logo">NexiMap KML Studio<span>v1.0</span></div>
    <div class="toolbar-divider"></div>
    <button class="tb-btn" onclick="openKMLFile()" title="Open KML file">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
        Open KML
    </button>
    <button class="tb-btn" onclick="openMergeFiles()" title="Merge multiple KML files">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="8" height="10" rx="1"/><rect x="14" y="7" width="8" height="10" rx="1"/><path d="M10 12h4"/></svg>
        Merge KMLs
    </button>
    <div class="toolbar-divider"></div>
    <button class="tb-btn" onclick="saveKML()" title="Save as KML">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/></svg>
        Save KML
    </button>
    <button class="tb-btn" onclick="exportSimplifiedGeoJSON()" title="Export simplified GeoJSON for NexiMap">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
        Export GeoJSON
    </button>
    <div class="toolbar-divider"></div>
    <button class="tb-btn" id="btnEditMode" onclick="toggleEditMode()" title="Toggle vertex editing mode">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
        Edit Vertices
    </button>
    <button class="tb-btn" id="btnAddPoint" onclick="toggleAddPointMode()" title="Click on map to add points">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
        Add Point
    </button>
    <div class="tb-spacer"></div>
    <span id="statusText">Ready</span>
</div>

<!-- MAIN LAYOUT -->
<div id="mainLayout">
    <!-- LEFT PANEL -->
    <div id="leftPanel">
        <div id="leftPanelHeader">
            <h3>Layers &amp; Folders</h3>
            <div class="panel-actions">
                <button class="panel-btn" onclick="createNewFolder()" title="New folder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                </button>
                <button class="panel-btn" onclick="selectAllItems()" title="Select all">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>
                </button>
            </div>
        </div>
        <div id="folderTree"></div>
        <div id="leftResize"></div>
    </div>

    <!-- MAP -->
    <div id="mapContainer">
        <div id="map"></div>
        <div id="emptyState">
            <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                <circle cx="12" cy="10" r="3"/>
            </svg>
            <p>Open a KML file to begin<br><span class="hint">or drag &amp; drop a .kml file onto the map</span></p>
        </div>
    </div>

    <!-- RIGHT PANEL -->
    <div id="rightPanel">
        <div id="rightPanelHeader"><h3>Properties</h3></div>
        <div id="propsContent">
            <div class="prop-section" id="propNone">
                <p style="font-size:11px;color:var(--text-muted);text-align:center;padding:20px 0;">Select a layer to edit its properties</p>
            </div>
            <div class="prop-section" id="propName" style="display:none;">
                <h4>Layer</h4>
                <div class="prop-row">
                    <span class="prop-label">Name</span>
                    <input class="prop-input" type="text" id="propNameInput" onchange="updateSelectedName(this.value)">
                </div>
                <div class="prop-row">
                    <span class="prop-label">Points</span>
                    <span id="propPointCount" style="font-family:'JetBrains Mono';font-size:11px;color:var(--text-muted);">0</span>
                </div>
            </div>
            <div class="prop-section" id="propStyle" style="display:none;">
                <h4>Line Style</h4>
                <div class="prop-row">
                    <span class="prop-label">Color</span>
                    <input class="prop-input" type="color" id="propColor" value="#3b82f6" onchange="updateSelectedColor(this.value)">
                </div>
                <div class="prop-row">
                    <span class="prop-label">Width</span>
                    <input class="prop-input" type="range" id="propWidth" min="1" max="10" value="3" oninput="updateSelectedWidth(this.value)">
                    <span class="prop-range-val" id="propWidthVal">3</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">Opacity</span>
                    <input class="prop-input" type="range" id="propOpacity" min="0.1" max="1" step="0.05" value="0.9" oninput="updateSelectedOpacity(this.value)">
                    <span class="prop-range-val" id="propOpacityVal">0.9</span>
                </div>
            </div>
            <div class="prop-section" id="propSimplify" style="display:none;">
                <h4>Simplification</h4>
                <div class="prop-row">
                    <span class="prop-label">Tolerance</span>
                    <input class="prop-input" type="range" id="propTolerance" min="0.0001" max="0.1" step="0.0001" value="0.001" oninput="previewSimplify(this.value)">
                    <span class="prop-range-val" id="propToleranceVal">0.001</span>
                </div>
                <div id="simplifyPreview"></div>
                <button class="prop-btn success" onclick="applySimplify()">Apply Simplification</button>
                <div style="height:6px;"></div>
                <button class="prop-btn" onclick="undoSimplify()">Undo Simplification</button>
            </div>
            <div class="prop-section" id="propActions" style="display:none;">
                <h4>Actions</h4>
                <button class="prop-btn" onclick="zoomToSelected()">Zoom to Layer</button>
                <div style="height:6px;"></div>
                <button class="prop-btn" onclick="duplicateSelected()">Duplicate</button>
                <div style="height:6px;"></div>
                <button class="prop-btn danger" onclick="deleteSelected()">Delete Layer</button>
            </div>
        </div>
    </div>
</div>

<!-- CONTEXT MENU -->
<div class="ctx-menu" id="ctxMenu">
    <div class="ctx-item" onclick="ctxRename()">Rename</div>
    <div class="ctx-item" onclick="ctxDuplicate()">Duplicate</div>
    <div class="ctx-item" onclick="ctxZoomTo()">Zoom to</div>
    <div class="ctx-sep"></div>
    <div class="ctx-item" onclick="ctxMoveToFolder()">Move to folder…</div>
    <div class="ctx-sep"></div>
    <div class="ctx-item danger" onclick="ctxDelete()">Delete</div>
</div>

<!-- TOASTS -->
<div id="toastContainer"></div>

<!-- FILE INPUTS -->
<input type="file" id="fileInput" accept=".kml" onchange="handleFileOpen(event)">
<input type="file" id="mergeFileInput" accept=".kml" multiple onchange="handleMergeFiles(event)">

<!-- MODAL -->
<div class="modal-overlay" id="modalOverlay">
    <div class="modal" id="modalContent"></div>
</div>

<script>
// ============================================================
// NexiMap KML Studio v1.0 — Core Application
// ============================================================

(async function() {
    // Wait for Leaflet
    const loaded = await loadLeaflet();
    if (!loaded) {
        document.getElementById('emptyState').innerHTML = `
            <p style="color:#ef4444;font-size:14px;padding:20px;">
                <strong>Failed to load Leaflet map library.</strong><br><br>
                Please check your internet connection and reload.<br>
                The app requires Leaflet.js from a CDN.
            </p>`;
        return;
    }

// === DATA MODEL ===
let projectData = {
    folders: [],  // { id, name, expanded, items: [layerId...] }
    layers: {},   // layerId -> { id, name, coords, originalCoords, color, width, opacity, visible, folderId, leafletLayer, vertexMarkers }
};

let nextId = 1;
const genId = () => `layer_${nextId++}`;
const genFolderId = () => `folder_${nextId++}`;

let selectedLayerId = null;
let selectedFolderIds = new Set();
let editMode = false;
let addPointMode = false;
let ctxTargetId = null;

// === MAP INIT ===
const map = L.map('map', {
    center: [20, 0],
    zoom: 3,
    zoomControl: true,
    attributionControl: false
});

// Dark tile layer
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 19,
    subdomains: 'abcd'
}).addTo(map);

L.control.attribution({ position: 'bottomright', prefix: 'NexiMap KML Studio' }).addTo(map);

// === FILE I/O ===
function openKMLFile() {
    document.getElementById('fileInput').click();
}

function openMergeFiles() {
    document.getElementById('mergeFileInput').click();
}

function handleFileOpen(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try {
            importKML(ev.target.result, file.name);
            toast(`Opened ${file.name}`, 'success');
        } catch (err) {
            toast(`Error parsing KML: ${err.message}`, 'error');
        }
    };
    reader.readAsText(file);
    e.target.value = '';
}

function handleMergeFiles(e) {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;
    let loaded = 0;
    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                importKML(ev.target.result, file.name);
                loaded++;
                if (loaded === files.length) {
                    toast(`Merged ${files.length} KML files`, 'success');
                }
            } catch (err) {
                toast(`Error in ${file.name}: ${err.message}`, 'error');
            }
        };
        reader.readAsText(file);
    });
    e.target.value = '';
}

// Drag and drop support
const mapContainer = document.getElementById('mapContainer');
mapContainer.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); });
mapContainer.addEventListener('drop', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.kml'));
    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                importKML(ev.target.result, file.name);
                toast(`Loaded ${file.name}`, 'success');
            } catch (err) {
                toast(`Error: ${err.message}`, 'error');
            }
        };
        reader.readAsText(file);
    });
});

// === KML PARSER ===
function importKML(kmlString, fileName) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(kmlString, 'text/xml');

    // Create a folder for this file
    const folderId = genFolderId();
    const folderName = fileName.replace(/\.kml$/i, '');
    const folder = { id: folderId, name: folderName, expanded: true, items: [] };

    // Parse KML folders
    const kmlFolders = doc.querySelectorAll('Folder');
    if (kmlFolders.length > 0) {
        kmlFolders.forEach(kf => {
            const subFolderName = getKmlText(kf, 'name') || 'Unnamed Folder';
            const subFolderId = genFolderId();
            const subFolder = { id: subFolderId, name: subFolderName, expanded: true, items: [], parentId: folderId };
            
            // Parse placemarks within this folder
            const placemarks = kf.querySelectorAll(':scope > Placemark');
            placemarks.forEach(pm => {
                const layer = parsePlacemark(pm, subFolderId);
                if (layer) {
                    subFolder.items.push(layer.id);
                    projectData.layers[layer.id] = layer;
                }
            });

            if (subFolder.items.length > 0) {
                projectData.folders.push(subFolder);
                folder.items.push(subFolderId);
            }
        });
    }

    // Parse root-level placemarks
    const rootPlacemarks = doc.querySelectorAll('Document > Placemark, kml > Placemark');
    rootPlacemarks.forEach(pm => {
        const layer = parsePlacemark(pm, folderId);
        if (layer) {
            folder.items.push(layer.id);
            projectData.layers[layer.id] = layer;
        }
    });

    // If no folders were found with placemarks, try all placemarks
    if (Object.keys(projectData.layers).length === 0 || folder.items.length === 0) {
        const allPms = doc.querySelectorAll('Placemark');
        allPms.forEach(pm => {
            const layer = parsePlacemark(pm, folderId);
            if (layer) {
                folder.items.push(layer.id);
                projectData.layers[layer.id] = layer;
            }
        });
    }

    projectData.folders.push(folder);
    renderAll();
    zoomToAll();
    document.getElementById('emptyState').classList.add('hidden');
    updateStatus();
}

function parsePlacemark(pm, folderId) {
    const name = getKmlText(pm, 'name') || 'Unnamed';
    
    // Try LineString first
    let coordsEl = pm.querySelector('LineString coordinates');
    let type = 'line';
    
    // Try Point
    if (!coordsEl) {
        coordsEl = pm.querySelector('Point coordinates');
        type = 'point';
    }
    
    // Try MultiGeometry
    if (!coordsEl) {
        const multiCoords = pm.querySelectorAll('MultiGeometry LineString coordinates');
        if (multiCoords.length > 0) {
            // Combine all linestrings
            let allCoords = [];
            multiCoords.forEach(c => {
                allCoords = allCoords.concat(parseCoordinateString(c.textContent));
            });
            if (allCoords.length > 0) {
                const style = parseStyle(pm);
                const id = genId();
                return {
                    id, name, type: 'line', coords: allCoords,
                    originalCoords: JSON.parse(JSON.stringify(allCoords)),
                    color: style.color, width: style.width, opacity: style.opacity,
                    visible: true, folderId, leafletLayer: null, vertexMarkers: []
                };
            }
        }
        return null;
    }

    const coords = parseCoordinateString(coordsEl.textContent);
    if (coords.length === 0) return null;

    const style = parseStyle(pm);
    const id = genId();

    return {
        id, name, type, coords,
        originalCoords: JSON.parse(JSON.stringify(coords)),
        color: style.color, width: style.width, opacity: style.opacity,
        visible: true, folderId, leafletLayer: null, vertexMarkers: []
    };
}

function parseCoordinateString(str) {
    return str.trim().split(/\s+/).map(s => {
        const parts = s.split(',');
        if (parts.length >= 2) {
            return [parseFloat(parts[1]), parseFloat(parts[0])]; // [lat, lng]
        }
        return null;
    }).filter(c => c && !isNaN(c[0]) && !isNaN(c[1]));
}

function parseStyle(pm) {
    let color = '#3b82f6';
    let width = 3;
    let opacity = 0.9;

    const styleEl = pm.querySelector('Style LineStyle');
    if (styleEl) {
        const kmlColor = getKmlText(styleEl, 'color');
        if (kmlColor && kmlColor.length === 8) {
            // KML color: aabbggrr
            const a = parseInt(kmlColor.substr(0, 2), 16) / 255;
            const b = kmlColor.substr(2, 2);
            const g = kmlColor.substr(4, 2);
            const r = kmlColor.substr(6, 2);
            color = '#' + r + g + b;
            opacity = Math.round(a * 100) / 100;
        }
        const w = getKmlText(styleEl, 'width');
        if (w) width = parseFloat(w);
    }

    return { color, width, opacity };
}

function getKmlText(parent, tagName) {
    const el = parent.querySelector(':scope > ' + tagName);
    return el ? el.textContent.trim() : null;
}

// === RENDERING ===
function renderAll() {
    renderFolderTree();
    renderMapLayers();
}

function renderMapLayers() {
    // Clear existing
    Object.values(projectData.layers).forEach(layer => {
        if (layer.leafletLayer) { map.removeLayer(layer.leafletLayer); }
        layer.vertexMarkers.forEach(m => map.removeLayer(m));
        layer.vertexMarkers = [];
    });

    // Draw
    Object.values(projectData.layers).forEach(layer => {
        if (!layer.visible) return;
        if (layer.type === 'line' && layer.coords.length > 1) {
            layer.leafletLayer = L.polyline(layer.coords, {
                color: layer.color,
                weight: layer.width,
                opacity: layer.opacity,
                interactive: true
            }).addTo(map);

            layer.leafletLayer.on('click', () => {
                selectLayer(layer.id);
            });
        } else if (layer.type === 'point' && layer.coords.length > 0) {
            layer.leafletLayer = L.circleMarker(layer.coords[0], {
                radius: 5,
                color: layer.color,
                fillColor: layer.color,
                fillOpacity: layer.opacity,
                weight: 2
            }).addTo(map);
            layer.leafletLayer.on('click', () => selectLayer(layer.id));
        }

        // Vertex markers if in edit mode and selected
        if (editMode && layer.id === selectedLayerId && layer.type === 'line') {
            renderVertexMarkers(layer);
        }
    });
}

function renderVertexMarkers(layer) {
    layer.vertexMarkers.forEach(m => map.removeLayer(m));
    layer.vertexMarkers = [];

    layer.coords.forEach((coord, idx) => {
        const isEndpoint = idx === 0 || idx === layer.coords.length - 1;
        const icon = L.divIcon({
            className: isEndpoint ? 'vertex-marker-endpoint' : 'vertex-marker',
            iconSize: isEndpoint ? [12, 12] : [10, 10],
            iconAnchor: isEndpoint ? [6, 6] : [5, 5]
        });

        const marker = L.marker(coord, {
            icon: icon,
            draggable: true,
            zIndexOffset: 1000
        }).addTo(map);

        marker.on('dragstart', () => {
            marker.getElement().classList.add('dragging');
        });

        marker.on('drag', (e) => {
            const latlng = e.target.getLatLng();
            layer.coords[idx] = [latlng.lat, latlng.lng];
            if (layer.leafletLayer) {
                layer.leafletLayer.setLatLngs(layer.coords);
            }
        });

        marker.on('dragend', (e) => {
            marker.getElement().classList.remove('dragging');
            const latlng = e.target.getLatLng();
            layer.coords[idx] = [latlng.lat, latlng.lng];
            updateStatus();
        });

        // Right-click to delete vertex
        marker.on('contextmenu', (e) => {
            L.DomEvent.stopPropagation(e);
            if (layer.coords.length > 2) {
                layer.coords.splice(idx, 1);
                renderMapLayers();
                toast(`Removed vertex ${idx + 1}`, 'info');
                updateStatus();
            }
        });

        layer.vertexMarkers.push(marker);
    });
}

// === FOLDER TREE ===
function renderFolderTree() {
    const container = document.getElementById('folderTree');
    container.innerHTML = '';

    // Get root folders (those without parentId)
    const rootFolders = projectData.folders.filter(f => !f.parentId);

    rootFolders.forEach(folder => {
        container.appendChild(createFolderElement(folder));
    });
}

function createFolderElement(folder) {
    const div = document.createElement('div');
    div.className = 'tree-folder';
    div.dataset.folderId = folder.id;

    // Header
    const header = document.createElement('div');
    header.className = 'tree-folder-header';
    if (selectedFolderIds.has(folder.id)) header.classList.add('selected');
    
    const itemCount = countFolderItems(folder);

    header.innerHTML = `
        <span class="tree-toggle ${folder.expanded ? '' : 'collapsed'}">▼</span>
        <svg class="tree-folder-icon" viewBox="0 0 24 24" fill="none" stroke="${folder.expanded ? '#f59e0b' : '#64748b'}" stroke-width="2">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
        </svg>
        <span class="tree-folder-name">${escHtml(folder.name)}</span>
        <span class="tree-folder-count">${itemCount}</span>
    `;

    header.addEventListener('click', (e) => {
        if (e.ctrlKey || e.metaKey) {
            if (selectedFolderIds.has(folder.id)) selectedFolderIds.delete(folder.id);
            else selectedFolderIds.add(folder.id);
        } else {
            folder.expanded = !folder.expanded;
        }
        renderFolderTree();
    });

    header.addEventListener('dblclick', () => {
        const input = document.createElement('input');
        input.className = 'prop-input';
        input.value = folder.name;
        input.style.cssText = 'width:100%;font-size:12px;';
        const nameSpan = header.querySelector('.tree-folder-name');
        nameSpan.replaceWith(input);
        input.focus();
        input.select();
        input.addEventListener('blur', () => {
            folder.name = input.value || folder.name;
            renderFolderTree();
        });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') input.blur();
        });
    });

    div.appendChild(header);

    // Children container
    const children = document.createElement('div');
    children.className = `tree-folder-children ${folder.expanded ? '' : 'hidden'}`;

    // Sub-folders
    const subFolders = projectData.folders.filter(f => f.parentId === folder.id);
    subFolders.forEach(sf => {
        children.appendChild(createFolderElement(sf));
    });

    // Layer items
    folder.items.forEach(itemId => {
        // Skip if it's a subfolder reference
        if (projectData.folders.find(f => f.id === itemId)) return;
        const layer = projectData.layers[itemId];
        if (!layer) return;

        const item = document.createElement('div');
        item.className = 'tree-item';
        if (selectedLayerId === layer.id) item.classList.add('selected');
        item.dataset.layerId = layer.id;
        item.draggable = true;

        item.innerHTML = `
            <span class="tree-item-color" style="background:${layer.color}"></span>
            <span class="tree-item-name">${escHtml(layer.name)}</span>
            <span class="tree-item-pts">${layer.coords.length}pt</span>
            <span class="tree-item-vis ${layer.visible ? '' : 'hidden-item'}" data-id="${layer.id}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${layer.visible
                        ? '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'
                        : '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>'
                    }
                </svg>
            </span>
        `;

        item.addEventListener('click', (e) => {
            if (e.target.closest('.tree-item-vis')) {
                layer.visible = !layer.visible;
                renderAll();
                return;
            }
            selectLayer(layer.id);
        });

        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            ctxTargetId = layer.id;
            showContextMenu(e.clientX, e.clientY);
        });

        item.addEventListener('dblclick', () => {
            const nameSpan = item.querySelector('.tree-item-name');
            const input = document.createElement('input');
            input.className = 'prop-input';
            input.value = layer.name;
            input.style.cssText = 'flex:1;font-size:11px;';
            nameSpan.replaceWith(input);
            input.focus();
            input.select();
            input.addEventListener('blur', () => {
                layer.name = input.value || layer.name;
                renderAll();
                updatePropsPanel();
            });
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') input.blur(); });
        });

        // Drag
        item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', layer.id);
            e.dataTransfer.effectAllowed = 'move';
        });

        children.appendChild(item);
    });

    // Drop target
    children.addEventListener('dragover', (e) => {
        e.preventDefault();
        header.classList.add('drag-over');
    });
    children.addEventListener('dragleave', () => {
        header.classList.remove('drag-over');
    });
    children.addEventListener('drop', (e) => {
        e.preventDefault();
        header.classList.remove('drag-over');
        const layerId = e.dataTransfer.getData('text/plain');
        moveLayerToFolder(layerId, folder.id);
    });

    div.appendChild(children);
    return div;
}

function countFolderItems(folder) {
    let count = folder.items.filter(id => projectData.layers[id]).length;
    const subFolders = projectData.folders.filter(f => f.parentId === folder.id);
    subFolders.forEach(sf => count += countFolderItems(sf));
    return count;
}

function moveLayerToFolder(layerId, targetFolderId) {
    // Remove from old folder
    projectData.folders.forEach(f => {
        f.items = f.items.filter(id => id !== layerId);
    });
    // Add to new folder
    const target = projectData.folders.find(f => f.id === targetFolderId);
    if (target) {
        target.items.push(layerId);
        const layer = projectData.layers[layerId];
        if (layer) layer.folderId = targetFolderId;
    }
    renderFolderTree();
    toast('Layer moved', 'info');
}

// === SELECTION ===
function selectLayer(id) {
    selectedLayerId = id;
    renderFolderTree();
    renderMapLayers();
    updatePropsPanel();
}

function updatePropsPanel() {
    const layer = projectData.layers[selectedLayerId];
    if (!layer) {
        document.getElementById('propNone').style.display = '';
        document.getElementById('propName').style.display = 'none';
        document.getElementById('propStyle').style.display = 'none';
        document.getElementById('propSimplify').style.display = 'none';
        document.getElementById('propActions').style.display = 'none';
        return;
    }

    document.getElementById('propNone').style.display = 'none';
    document.getElementById('propName').style.display = '';
    document.getElementById('propStyle').style.display = '';
    document.getElementById('propSimplify').style.display = layer.type === 'line' ? '' : 'none';
    document.getElementById('propActions').style.display = '';

    document.getElementById('propNameInput').value = layer.name;
    document.getElementById('propPointCount').textContent = `${layer.coords.length} vertices`;
    document.getElementById('propColor').value = layer.color;
    document.getElementById('propWidth').value = layer.width;
    document.getElementById('propWidthVal').textContent = layer.width;
    document.getElementById('propOpacity').value = layer.opacity;
    document.getElementById('propOpacityVal').textContent = layer.opacity;

    if (layer.type === 'line') {
        previewSimplify(document.getElementById('propTolerance').value);
    }
}

// === PROPERTY UPDATES ===
function updateSelectedName(val) {
    const layer = projectData.layers[selectedLayerId];
    if (layer) { layer.name = val; renderFolderTree(); }
}

function updateSelectedColor(val) {
    const layer = projectData.layers[selectedLayerId];
    if (layer) { layer.color = val; renderMapLayers(); renderFolderTree(); }
}

function updateSelectedWidth(val) {
    const layer = projectData.layers[selectedLayerId];
    if (layer) {
        layer.width = parseFloat(val);
        document.getElementById('propWidthVal').textContent = val;
        if (layer.leafletLayer) layer.leafletLayer.setStyle({ weight: layer.width });
    }
}

function updateSelectedOpacity(val) {
    const layer = projectData.layers[selectedLayerId];
    if (layer) {
        layer.opacity = parseFloat(val);
        document.getElementById('propOpacityVal').textContent = val;
        if (layer.leafletLayer) layer.leafletLayer.setStyle({ opacity: layer.opacity });
    }
}

// === SIMPLIFICATION (Douglas-Peucker) ===
function douglasPeucker(points, tolerance) {
    if (points.length <= 2) return points;

    let maxDist = 0;
    let maxIdx = 0;
    const first = points[0];
    const last = points[points.length - 1];

    for (let i = 1; i < points.length - 1; i++) {
        const d = perpendicularDist(points[i], first, last);
        if (d > maxDist) {
            maxDist = d;
            maxIdx = i;
        }
    }

    if (maxDist > tolerance) {
        const left = douglasPeucker(points.slice(0, maxIdx + 1), tolerance);
        const right = douglasPeucker(points.slice(maxIdx), tolerance);
        return left.slice(0, -1).concat(right);
    }

    return [first, last];
}

function perpendicularDist(point, lineStart, lineEnd) {
    const dx = lineEnd[1] - lineStart[1];
    const dy = lineEnd[0] - lineStart[0];
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) return Math.sqrt(Math.pow(point[0] - lineStart[0], 2) + Math.pow(point[1] - lineStart[1], 2));
    const u = ((point[1] - lineStart[1]) * dx + (point[0] - lineStart[0]) * dy) / (mag * mag);
    const closestX = lineStart[1] + u * dx;
    const closestY = lineStart[0] + u * dy;
    return Math.sqrt(Math.pow(point[0] - closestY, 2) + Math.pow(point[1] - closestX, 2));
}

function previewSimplify(tolerance) {
    tolerance = parseFloat(tolerance);
    document.getElementById('propToleranceVal').textContent = tolerance.toFixed(4);
    
    const layer = projectData.layers[selectedLayerId];
    if (!layer || layer.type !== 'line') return;

    const simplified = douglasPeucker(layer.coords, tolerance);
    const origCount = layer.originalCoords.length;
    const newCount = simplified.length;
    const reduction = ((1 - newCount / layer.coords.length) * 100).toFixed(1);

    document.getElementById('simplifyPreview').innerHTML =
        `Original: ${origCount} pts<br>Current: ${layer.coords.length} pts<br>After: ${newCount} pts (${reduction}% reduction)`;
}

function applySimplify() {
    const layer = projectData.layers[selectedLayerId];
    if (!layer || layer.type !== 'line') return;

    const tolerance = parseFloat(document.getElementById('propTolerance').value);
    layer.coords = douglasPeucker(layer.coords, tolerance);
    renderAll();
    updatePropsPanel();
    toast(`Simplified to ${layer.coords.length} points`, 'success');
    updateStatus();
}

function undoSimplify() {
    const layer = projectData.layers[selectedLayerId];
    if (!layer) return;
    layer.coords = JSON.parse(JSON.stringify(layer.originalCoords));
    renderAll();
    updatePropsPanel();
    toast('Restored original coordinates', 'info');
    updateStatus();
}

// === EDIT MODE ===
function toggleEditMode() {
    editMode = !editMode;
    addPointMode = false;
    document.getElementById('btnEditMode').classList.toggle('active', editMode);
    document.getElementById('btnAddPoint').classList.toggle('active', false);
    renderMapLayers();
    toast(editMode ? 'Edit mode ON — drag vertices to move them' : 'Edit mode OFF', 'info');
}

function toggleAddPointMode() {
    addPointMode = !addPointMode;
    if (addPointMode) editMode = true;
    document.getElementById('btnAddPoint').classList.toggle('active', addPointMode);
    document.getElementById('btnEditMode').classList.toggle('active', editMode);
    
    if (addPointMode && !selectedLayerId) {
        toast('Select a line layer first', 'error');
        addPointMode = false;
        document.getElementById('btnAddPoint').classList.remove('active');
        return;
    }
    
    toast(addPointMode ? 'Click on map to add points to selected line' : 'Add point mode OFF', 'info');
}

map.on('click', (e) => {
    if (!addPointMode) return;
    const layer = projectData.layers[selectedLayerId];
    if (!layer || layer.type !== 'line') return;

    // Find nearest segment and insert
    let minDist = Infinity;
    let insertIdx = layer.coords.length;

    for (let i = 0; i < layer.coords.length - 1; i++) {
        const d = distToSegment([e.latlng.lat, e.latlng.lng], layer.coords[i], layer.coords[i + 1]);
        if (d < minDist) {
            minDist = d;
            insertIdx = i + 1;
        }
    }

    layer.coords.splice(insertIdx, 0, [e.latlng.lat, e.latlng.lng]);
    renderMapLayers();
    updatePropsPanel();
    updateStatus();
});

function distToSegment(p, a, b) {
    const dx = b[1] - a[1], dy = b[0] - a[0];
    const lenSq = dx * dx + dy * dy;
    if (lenSq === 0) return Math.sqrt(Math.pow(p[0] - a[0], 2) + Math.pow(p[1] - a[1], 2));
    let t = ((p[1] - a[1]) * dx + (p[0] - a[0]) * dy) / lenSq;
    t = Math.max(0, Math.min(1, t));
    return Math.sqrt(Math.pow(p[0] - (a[0] + t * dy), 2) + Math.pow(p[1] - (a[1] + t * dx), 2));
}

// === FOLDER MANAGEMENT ===
function createNewFolder() {
    const folderId = genFolderId();
    projectData.folders.push({ id: folderId, name: 'New Folder', expanded: true, items: [] });
    renderFolderTree();
    toast('Created new folder', 'info');
}

function selectAllItems() {
    const allIds = Object.keys(projectData.layers);
    if (allIds.length > 0) {
        selectLayer(allIds[0]); // Select first for props panel
    }
}

// === CONTEXT MENU ===
function showContextMenu(x, y) {
    const menu = document.getElementById('ctxMenu');
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    menu.classList.add('show');
}

document.addEventListener('click', () => {
    document.getElementById('ctxMenu').classList.remove('show');
});

function ctxRename() {
    const layer = projectData.layers[ctxTargetId];
    if (!layer) return;
    const name = prompt('Rename layer:', layer.name);
    if (name) { layer.name = name; renderAll(); updatePropsPanel(); }
}

function ctxDuplicate() {
    duplicateLayer(ctxTargetId);
}

function ctxZoomTo() {
    const layer = projectData.layers[ctxTargetId];
    if (layer && layer.leafletLayer) {
        map.fitBounds(layer.leafletLayer.getBounds(), { padding: [40, 40] });
    }
}

function ctxMoveToFolder() {
    const folders = projectData.folders.filter(f => !f.parentId);
    const names = folders.map(f => f.name);
    const choice = prompt('Move to folder:\n' + names.map((n, i) => `${i + 1}. ${n}`).join('\n') + '\n\nEnter number:');
    if (choice) {
        const idx = parseInt(choice) - 1;
        if (idx >= 0 && idx < folders.length) {
            moveLayerToFolder(ctxTargetId, folders[idx].id);
        }
    }
}

function ctxDelete() {
    deleteLayer(ctxTargetId);
}

// === ACTIONS ===
function zoomToSelected() {
    const layer = projectData.layers[selectedLayerId];
    if (layer && layer.leafletLayer) {
        map.fitBounds(layer.leafletLayer.getBounds(), { padding: [40, 40] });
    }
}

function zoomToAll() {
    const allCoords = [];
    Object.values(projectData.layers).forEach(l => {
        l.coords.forEach(c => allCoords.push(c));
    });
    if (allCoords.length > 0) {
        map.fitBounds(L.latLngBounds(allCoords), { padding: [40, 40] });
    }
}

function duplicateSelected() {
    duplicateLayer(selectedLayerId);
}

function duplicateLayer(id) {
    const layer = projectData.layers[id];
    if (!layer) return;
    const newId = genId();
    const newLayer = {
        ...layer,
        id: newId,
        name: layer.name + ' (copy)',
        coords: JSON.parse(JSON.stringify(layer.coords)),
        originalCoords: JSON.parse(JSON.stringify(layer.originalCoords)),
        leafletLayer: null,
        vertexMarkers: []
    };
    projectData.layers[newId] = newLayer;
    const folder = projectData.folders.find(f => f.id === layer.folderId);
    if (folder) folder.items.push(newId);
    renderAll();
    toast('Layer duplicated', 'info');
}

function deleteSelected() {
    deleteLayer(selectedLayerId);
}

function deleteLayer(id) {
    const layer = projectData.layers[id];
    if (!layer) return;
    if (layer.leafletLayer) map.removeLayer(layer.leafletLayer);
    layer.vertexMarkers.forEach(m => map.removeLayer(m));
    delete projectData.layers[id];
    projectData.folders.forEach(f => {
        f.items = f.items.filter(i => i !== id);
    });
    if (selectedLayerId === id) selectedLayerId = null;
    renderAll();
    updatePropsPanel();
    toast('Layer deleted', 'info');
    updateStatus();
}

// === EXPORT: KML ===
function saveKML() {
    const kml = buildKML();
    downloadFile(kml, 'neximap_export.kml', 'application/vnd.google-earth.kml+xml');
    toast('KML saved', 'success');
}

function buildKML() {
    let kml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    kml += '<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n';
    kml += `  <name>NexiMap KML Studio Export</name>\n`;

    const rootFolders = projectData.folders.filter(f => !f.parentId);
    rootFolders.forEach(folder => {
        kml += buildKMLFolder(folder, '  ');
    });

    kml += '</Document>\n</kml>';
    return kml;
}

function buildKMLFolder(folder, indent) {
    let kml = `${indent}<Folder>\n`;
    kml += `${indent}  <name>${escXml(folder.name)}</name>\n`;

    // Sub-folders
    const subFolders = projectData.folders.filter(f => f.parentId === folder.id);
    subFolders.forEach(sf => {
        kml += buildKMLFolder(sf, indent + '  ');
    });

    // Layers
    folder.items.forEach(itemId => {
        if (projectData.folders.find(f => f.id === itemId)) return;
        const layer = projectData.layers[itemId];
        if (!layer) return;
        kml += buildKMLPlacemark(layer, indent + '  ');
    });

    kml += `${indent}</Folder>\n`;
    return kml;
}

function buildKMLPlacemark(layer, indent) {
    let kml = `${indent}<Placemark>\n`;
    kml += `${indent}  <name>${escXml(layer.name)}</name>\n`;

    // Style
    const a = Math.round(layer.opacity * 255).toString(16).padStart(2, '0');
    const r = layer.color.substr(1, 2);
    const g = layer.color.substr(3, 2);
    const b = layer.color.substr(5, 2);
    const kmlColor = a + b + g + r;

    kml += `${indent}  <Style><LineStyle>\n`;
    kml += `${indent}    <color>${kmlColor}</color>\n`;
    kml += `${indent}    <width>${layer.width}</width>\n`;
    kml += `${indent}  </LineStyle></Style>\n`;

    if (layer.type === 'line') {
        kml += `${indent}  <LineString>\n`;
        kml += `${indent}    <coordinates>\n`;
        layer.coords.forEach(c => {
            kml += `${indent}      ${c[1]},${c[0]},0\n`; // lng,lat,alt
        });
        kml += `${indent}    </coordinates>\n`;
        kml += `${indent}  </LineString>\n`;
    } else if (layer.type === 'point') {
        kml += `${indent}  <Point>\n`;
        kml += `${indent}    <coordinates>${layer.coords[0][1]},${layer.coords[0][0]},0</coordinates>\n`;
        kml += `${indent}  </Point>\n`;
    }

    kml += `${indent}</Placemark>\n`;
    return kml;
}

// === EXPORT: SIMPLIFIED GEOJSON ===
function exportSimplifiedGeoJSON() {
    const features = [];
    let totalOriginal = 0;
    let totalSimplified = 0;

    Object.values(projectData.layers).forEach(layer => {
        if (layer.type !== 'line') return; // Only LineStrings
        totalOriginal += layer.originalCoords.length;
        totalSimplified += layer.coords.length;

        features.push({
            type: 'Feature',
            properties: {
                name: layer.name,
                stroke: layer.color,
                'stroke-width': layer.width,
                'stroke-opacity': layer.opacity,
                originalPoints: layer.originalCoords.length,
                simplifiedPoints: layer.coords.length
            },
            geometry: {
                type: 'LineString',
                coordinates: layer.coords.map(c => [c[1], c[0]]) // GeoJSON: [lng, lat]
            }
        });
    });

    if (features.length === 0) {
        toast('No line layers to export', 'error');
        return;
    }

    const geojson = {
        type: 'FeatureCollection',
        properties: {
            generator: 'NexiMap KML Studio v1.0',
            exportDate: new Date().toISOString(),
            totalFeatures: features.length,
            totalOriginalPoints: totalOriginal,
            totalSimplifiedPoints: totalSimplified
        },
        features: features
    };

    const fileName = `Simplified_GeoJSON_${getProjectName()}.geojson`;
    downloadFile(JSON.stringify(geojson, null, 2), fileName, 'application/geo+json');
    toast(`Exported ${features.length} lines as simplified GeoJSON`, 'success');
}

function getProjectName() {
    const rootFolders = projectData.folders.filter(f => !f.parentId);
    if (rootFolders.length === 1) return rootFolders[0].name.replace(/[^a-zA-Z0-9_-]/g, '_');
    if (rootFolders.length > 1) return 'merged_' + rootFolders.length + '_files';
    return 'export';
}

// === UTILS ===
function downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function escHtml(s) {
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
}

function escXml(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function toast(msg, type = 'info') {
    const container = document.getElementById('toastContainer');
    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.textContent = msg;
    container.appendChild(t);
    setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 3000);
}

function updateStatus() {
    const layerCount = Object.keys(projectData.layers).length;
    const totalPts = Object.values(projectData.layers).reduce((sum, l) => sum + l.coords.length, 0);
    document.getElementById('statusText').textContent = `${layerCount} layers · ${totalPts.toLocaleString()} vertices`;
}

// === RESIZE HANDLE ===
const leftResize = document.getElementById('leftResize');
let resizing = false;
leftResize.addEventListener('mousedown', (e) => {
    resizing = true;
    leftResize.classList.add('active');
    document.addEventListener('mousemove', onResize);
    document.addEventListener('mouseup', () => {
        resizing = false;
        leftResize.classList.remove('active');
        document.removeEventListener('mousemove', onResize);
        map.invalidateSize();
    }, { once: true });
});

function onResize(e) {
    const panel = document.getElementById('leftPanel');
    const newWidth = Math.max(200, Math.min(450, e.clientX));
    panel.style.width = newWidth + 'px';
}

// Init
updateStatus();

// Expose functions to global scope for onclick handlers
window.openKMLFile = openKMLFile;
window.openMergeFiles = openMergeFiles;
window.handleFileOpen = handleFileOpen;
window.handleMergeFiles = handleMergeFiles;
window.saveKML = saveKML;
window.exportSimplifiedGeoJSON = exportSimplifiedGeoJSON;
window.toggleEditMode = toggleEditMode;
window.toggleAddPointMode = toggleAddPointMode;
window.createNewFolder = createNewFolder;
window.selectAllItems = selectAllItems;
window.updateSelectedName = updateSelectedName;
window.updateSelectedColor = updateSelectedColor;
window.updateSelectedWidth = updateSelectedWidth;
window.updateSelectedOpacity = updateSelectedOpacity;
window.previewSimplify = previewSimplify;
window.applySimplify = applySimplify;
window.undoSimplify = undoSimplify;
window.zoomToSelected = zoomToSelected;
window.duplicateSelected = duplicateSelected;
window.deleteSelected = deleteSelected;
window.ctxRename = ctxRename;
window.ctxDuplicate = ctxDuplicate;
window.ctxZoomTo = ctxZoomTo;
window.ctxMoveToFolder = ctxMoveToFolder;
window.ctxDelete = ctxDelete;

})(); // end async init
</script>
</body>
</html>
